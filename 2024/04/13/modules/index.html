<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Linux内核模块自动加载机制的探索 · Big7ng's Blog</title><meta name="description" content="Linux内核模块自动加载机制的探索 - Big7ng"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://big7ng.github.io/atom.xml" title="Big7ng's Blog"><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="Big7ng's Blog" type="application/atom+xml">
</head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/Big7ng" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Linux内核模块自动加载机制的探索</h1><div class="post-info">Apr 13, 2024</div><div class="post-content"><p>在编译内核的时候，如果将某一功能编译成内核模块，那需要我们手动输入<code>insmod</code>或者<code>modprobe</code>命令进行加载吗？</p>
<p>经过实践发现，内核会在插入设备的时候自动加载相应的驱动模块，这是怎么实现的？本文接下来将进行一系列探索。</p>
<h1 id="从dmesg开始"><a href="#从dmesg开始" class="headerlink" title="从dmesg开始"></a>从dmesg开始</h1><p>USB声卡插入插槽，如果把SND_USB_AUDIO编译进内核，即<code>CONFIG_SND_USB_AUDIO=y</code>时，dmesg出现如下输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[574786.075305] usb 3-1: new full-speed USB device number 3 using ohci-platform</span><br><span class="line">[574786.301945] usb 3-1: New USB device found, idVendor=4459, idProduct=3233, bcdDevice= 1.00</span><br><span class="line">[574786.302014] usb 3-1: New USB device strings: Mfr=1, Product=2, SerialNumber=3</span><br><span class="line">[574786.302031] usb 3-1: Product: Yundea M1066</span><br><span class="line">[574786.302045] usb 3-1: Manufacturer: Yundea Technology</span><br><span class="line">[574786.302059] usb 3-1: SerialNumber: 433036323231382E</span><br><span class="line">[574786.306246] usb-storage 3-1:1.0: USB Mass Storage device detected</span><br><span class="line">[574786.310691] scsi host3: usb-storage 3-1:1.0</span><br><span class="line">[574787.341957] scsi 3:0:0:0: Direct-Access     BR25     UDISK            1.00 PQ: 0 ANSI: 2</span><br><span class="line">[574787.369983] sd 3:0:0:0: [sdc] Attached SCSI removable disk</span><br></pre></td></tr></table></figure>

<p>如果把SND_USB_AUDIO编译成模块，即<code>CONFIG_SND_USB_AUDIO=m</code>时，dmesg出现如下输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[ 1768.962881] usb 3-2: new full-speed USB device number 5 using xhci_hcd</span><br><span class="line">[ 1769.311093] usb 3-2: New USB device found, idVendor=4459, idProduct=3233, bcdDevice= 1.00</span><br><span class="line">[ 1769.311095] usb 3-2: New USB device strings: Mfr=1, Product=2, SerialNumber=3</span><br><span class="line">[ 1769.311096] usb 3-2: Product: Yundea M1066</span><br><span class="line">[ 1769.311097] usb 3-2: Manufacturer: Yundea Technology</span><br><span class="line">[ 1769.311098] usb 3-2: SerialNumber: 433036323231382E</span><br><span class="line">[ 1769.327878] mc: Linux media interface: v0.10</span><br><span class="line">[ 1769.328662] usb-storage 3-2:1.0: USB Mass Storage device detected</span><br><span class="line">[ 1769.329237] scsi host33: usb-storage 3-2:1.0</span><br><span class="line">[ 1769.329370] usbcore: registered new interface driver usb-storage</span><br><span class="line">[ 1769.331443] usbcore: registered new interface driver uas</span><br><span class="line">[ 1769.443024] usbcore: registered new interface driver snd-usb-audio</span><br><span class="line">[ 1770.339466] scsi 33:0:0:0: Direct-Access     BR25     UDISK            1.00 PQ: 0 ANSI: 2</span><br><span class="line">[ 1770.339900] sd 33:0:0:0: Attached scsi generic sg2 type 0</span><br><span class="line">[ 1770.409154] sd 33:0:0:0: [sdb] Attached SCSI removable disk</span><br></pre></td></tr></table></figure>

<p>我们接下来分析一下驱动编译为内核模块时USB插入后内核的响应：</p>
<ol>
<li>在USB端口3-2检测到一个新的全速USB设备,并使用xHCI（eXtensible Host Controller Interface）USB主机控制器；</li>
<li>获取该USB设备的信息，包括供应商ID(4459)、产品ID(3233)、设备版本号(1.00)；</li>
<li><code>Mfr=1</code>表示制造商信息在USB设备字符串索引1中，<code>Product=2</code>表示产品信息在USB设备字符串索引2中，<code>SerialNumber=3</code>表示序列号信息在USB设备字符串索引3中；</li>
<li>获取产品名称、制造商、序列号；</li>
<li>表示Linux媒体接口(Media Controller)已启用；</li>
<li>表示检测到USB设备是一个USB大容量存储设备；</li>
<li>为USB大容量存储设备创建了一个新的SCSI主机设备；</li>
<li>内核注册了新的USB驱动程序：usb-storage、uas、snd-usb-audio；</li>
<li>提供了SCSI设备的信息,显示它是一个Direct-Access可直接访问的存储设备,型号为”BR25 UDISK”,固件版本为1.00；<code>33:0:0:0</code>是该SCSI设备的唯一标识符，<code>PQ: 1</code>表示”Peripheral Qualifier”(外围设备限定符)为0，意味着设备可以正常使用，<code>ANSI: 2</code>表示设备遵循的ANSI SCSI标准版本为2；</li>
<li>SCSI设备已作为一个通用SCSI设备附加；</li>
<li>SCSI设备已被附加为一个可移动磁盘,设备名为”sdb”。</li>
</ol>
<p>经过对比可以看到，把驱动编译成模块，在usb插入后会自动加载相应的模块，这里有三条加载驱动信息是因为该内核配置了<code>CONFIG_USB_STORAGE</code>、<code>CONFIG_USB_UAS=m</code>，即usb存储驱动与<a target="_blank" rel="noopener" href="https://linux-sunxi.org/USB/UAS">USB Attached SCSI</a>驱动。</p>
<p>为什么会有“usbcore: registered new interface driver snd-usb-audio”这一系列输出，是谁输出的？</p>
<h1 id="usbcore是谁输出的？"><a href="#usbcore是谁输出的？" class="headerlink" title="usbcore是谁输出的？"></a>usbcore是谁输出的？</h1><p>观察dmesg中关于自动加载驱动的输出，通过查找内核源码可以将其定位为<code>usb_register_driver</code>函数。</p>
<p><code>usb_register_driver</code>声明，位于<code>/include/linux/usb.h</code>中，在该头文件中，<code>usb_register</code>、<code>module_usb_driver</code>、<code>module_usb_stor_driver</code>函数对其进行了封装。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * use these in module_init()/module_exit()</span></span><br><span class="line"><span class="comment"> * and don&#x27;t forget MODULE_DEVICE_TABLE(usb, ...)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">usb_register_driver</span><span class="params">(<span class="keyword">struct</span> usb_driver *, <span class="keyword">struct</span> module *,</span></span><br><span class="line"><span class="params">			       <span class="type">const</span> <span class="type">char</span> *)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* use a define to avoid include chaining to get THIS_MODULE &amp; friends */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> usb_register(driver) \</span></span><br><span class="line"><span class="meta">	usb_register_driver(driver, THIS_MODULE, KBUILD_MODNAME)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * module_usb_driver() - Helper macro for registering a USB driver</span></span><br><span class="line"><span class="comment"> * @__usb_driver: usb_driver struct</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Helper macro for USB drivers which do not do anything special in module</span></span><br><span class="line"><span class="comment"> * init/exit. This eliminates a lot of boilerplate. Each module may only</span></span><br><span class="line"><span class="comment"> * use this macro once, and calling it replaces module_init() and module_exit()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> module_usb_driver(__usb_driver) \</span></span><br><span class="line"><span class="meta">	module_driver(__usb_driver, usb_register, \</span></span><br><span class="line"><span class="meta">		       usb_deregister)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> module_usb_stor_driver(__driver, __sht, __name) \</span></span><br><span class="line"><span class="meta">static int __init __driver##_init(void) \</span></span><br><span class="line"><span class="meta">&#123; \</span></span><br><span class="line"><span class="meta">	usb_stor_host_template_init(&amp;(__sht), __name, THIS_MODULE); \</span></span><br><span class="line"><span class="meta">	return usb_register(&amp;(__driver)); \</span></span><br><span class="line"><span class="meta">&#125; \</span></span><br><span class="line"><span class="meta">module_init(__driver##_init); \</span></span><br><span class="line"><span class="meta">static void __exit __driver##_exit(void) \</span></span><br><span class="line"><span class="meta">&#123; \</span></span><br><span class="line"><span class="meta">	usb_deregister(&amp;(__driver)); \</span></span><br><span class="line"><span class="meta">&#125; \</span></span><br><span class="line"><span class="meta">module_exit(__driver##_exit)</span></span><br></pre></td></tr></table></figure>

<p><code>usb_register_driver</code>定义，位于<code>/drivers/usb/core/driver.c</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * usb_register_driver - register a USB interface driver</span></span><br><span class="line"><span class="comment"> * @new_driver: USB operations for the interface driver</span></span><br><span class="line"><span class="comment"> * @owner: module owner of this driver.</span></span><br><span class="line"><span class="comment"> * @mod_name: module name string</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Registers a USB interface driver with the USB core.  The list of</span></span><br><span class="line"><span class="comment"> * unattached interfaces will be rescanned whenever a new driver is</span></span><br><span class="line"><span class="comment"> * added, allowing the new driver to attach to any recognized interfaces.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Return: A negative error code on failure and 0 on success.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">NOTE:</span> if you want your driver to use the USB major number, you must call</span></span><br><span class="line"><span class="comment"> * usb_register_dev() to enable that functionality.  This function no longer</span></span><br><span class="line"><span class="comment"> * takes care of that.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">usb_register_driver</span><span class="params">(<span class="keyword">struct</span> usb_driver *new_driver, <span class="keyword">struct</span> module *owner,</span></span><br><span class="line"><span class="params">			<span class="type">const</span> <span class="type">char</span> *mod_name)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> retval = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (usb_disabled())</span><br><span class="line">		<span class="keyword">return</span> -ENODEV;</span><br><span class="line"></span><br><span class="line">	new_driver-&gt;driver.name = new_driver-&gt;name;</span><br><span class="line">	new_driver-&gt;driver.bus = &amp;usb_bus_type;</span><br><span class="line">	new_driver-&gt;driver.probe = usb_probe_interface;</span><br><span class="line">	new_driver-&gt;driver.remove = usb_unbind_interface;</span><br><span class="line">	new_driver-&gt;driver.owner = owner;</span><br><span class="line">	new_driver-&gt;driver.mod_name = mod_name;</span><br><span class="line">	new_driver-&gt;driver.dev_groups = new_driver-&gt;dev_groups;</span><br><span class="line">	spin_lock_init(&amp;new_driver-&gt;dynids.lock);</span><br><span class="line">	INIT_LIST_HEAD(&amp;new_driver-&gt;dynids.<span class="built_in">list</span>);</span><br><span class="line"></span><br><span class="line">	retval = driver_register(&amp;new_driver-&gt;driver);</span><br><span class="line">	<span class="keyword">if</span> (retval)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	retval = usb_create_newid_files(new_driver);</span><br><span class="line">	<span class="keyword">if</span> (retval)</span><br><span class="line">		<span class="keyword">goto</span> out_newid;</span><br><span class="line"></span><br><span class="line">	pr_info(<span class="string">&quot;%s: registered new interface driver %s\n&quot;</span>,</span><br><span class="line">			usbcore_name, new_driver-&gt;name);	<span class="meta">#dmesg中的usbcore输出</span></span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">return</span> retval;</span><br><span class="line"></span><br><span class="line">out_newid:</span><br><span class="line">	driver_unregister(&amp;new_driver-&gt;driver);</span><br><span class="line"></span><br><span class="line">	pr_err(<span class="string">&quot;%s: error %d registering interface driver %s\n&quot;</span>,</span><br><span class="line">		usbcore_name, retval, new_driver-&gt;name);</span><br><span class="line">	<span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(usb_register_driver);</span><br></pre></td></tr></table></figure>

<p>通过函数的定义发现，是<code>usb_register_driver</code>内核函数在dmesg中打印了usbcore的信息。</p>
<p>uas驱动中，<code>root/driver/usb/storage/uas.c</code>文件调用了<code>uas_init</code>，uas_init调用了<code>usb_register</code>函数；</p>
<p>usb-storage驱动中，<code>/root/driver/usb/storage/usb.c</code>文件调用了<code>module_usb_stor_driver</code>函数；</p>
<p>snd-usb-audio驱动中，<code>/root/sound/usb/card.c</code>文件调用了<code>module_usb_driver</code>函数。</p>
<p>因此，在安装这些usb驱动的时候，会自动向dmesg输出内容，那么，是谁安装了这些驱动呢？</p>
<h1 id="udev"><a href="#udev" class="headerlink" title="udev"></a>udev</h1><p>udev 负责监听 Linux 内核发出的改变设备状态的事件，例如一个 USB 设备被插入或拔出。</p>
<p>使用 systemd 的机器上，udev 操作由 <code>systemd-udevd</code> 守护进程管理，可以通过常规的 systemd 方式使用 <code>systemctl status </code>命令 检查 udev 守护进程的状态：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl status systemd-udevd</span><br><span class="line">systemctl status udev</span><br></pre></td></tr></table></figure>

<p>udev 通过序列号、制造商、以及提供商 ID 和产品 ID 号来识别设备。</p>
<h3 id="udevadm"><a href="#udevadm" class="headerlink" title="udevadm"></a>udevadm</h3><p>udevadm(udev administrator), 是一个 udev 管理工具，可用于查询 udev 数据库中的设备信息，也可以从 sysfs 文件系统中查询到设备的属性以辅助创建 udev 规则。</p>
<p>使用 <code>udevadm monitor</code> 命令你可以实时利用 udev，并且可以看到当你插入不同设备时发生了什么。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo udevadm monitor</span><br></pre></td></tr></table></figure>

<p>该监视函数输出接收到的事件：</p>
<ul>
<li>KERNEL：内核发送 uevent 事件, udev 守护进程侦听来自内核的 uevent，以此添加或者删除 &#x2F;dev下的设备文件</li>
<li>UDEV：在规则处理之后发出 udev 事件</li>
</ul>
<p>以下内容是插入USB声卡后udevadm monitor的输出（节选）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">KERNEL[22751.610627] add      /devices/pci0000:00/0000:00:15.0/0000:03:00.0/usb3/3-2 (usb)</span><br><span class="line">KERNEL[22751.616782] add      /devices/pci0000:00/0000:00:15.0/0000:03:00.0/usb3/3-2/3-2:1.0 (usb)</span><br><span class="line">KERNEL[22751.618458] add      /devices/pci0000:00/0000:00:15.0/0000:03:00.0/usb3/3-2/3-2:1.0/host33 (scsi)</span><br><span class="line">KERNEL[22751.618484] add      /devices/pci0000:00/0000:00:15.0/0000:03:00.0/usb3/3-2/3-2:1.0/host33/scsi_host/host33 (scsi_host)</span><br><span class="line">KERNEL[22751.620373] add      /devices/pci0000:00/0000:00:15.0/0000:03:00.0/usb3/3-2/3-2:1.1 (usb)</span><br><span class="line">KERNEL[22751.729567] add      /devices/pci0000:00/0000:00:15.0/0000:03:00.0/usb3/3-2/3-2:1.1/sound/card1 (sound)</span><br><span class="line">KERNEL[22751.730062] add      /devices/pci0000:00/0000:00:15.0/0000:03:00.0/usb3/3-2/3-2:1.1/sound/card1/pcmC1D0p (sound)</span><br><span class="line">KERNEL[22751.730387] add      /devices/pci0000:00/0000:00:15.0/0000:03:00.0/usb3/3-2/3-2:1.1/sound/card1/pcmC1D0c (sound)</span><br><span class="line">KERNEL[22751.730624] add      /devices/pci0000:00/0000:00:15.0/0000:03:00.0/usb3/3-2/3-2:1.1/sound/card1/controlC1 (sound)</span><br><span class="line">UDEV  [22751.739014] add      /devices/pci0000:00/0000:00:15.0/0000:03:00.0/usb3/3-2/3-2:1.1/sound/card1 (sound)</span><br><span class="line">UDEV  [22751.739301] add      /devices/pci0000:00/0000:00:15.0/0000:03:00.0/usb3/3-2/3-2:1.0/host33 (scsi)</span><br><span class="line">UDEV  [22751.740201] add      /devices/pci0000:00/0000:00:15.0/0000:03:00.0/usb3/3-2/3-2:1.0/host33/scsi_host/host33 (scsi_host)</span><br><span class="line">UDEV  [22751.740729] add      /devices/pci0000:00/0000:00:15.0/0000:03:00.0/usb3/3-2/3-2:1.1/sound/card1/pcmC1D0p (sound)</span><br><span class="line">KERNEL[22751.740740] change   /devices/pci0000:00/0000:00:15.0/0000:03:00.0/usb3/3-2/3-2:1.1/sound/card1 (sound)</span><br><span class="line">UDEV  [22751.740748] add      /devices/pci0000:00/0000:00:15.0/0000:03:00.0/usb3/3-2/3-2:1.1/sound/card1/pcmC1D0c (sound)</span><br><span class="line">UDEV  [22751.759173] add      /devices/pci0000:00/0000:00:15.0/0000:03:00.0/usb3/3-2/3-2:1.1/sound/card1/controlC1 (sound)</span><br><span class="line">UDEV  [22751.762417] change   /devices/pci0000:00/0000:00:15.0/0000:03:00.0/usb3/3-2/3-2:1.1/sound/card1 (sound)</span><br></pre></td></tr></table></figure>

<p> <code>udevadm info</code> 命令去查询 udev 数据库中的指定设备信息。<code>-q</code>, <code>--query=TYPE</code> ：从数据库中查询指定类型的设备，需要使用 <code>--path</code> 和 <code>--name</code> 选项指定设备。合法的 TYPE 类型包括：设备名（name），链接（symlink），路径（path），属性（property）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">udevadm info -q path -n /dev/sdc1</span><br></pre></td></tr></table></figure>


<h3 id="udev规则"><a href="#udev规则" class="headerlink" title="udev规则"></a>udev规则</h3><p>udev 的工作方式是试图将它收到的每个系统事件与 <code>/lib/udev/rules.d/</code> 和 <code>/etc/udev/rules.d/</code> 目录下找到的规则集进行匹配。</p>
<p>udev 规则是定义在一个以 <code>.rules</code> 为扩展名的文件中。那些文件主要放在两个位置：<code>/usr/lib/udev/rules.d</code>，这个目录用于存放系统安装的规则；<code>/etc/udev/rules.d/</code> 这个目录是保留给自定义规则的。如果两个目录下均有相同的文件，则以<code>/etc/udev/rules.d/</code> 中的文件为准。</p>
<p>规则文件包括匹配键和分配键，可用的匹配键包括 <code>action</code>、<code>name</code> 和 <code>subsystem</code>。这意味着如果探测到一个属于某个子系统的、带有特定名称的设备，就会给设备指定一个预设的配置，例如执行一段脚本。</p>
<p><code>ACTION</code> 键：通过使用它，当在一个设备上发生了特定的事件，我们将指定我们要应用的规则的具体内容。有效的值有 <code>add</code>、<code>remove </code>以及 <code>change</code>。然后，我们使用 <code>ATTRS</code> 关键字去指定一个属性去匹配。</p>
<p>&#x2F;lib&#x2F;udev&#x2F;rules.d&#x2F;80-drivers.rules中有<strong>自动加载驱动</strong>的规则如下，有了这一行，udev就可以根据插入设备的modalias自动加载相应的驱动模块了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ACTION!=&quot;add&quot;, GOTO=&quot;drivers_end&quot;</span><br><span class="line"></span><br><span class="line">ENV&#123;MODALIAS&#125;==&quot;?*&quot;, RUN&#123;builtin&#125;+=&quot;kmod load $env&#123;MODALIAS&#125;&quot;</span><br></pre></td></tr></table></figure>
<p>我们也看可以自己更改udev规则，更改后需要重新加载udev规则</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">udevadm control --reload</span><br></pre></td></tr></table></figure>


<h3 id="hwdb"><a href="#hwdb" class="headerlink" title="hwdb"></a>hwdb</h3><p>硬件数据库(HWDB)是一个由”<a target="_blank" rel="noopener" href="https://wiki.archlinux.org/title/Modalias">modalias</a>“风格的键(key)与”udev属性”风格的值(value)组成的 key-value 文本数据库。 主要用于 udev 为匹配到的硬件设备添加关联属性， 但也可以用于直接查询。</p>
<p>每个硬件数据库文件(hwdb)都包含一系列由”matche”与关联的”key-value”组成的记录。</p>
<p>&#x2F;lib&#x2F;udev&#x2F;hwdb.d&#x2F;20-usb-classes.hwdb文件中有如下一行:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">usb:v*p*d*dc01*</span><br><span class="line"> ID_USB_CLASS_FROM_DATABASE=Audio</span><br></pre></td></tr></table></figure>



<p>参考资料</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/51984452">https://zhuanlan.zhihu.com/p/51984452</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/33932734">https://zhuanlan.zhihu.com/p/33932734</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jinbuguo.com/systemd/hwdb.html">https://www.jinbuguo.com/systemd/hwdb.html</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jinbuguo.com/systemd/systemd-hwdb.html">https://www.jinbuguo.com/systemd/systemd-hwdb.html</a></p>
<p><a target="_blank" rel="noopener" href="https://documentation.suse.com/zh-cn/sles/12-SP5/html/SLES-all/cha-udev.html">https://documentation.suse.com/zh-cn/sles/12-SP5/html/SLES-all/cha-udev.html</a></p>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/62835556/usb-why-usb-devices-the-modules-automatically-loaded">https://stackoverflow.com/questions/62835556/usb-why-usb-devices-the-modules-automatically-loaded</a></p>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/73811317/how-to-find-the-udev-rule-which-causes-the-loading-of-the-kernel-module-88xxau-k">https://stackoverflow.com/questions/73811317/how-to-find-the-udev-rule-which-causes-the-loading-of-the-kernel-module-88xxau-k</a></p>
</div></article></div></main><footer><div class="paginator"><a href="/2024/05/02/Linux_boot/" class="prev">PREV</a><a href="/2024/04/08/vocie/" class="next">NEXT</a></div><div class="copyright"><p>© 2022 - 2024 <a href="https://big7ng.github.io">Big7ng</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>