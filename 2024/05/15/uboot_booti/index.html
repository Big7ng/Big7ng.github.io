<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> uboot加载linux内核与设备树机制的探索 · Big7ng's Blog</title><meta name="description" content="uboot加载linux内核与设备树机制的探索 - Big7ng"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://big7ng.github.io/atom.xml" title="Big7ng's Blog"><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="Big7ng's Blog" type="application/atom+xml">
</head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/Big7ng" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">uboot加载linux内核与设备树机制的探索</h1><div class="post-info">May 15, 2024</div><div class="post-content"><p>在重新编译Linux内核与设备树后，需要使用uboot加载新的内核与设备树。<br>开发板启动后，进入uboot命令行，执行以下命令：</p>
<p>设置环境变量<code>bootargs</code>启动参数：</p>
<ul>
<li>console&#x3D;ttyAMA1,115200：指定了控制台输出设备为ttyAMA1，波特率为115200。这意味着内核将在ttyAMA1上输出调试信息和控制台输入。</li>
<li>earlycon&#x3D;pl011,0x2800d000：指定了早期控制台设备为pl011，基地址为0x2800d000。早期控制台用于在内核初始化期间提供调试信息。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setenv bootargs &#x27;console=ttyAMA1,115200 earlycon=pl011,0x2800d000 root=/dev/mmcblk0p1 rootwait rw&#x27;</span><br></pre></td></tr></table></figure>
<p>加载内核至指定内存地址<code>0x90100000</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ext4load mmc 0:1 0x90100000 boot/Image</span><br></pre></td></tr></table></figure>
<p>加载设备树至指定内存地址<code>0x90000000</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ext4load mmc 0:1 0x90000000 boot/phytiumpi_firefly.dtb</span><br></pre></td></tr></table></figure>

<p>开始引导Linux系统，其中的<code>-</code>表明不使用initial RAM disk来启动内核，booti命令的使用细节可以参考<a target="_blank" rel="noopener" href="https://docs.u-boot.org/en/latest/usage/cmd/booti.html">uboot官方文档</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">booti 0x90100000 - 0x90000000</span><br></pre></td></tr></table></figure>

<p>若需要在每次开机时uboot自动执行以上命令，可以设置uboot中的<code>bootcmd</code>环境变量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setenv bootcmd &#x27;ext4load mmc 0:1 0x90100000 boot/Image; ext4load mmc 0:1 0x90000000 boot/phytiumpi_firefly.dtb; booti 0x90100000 - 0x90000000&#x27;</span><br></pre></td></tr></table></figure>

<p>上述操作过程引发了很多疑惑：0x90100000、0x90000000和0x2800d000这个地址是怎么来的呢？pl011是什么东西？内核与设备树加载到了两块地址上，那内核是如何获取设备树信息的呢？</p>
<h1 id="uboot中使用的地址"><a href="#uboot中使用的地址" class="headerlink" title="uboot中使用的地址"></a>uboot中使用的地址</h1><h3 id="0x2800d000"><a href="#0x2800d000" class="headerlink" title="0x2800d000"></a>0x2800d000</h3><p>首先是0x2800d000这个地址，通过查阅phytiumpi开发板的设备树文件，在pe220x.dtsi这个文件中找到了相关的信息，0x2800d000是uart1的映射地址。 </p>
<p>为什么是这个地址？查阅飞腾派芯片手册，0x000_2800_0000 ~ 0x000_2FFF_FFFF这块地址空间分配给了低速设备。</p>
<p>其中0x000_2800_D000 ~ 0x000_2800_DFFF 的4KB地址空间分配给了UART1。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">uart1: uart@2800d000 &#123;</span><br><span class="line">			compatible = &quot;arm,pl011&quot;,&quot;arm,primecell&quot;;</span><br><span class="line">			reg = &lt;0x0 0x2800d000 0x0 0x1000&gt;;</span><br><span class="line">			interrupts = &lt;GIC_SPI 84 IRQ_TYPE_LEVEL_HIGH&gt;;</span><br><span class="line">			clocks = &lt;&amp;sysclk_100mhz &amp;sysclk_100mhz&gt;;</span><br><span class="line">			clock-names = &quot;uartclk&quot;, &quot;apb_pclk&quot;;</span><br><span class="line">			status = &quot;disabled&quot;;</span><br><span class="line">		&#125;;</span><br></pre></td></tr></table></figure>

<p>不同的开发板有不同的设备树，因此这个地址是因设备的变化而变化的。</p>
<p>PL011指PrimeCell UART，是ARM公司设计的UART IP核，具体的文档可以在<a target="_blank" rel="noopener" href="https://developer.arm.com/documentation/ddi0183/g/">ARM官网</a>查看。</p>
<h3 id="0x90100000与0x90000000"><a href="#0x90100000与0x90000000" class="headerlink" title="0x90100000与0x90000000"></a>0x90100000与0x90000000</h3><p>在飞腾派中，0x000_8000_0000 ~ 0x000_FFFF_FFFF地址空间分配为Memory 空间，0x90100000与0x90000000均位于其中。</p>
<p>根据booti命令的参数，0x90000000为设备树的加载地址，0x90100000为Linux内核的加载地址。编译后的dtb大小为24.5KB，未压缩的内核大小为23.5MB，地址0x90000000与0x90100000之间的空间约为1048KB，足够设备树文件加载。经过查阅uboot源码，这两个地址是在移植uboot时进行设置的。</p>
<p>由于没有飞腾派移植uboot的源码，这里先展示以下rk3588的案例，<code>u-boot/include/configs/rk3588_common.h</code>中有如下配置：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ENV_MEM_LAYOUT_SETTINGS		\</span></span><br><span class="line"><span class="meta">	<span class="string">&quot;scriptaddr=0x00c00000\0&quot;</span>	\</span></span><br><span class="line"><span class="meta">	<span class="string">&quot;script_offset_f=0xffe000\0&quot;</span>	\</span></span><br><span class="line"><span class="meta">	<span class="string">&quot;script_size_f=0x2000\0&quot;</span>	\</span></span><br><span class="line"><span class="meta">	<span class="string">&quot;pxefile_addr_r=0x00e00000\0&quot;</span>	\</span></span><br><span class="line"><span class="meta">	<span class="string">&quot;kernel_addr_r=0x02000000\0&quot;</span>	\</span></span><br><span class="line"><span class="meta">	<span class="string">&quot;kernel_comp_addr_r=0x0a000000\0&quot;</span>	\</span></span><br><span class="line"><span class="meta">	<span class="string">&quot;fdt_addr_r=0x12000000\0&quot;</span>	\</span></span><br><span class="line"><span class="meta">	<span class="string">&quot;fdtoverlay_addr_r=0x12100000\0&quot;</span>	\</span></span><br><span class="line"><span class="meta">	<span class="string">&quot;ramdisk_addr_r=0x12180000\0&quot;</span>	\</span></span><br><span class="line"><span class="meta">	<span class="string">&quot;kernel_comp_size=0x8000000\0&quot;</span></span></span><br></pre></td></tr></table></figure>

<p>可以看从中看出，内核加载地址为0x02000000，设备树加载地址为0x12000000。因此这部分地址也是根据不同的芯片而改变的。</p>
<h3 id="booti-bootz与bootm"><a href="#booti-bootz与bootm" class="headerlink" title="booti,bootz与bootm"></a>booti,bootz与bootm</h3><p>uboot能启动的内核格式：Image, zImage, uImage, fdt方式。</p>
<p>uboot提供了三种命令来启动内核：<a target="_blank" rel="noopener" href="https://docs.u-boot.org/en/latest/usage/cmd/booti.html">booti</a>, <a target="_blank" rel="noopener" href="https://docs.u-boot.org/en/latest/usage/cmd/bootz.html">bootz</a>, <a target="_blank" rel="noopener" href="https://docs.u-boot.org/en/latest/usage/cmd/bootm.html">bootm</a>三个命令，分别用于对应Image, zImage, ulmage&#x2F;FIT三种内核格式:</p>
<ul>
<li>Image: 内核的原始烧录镜像文件, 也可以对他进行压缩, 根据不同的压缩算法有不同的文件名, gzip算法为Image.gz.</li>
<li>zImage: 压缩后的内核烧录镜像文件, 采用的是自压缩算法(不需要额外的解压器).</li>
<li>uImage:  这是uboot提供的一种内核Wrapper, 包含了内核烧录镜像与其他信息。由于uImage存在很大限制与安全隐患, 已不被官方支持, 现称其为legacy image format。</li>
<li><a target="_blank" rel="noopener" href="https://docs.u-boot.org/en/latest/usage/fit/index.html">FIT</a>: Flat Image Tree (FIT)是最新的uImage文件, 为了更好的支持单个固件的通用性，类似于kernel device tree机制，uboot也需要对这种uImage固件进行支持。FIT uImage中加入多个dtb文件，和ramdisak文件，当然如果需要的话，同样可以支持多个kernel文件。这样的目的就是能够使同一个uImage就能够在uboot中选择特定的kernel&#x2F;dtb和ramdisk进行启动了，达成一个uImage可以通用多个板型的目的。</li>
</ul>
<h1 id="Boot流程分析"><a href="#Boot流程分析" class="headerlink" title="Boot流程分析"></a>Boot流程分析</h1><h3 id="uboot是如何引导Boot-image的？"><a href="#uboot是如何引导Boot-image的？" class="headerlink" title="uboot是如何引导Boot image的？"></a>uboot是如何引导Boot image的？</h3><p>接下来将对uboot源码进行分析，最新以及历史的uboot源码可以在Bootlin的Elixir Cross Referencer中<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/u-boot/latest/source">查看</a>。</p>
<p>Boot流程主要用了两个结构体：bootm_info与bootm_headers，定义均位于<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/u-boot/latest/source">&#x2F;</a><a target="_blank" rel="noopener" href="https://elixir.bootlin.com/u-boot/latest/source/include">include</a>&#x2F;<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/u-boot/latest/source/include/bootm.h">bootm.h</a>文件中。</p>
<p>bootm_info结构体用于存储Boot系统所需的信息：镜像地址、ramdisk地址、fdt设备树地址等。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bootm_info</span> &#123;</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *addr_img;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *conf_ramdisk;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *conf_fdt;</span><br><span class="line">	<span class="type">bool</span> boot_progress;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">bootm_headers</span> *<span class="title">images</span>;</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *cmd_name;</span><br><span class="line">	<span class="type">int</span> argc;</span><br><span class="line">	<span class="type">char</span> *<span class="type">const</span> *argv;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>bootm_headers记录了image镜像的具体信息。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Legacy and FIT format headers used by do_bootm() and do_bootm_&lt;os&gt;() routines.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bootm_headers</span> &#123;</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Legacy os image header, if it is a multi component image</span></span><br><span class="line"><span class="comment">	 * then boot_get_ramdisk() and get_fdt() will attempt to get</span></span><br><span class="line"><span class="comment">	 * data from second and third component accordingly.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">legacy_img_hdr</span>	*<span class="title">legacy_hdr_os</span>;</span>		<span class="comment">/* image header pointer */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">legacy_img_hdr</span>	<span class="title">legacy_hdr_os_copy</span>;</span>	<span class="comment">/* header copy */</span></span><br><span class="line">	ulong		legacy_hdr_valid;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * The fit_ members are only used with FIT, but it involves a lot of</span></span><br><span class="line"><span class="comment">	 * #ifdefs to avoid compiling that code. Since FIT is the standard</span></span><br><span class="line"><span class="comment">	 * format, even for SPL, this extra data size seems worth it.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>	*fit_uname_cfg;	<span class="comment">/* configuration node unit name */</span></span><br><span class="line"></span><br><span class="line">	<span class="type">void</span>		*fit_hdr_os;	<span class="comment">/* os FIT image header */</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>	*fit_uname_os;	<span class="comment">/* os subimage node unit name */</span></span><br><span class="line">	<span class="type">int</span>		fit_noffset_os;	<span class="comment">/* os subimage node offset */</span></span><br><span class="line"></span><br><span class="line">	<span class="type">void</span>		*fit_hdr_rd;	<span class="comment">/* init ramdisk FIT image header */</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>	*fit_uname_rd;	<span class="comment">/* init ramdisk subimage node unit name */</span></span><br><span class="line">	<span class="type">int</span>		fit_noffset_rd;	<span class="comment">/* init ramdisk subimage node offset */</span></span><br><span class="line"></span><br><span class="line">	<span class="type">void</span>		*fit_hdr_fdt;	<span class="comment">/* FDT blob FIT image header */</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>	*fit_uname_fdt;	<span class="comment">/* FDT blob subimage node unit name */</span></span><br><span class="line">	<span class="type">int</span>		fit_noffset_fdt;<span class="comment">/* FDT blob subimage node offset */</span></span><br><span class="line"></span><br><span class="line">	<span class="type">void</span>		*fit_hdr_setup;	<span class="comment">/* x86 setup FIT image header */</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>	*fit_uname_setup; <span class="comment">/* x86 setup subimage node name */</span></span><br><span class="line">	<span class="type">int</span>		fit_noffset_setup;<span class="comment">/* x86 setup subimage node offset */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> USE_HOSTCC</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">image_info</span>	<span class="title">os</span>;</span>		<span class="comment">/* os image info */</span></span><br><span class="line">	ulong		ep;		<span class="comment">/* entry point of OS */</span></span><br><span class="line"></span><br><span class="line">	ulong		rd_start, rd_end;<span class="comment">/* ramdisk start/end */</span></span><br><span class="line"></span><br><span class="line">	<span class="type">char</span>		*ft_addr;	<span class="comment">/* flat dev tree address */</span></span><br><span class="line">	ulong		ft_len;		<span class="comment">/* length of flat device tree */</span></span><br><span class="line"></span><br><span class="line">	ulong		initrd_start;</span><br><span class="line">	ulong		initrd_end;</span><br><span class="line">	ulong		cmdline_start;</span><br><span class="line">	ulong		cmdline_end;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">bd_info</span>		*<span class="title">kbd</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span>		verify;		<span class="comment">/* env_get(&quot;verify&quot;)[0] != &#x27;n&#x27; */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BOOTM_STATE_START	0x00000001</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BOOTM_STATE_FINDOS	0x00000002</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BOOTM_STATE_FINDOTHER	0x00000004</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BOOTM_STATE_LOADOS	0x00000008</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BOOTM_STATE_RAMDISK	0x00000010</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BOOTM_STATE_FDT		0x00000020</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BOOTM_STATE_OS_CMDLINE	0x00000040</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BOOTM_STATE_OS_BD_T	0x00000080</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BOOTM_STATE_OS_PREP	0x00000100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BOOTM_STATE_OS_FAKE_GO	0x00000200	<span class="comment">/* &#x27;Almost&#x27; run the OS */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BOOTM_STATE_OS_GO	0x00000400</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BOOTM_STATE_PRE_LOAD	0x00000800</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BOOTM_STATE_MEASURE	0x00001000</span></span><br><span class="line">	<span class="type">int</span>		state;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_LMB) &amp;&amp; !defined(USE_HOSTCC)</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">lmb</span>	<span class="title">lmb</span>;</span>		<span class="comment">/* for memory mgmt */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>本文使用了<code>booti</code>命令来启动内核，命令源码<a target="_blank" rel="noopener" href="https://github.com/u-boot/u-boot/blob/master/cmd/booti.c">uboot&#x2F;cmd&#x2F;booti.c</a>文件中。当在uboot命令行中输入<code>booti</code>时，调用了<code>do_booti</code>函数。</p>
<p>do_booti主要进行了如下操作：</p>
<ol>
<li>初始化bootm_info结构体, 其中调用了<code>bootm_init</code>函数;</li>
<li>调用<code>booti_start</code>函数加载image镜像至内存中；</li>
<li>关闭中断, 调用<code>bootm_run_states</code>函数启动Linux系统, <code>bootm_run_states</code>函数根据不同的state参数进行不同的操作。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">do_booti</span><span class="params">(<span class="keyword">struct</span> cmd_tbl *cmdtp, <span class="type">int</span> flag, <span class="type">int</span> argc, <span class="type">char</span> *<span class="type">const</span> argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">bootm_info</span> <span class="title">bmi</span>;</span></span><br><span class="line">	<span class="type">int</span> states;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Consume &#x27;booti&#x27; */</span></span><br><span class="line">	argc--; argv++;</span><br><span class="line"></span><br><span class="line">	bootm_init(&amp;bmi);	<span class="comment">//初始化bmi结构体，设置为空</span></span><br><span class="line">	<span class="keyword">if</span> (argc)</span><br><span class="line">		bmi.addr_img = argv[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">if</span> (argc &gt; <span class="number">1</span>)</span><br><span class="line">		bmi.conf_ramdisk = argv[<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">if</span> (argc &gt; <span class="number">2</span>)</span><br><span class="line">		bmi.conf_fdt = argv[<span class="number">2</span>];</span><br><span class="line">	bmi.boot_progress = <span class="literal">true</span>;</span><br><span class="line">	bmi.cmd_name = <span class="string">&quot;booti&quot;</span>;</span><br><span class="line">	<span class="comment">/* do not set up argc and argv[] since nothing uses them */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (booti_start(&amp;bmi))	<span class="comment">//booti_start运行成功，返回0</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * We are doing the BOOTM_STATE_LOADOS state ourselves, so must</span></span><br><span class="line"><span class="comment">	 * disable interrupts ourselves</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	bootm_disable_interrupts();</span><br><span class="line"></span><br><span class="line">	images.os.os = IH_OS_LINUX;		<span class="comment">//启动镜像类型</span></span><br><span class="line">	<span class="keyword">if</span> (IS_ENABLED(CONFIG_RISCV_SMODE))</span><br><span class="line">		images.os.arch = IH_ARCH_RISCV;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (IS_ENABLED(CONFIG_ARM64))</span><br><span class="line">		images.os.arch = IH_ARCH_ARM64;		<span class="comment">//选择启动镜像架构</span></span><br><span class="line"></span><br><span class="line">	states = BOOTM_STATE_MEASURE | BOOTM_STATE_OS_PREP |</span><br><span class="line">		BOOTM_STATE_OS_FAKE_GO | BOOTM_STATE_OS_GO;</span><br><span class="line">	<span class="keyword">if</span> (IS_ENABLED(CONFIG_SYS_BOOT_RAMDISK_HIGH))</span><br><span class="line">		states |= BOOTM_STATE_RAMDISK;</span><br><span class="line"></span><br><span class="line">	ret = bootm_run_states(&amp;bmi, states);	<span class="comment">//启动Linux系统</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>booti_start函数进行了如下操作:</p>
<ol>
<li><p>调用<code>bootm_run_states</code>函数, state参数设置为<code>BOOTM_STATE_START</code>, 执行<code>bootm_start</code>函数,初始化bootm_header结构体;</p>
</li>
<li><p>调用<code>image_decomp_type</code>检测image镜像是否被压缩, 若被压缩则进行解压;</p>
</li>
<li><p>调用<code>booti_setup</code>函数检测image镜像是否正确，返回Linux aarch64 Image的起始地址和大小;</p>
</li>
<li><p>调用<code>bootm_find_images</code>函数检测image镜像是否加载正确.</p>
</li>
</ol>
<p>综上, booti_start函数作用为配置并加载image镜像。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">booti_start</span><span class="params">(<span class="keyword">struct</span> bootm_info *bmi)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">bootm_headers</span> *<span class="title">images</span> =</span> bmi-&gt;images;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	ulong ld;</span><br><span class="line">	ulong relocated_addr;</span><br><span class="line">	ulong image_size;</span><br><span class="line">	<span class="type">uint8_t</span> *temp;</span><br><span class="line">	ulong dest;</span><br><span class="line">	ulong dest_end;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> comp_len;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> decomp_len;</span><br><span class="line">	<span class="type">int</span> ctype;</span><br><span class="line"></span><br><span class="line">	ret = bootm_run_states(bmi, BOOTM_STATE_START);		<span class="comment">//初始化</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Setup Linux kernel Image entry point */</span></span><br><span class="line">	<span class="keyword">if</span> (!bmi-&gt;addr_img) &#123;</span><br><span class="line">		ld = image_load_addr;</span><br><span class="line">		debug(<span class="string">&quot;*  kernel: default image load address = 0x%08lx\n&quot;</span>,</span><br><span class="line">				image_load_addr);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		ld = hextoul(bmi-&gt;addr_img, <span class="literal">NULL</span>);</span><br><span class="line">		debug(<span class="string">&quot;*  kernel: cmdline image address = 0x%08lx\n&quot;</span>, ld);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	temp = map_sysmem(ld, <span class="number">0</span>);</span><br><span class="line">	ctype = image_decomp_type(temp, <span class="number">2</span>); <span class="comment">//返回镜像的压缩类型，0表示未压缩</span></span><br><span class="line">	<span class="keyword">if</span> (ctype &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		dest = env_get_ulong(<span class="string">&quot;kernel_comp_addr_r&quot;</span>, <span class="number">16</span>, <span class="number">0</span>);</span><br><span class="line">		comp_len = env_get_ulong(<span class="string">&quot;kernel_comp_size&quot;</span>, <span class="number">16</span>, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span> (!dest || !comp_len) &#123;</span><br><span class="line">			<span class="built_in">puts</span>(<span class="string">&quot;kernel_comp_addr_r or kernel_comp_size is not provided!\n&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (dest &lt; gd-&gt;ram_base || dest &gt; gd-&gt;ram_top) &#123;</span><br><span class="line">			<span class="built_in">puts</span>(<span class="string">&quot;kernel_comp_addr_r is outside of DRAM range!\n&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		debug(<span class="string">&quot;kernel image compression type %d size = 0x%08lx address = 0x%08lx\n&quot;</span>,</span><br><span class="line">			ctype, comp_len, (ulong)dest);</span><br><span class="line">		decomp_len = comp_len * <span class="number">10</span>;</span><br><span class="line">		ret = image_decomp(ctype, <span class="number">0</span>, ld, IH_TYPE_KERNEL,</span><br><span class="line">				 (<span class="type">void</span> *)dest, (<span class="type">void</span> *)ld, comp_len,</span><br><span class="line">				 decomp_len, &amp;dest_end);</span><br><span class="line">		<span class="keyword">if</span> (ret)</span><br><span class="line">			<span class="keyword">return</span> ret;</span><br><span class="line">		<span class="comment">/* dest_end contains the uncompressed Image size */</span></span><br><span class="line">		memmove((<span class="type">void</span> *) ld, (<span class="type">void</span> *)dest, dest_end);</span><br><span class="line">	&#125;</span><br><span class="line">	unmap_sysmem((<span class="type">void</span> *)ld);</span><br><span class="line"></span><br><span class="line">	ret = booti_setup(ld, &amp;relocated_addr, &amp;image_size, <span class="literal">false</span>);	<span class="comment">//检测image地址和大小是否正确，0表示正确</span></span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Handle BOOTM_STATE_LOADOS */</span></span><br><span class="line">	<span class="keyword">if</span> (relocated_addr != ld) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Moving Image from 0x%lx to 0x%lx, end=%lx\n&quot;</span>, ld,</span><br><span class="line">		       relocated_addr, relocated_addr + image_size);</span><br><span class="line">		memmove((<span class="type">void</span> *)relocated_addr, (<span class="type">void</span> *)ld, image_size);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	images-&gt;ep = relocated_addr;</span><br><span class="line">	images-&gt;os.start = relocated_addr;</span><br><span class="line">	images-&gt;os.end = relocated_addr + image_size;</span><br><span class="line"></span><br><span class="line">	lmb_reserve(&amp;images-&gt;lmb, images-&gt;ep, le32_to_cpu(image_size));</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Handle the BOOTM_STATE_FINDOTHER state ourselves as we do not</span></span><br><span class="line"><span class="comment">	 * have a header that provide this informaiton.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (bootm_find_images(image_load_addr, bmi-&gt;conf_ramdisk, bmi-&gt;conf_fdt,</span><br><span class="line">			      relocated_addr, image_size))	<span class="comment">//加载image、ramdisk、fdt，如果加载成功，返回0</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>do_booti</code>最后一步调用<code>bootm_run_states</code>时states参数设置为BOOTM_STATE_MEASURE | BOOTM_STATE_OS_PREP |BOOTM_STATE_OS_FAKE_GO | BOOTM_STATE_OS_GO, <code>bootm_run_states</code>进行了如下操作:</p>
<ol>
<li>调用<code>bootm_measure</code>函数, 对image镜像进行测量（进行哈希处理并存储到安全内存（例如TPM PCR）的过程），用于安全认证；</li>
<li>调用<code>boot_fn = bootm_os_get_boot_func(images-&gt;os.os)</code>， 获取启动特定操作系统的函数指针（这里是Linux），结构体参数 images-&gt;os.os 就是系统类型，根据这个系统类型来选择对应的启动函数，在 do_booti 中设置了 images.os.os&#x3D; IH_OS_LINUX。函数返回值就是找到的系统启动函数，这里找到的 Linux 系统启动函数为 do_bootm_linux。因此 boot_fn&#x3D;<code>do_bootm_linux</code>，后面执行 boot_fn 函数的地方实际上是执行的 do_bootm_linux 函数；</li>
<li>调用boot_fn(BOOTM_STATE_OS_PREP, bmi)，进行启动image前的一些初始化工作，boot_prep_linux 主要用于处理环境变量 bootargs，bootargs 保存着传递给 Linux kernel 的参数；</li>
<li>boot_selected_os(BOOTM_STATE_OS_FAKE_GO, bmi, boot_fn)，<a target="_blank" rel="noopener" href="https://patchwork.ozlabs.org/project/uboot/patch/1370974493-21822-17-git-send-email-sjg@chromium.org/">fake go</a>用于完成执行跳转到OS image前的初始化，这个步骤用于保证能够追踪trace uboot系统记录直至最后一刻；</li>
<li>最后一步，调用boot_selected_os(BOOTM_STATE_OS_GO, bmi, boot_fn)函数，启动操作系统。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">bootm_run_states</span><span class="params">(<span class="keyword">struct</span> bootm_info *bmi, <span class="type">int</span> states)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">bootm_headers</span> *<span class="title">images</span> =</span> bmi-&gt;images;</span><br><span class="line">	boot_os_fn *boot_fn;</span><br><span class="line">	ulong iflag = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> ret = <span class="number">0</span>, need_boot_fn;</span><br><span class="line"></span><br><span class="line">	images-&gt;state |= states;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Work through the states and see how far we get. We stop on</span></span><br><span class="line"><span class="comment">	 * any error.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (states &amp; BOOTM_STATE_START)</span><br><span class="line">		ret = bootm_start();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!ret &amp;&amp; (states &amp; BOOTM_STATE_PRE_LOAD))</span><br><span class="line">		ret = bootm_pre_load(bmi-&gt;addr_img);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!ret &amp;&amp; (states &amp; BOOTM_STATE_FINDOS))</span><br><span class="line">		ret = bootm_find_os(bmi-&gt;cmd_name, bmi-&gt;addr_img);		<span class="comment">//Find the OS to boot，返回0表示正确</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!ret &amp;&amp; (states &amp; BOOTM_STATE_FINDOTHER)) &#123;</span><br><span class="line">		ulong img_addr;</span><br><span class="line"></span><br><span class="line">		img_addr = bmi-&gt;addr_img ? hextoul(bmi-&gt;addr_img, <span class="literal">NULL</span>)</span><br><span class="line">			: image_load_addr;</span><br><span class="line">		ret = bootm_find_other(img_addr, bmi-&gt;conf_ramdisk,</span><br><span class="line">				       bmi-&gt;conf_fdt);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (IS_ENABLED(CONFIG_MEASURED_BOOT) &amp;&amp; !ret &amp;&amp;</span><br><span class="line">	    (states &amp; BOOTM_STATE_MEASURE))</span><br><span class="line">		bootm_measure(images);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Load the OS */</span></span><br><span class="line">	<span class="keyword">if</span> (!ret &amp;&amp; (states &amp; BOOTM_STATE_LOADOS)) &#123;</span><br><span class="line">		iflag = bootm_disable_interrupts();</span><br><span class="line">        <span class="comment">//加载image镜像，由于之前已经加载过了，因此没有设置BOOTM_STATE_LOADOS，不会执行到这一步</span></span><br><span class="line">		ret = bootm_load_os(images, <span class="number">0</span>);	</span><br><span class="line">		<span class="keyword">if</span> (ret &amp;&amp; ret != BOOTM_ERR_OVERLAP)</span><br><span class="line">			<span class="keyword">goto</span> err;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (ret == BOOTM_ERR_OVERLAP)</span><br><span class="line">			ret = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Relocate the ramdisk */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SYS_BOOT_RAMDISK_HIGH</span></span><br><span class="line">	<span class="keyword">if</span> (!ret &amp;&amp; (states &amp; BOOTM_STATE_RAMDISK)) &#123;</span><br><span class="line">		ulong rd_len = images-&gt;rd_end - images-&gt;rd_start;</span><br><span class="line">		<span class="comment">//加载ramdisk，由于之前已经加载过了，因此没有设置BOOTM_STATE_RAMDISK，不会执行到这一步</span></span><br><span class="line">		ret = boot_ramdisk_high(&amp;images-&gt;lmb, images-&gt;rd_start,</span><br><span class="line">			rd_len, &amp;images-&gt;initrd_start, &amp;images-&gt;initrd_end);	</span><br><span class="line">		<span class="keyword">if</span> (!ret) &#123;</span><br><span class="line">			env_set_hex(<span class="string">&quot;initrd_start&quot;</span>, images-&gt;initrd_start);</span><br><span class="line">			env_set_hex(<span class="string">&quot;initrd_end&quot;</span>, images-&gt;initrd_end);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> CONFIG_IS_ENABLED(OF_LIBFDT) &amp;&amp; defined(CONFIG_LMB)</span></span><br><span class="line">	<span class="keyword">if</span> (!ret &amp;&amp; (states &amp; BOOTM_STATE_FDT)) &#123;</span><br><span class="line">		<span class="comment">//加载设备树，由于之前已经加载过了，因此没有设置BOOTM_STATE_FDT，不会执行到这一步</span></span><br><span class="line">        boot_fdt_add_mem_rsv_regions(&amp;images-&gt;lmb, images-&gt;ft_addr);</span><br><span class="line">		ret = boot_relocate_fdt(&amp;images-&gt;lmb, &amp;images-&gt;ft_addr,</span><br><span class="line">					&amp;images-&gt;ft_len);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* From now on, we need the OS boot function */</span></span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	boot_fn = bootm_os_get_boot_func(images-&gt;os.os);</span><br><span class="line">	need_boot_fn = states &amp; (BOOTM_STATE_OS_CMDLINE |</span><br><span class="line">			BOOTM_STATE_OS_BD_T | BOOTM_STATE_OS_PREP |</span><br><span class="line">			BOOTM_STATE_OS_FAKE_GO | BOOTM_STATE_OS_GO);</span><br><span class="line">	<span class="keyword">if</span> (boot_fn == <span class="literal">NULL</span> &amp;&amp; need_boot_fn) &#123;</span><br><span class="line">		<span class="keyword">if</span> (iflag)</span><br><span class="line">			enable_interrupts();</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;ERROR: booting os &#x27;%s&#x27; (%d) is not supported\n&quot;</span>,</span><br><span class="line">		       genimg_get_os_name(images-&gt;os.os), images-&gt;os.os);</span><br><span class="line">		bootstage_error(BOOTSTAGE_ID_CHECK_BOOT_OS);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Call various other states that are not generally used */</span></span><br><span class="line">	<span class="keyword">if</span> (!ret &amp;&amp; (states &amp; BOOTM_STATE_OS_CMDLINE))</span><br><span class="line">		ret = boot_fn(BOOTM_STATE_OS_CMDLINE, bmi);</span><br><span class="line">	<span class="keyword">if</span> (!ret &amp;&amp; (states &amp; BOOTM_STATE_OS_BD_T))</span><br><span class="line">		ret = boot_fn(BOOTM_STATE_OS_BD_T, bmi);</span><br><span class="line">	<span class="keyword">if</span> (!ret &amp;&amp; (states &amp; BOOTM_STATE_OS_PREP)) &#123;</span><br><span class="line">		<span class="type">int</span> flags = <span class="number">0</span>;</span><br><span class="line">		<span class="comment">/* For Linux OS do all substitutions at console processing */</span></span><br><span class="line">		<span class="keyword">if</span> (images-&gt;os.os == IH_OS_LINUX)</span><br><span class="line">			flags = BOOTM_CL_ALL;</span><br><span class="line">		ret = bootm_process_cmdline_env(flags);</span><br><span class="line">		<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;Cmdline setup failed (err=%d)\n&quot;</span>, ret);</span><br><span class="line">			ret = CMD_RET_FAILURE;</span><br><span class="line">			<span class="keyword">goto</span> err;</span><br><span class="line">		&#125;</span><br><span class="line">		ret = boot_fn(BOOTM_STATE_OS_PREP, bmi);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_TRACE</span></span><br><span class="line">	<span class="comment">/* Pretend to run the OS, then run a user command */</span></span><br><span class="line">	<span class="keyword">if</span> (!ret &amp;&amp; (states &amp; BOOTM_STATE_OS_FAKE_GO)) &#123;</span><br><span class="line">		<span class="type">char</span> *cmd_list = env_get(<span class="string">&quot;fakegocmd&quot;</span>);</span><br><span class="line"></span><br><span class="line">		ret = boot_selected_os(BOOTM_STATE_OS_FAKE_GO, bmi, boot_fn);</span><br><span class="line">		<span class="keyword">if</span> (!ret &amp;&amp; cmd_list)</span><br><span class="line">			ret = run_command_list(cmd_list, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Check for unsupported subcommand. */</span></span><br><span class="line">	<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;subcommand failed (err=%d)\n&quot;</span>, ret);</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Now run the OS! We hope this doesn&#x27;t return */</span></span><br><span class="line">	<span class="keyword">if</span> (!ret &amp;&amp; (states &amp; BOOTM_STATE_OS_GO))	<span class="comment">//启动系统</span></span><br><span class="line">		ret = boot_selected_os(BOOTM_STATE_OS_GO, bmi, boot_fn);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Deal with any fallout */</span></span><br><span class="line">err:</span><br><span class="line">	<span class="keyword">if</span> (iflag)</span><br><span class="line">		enable_interrupts();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ret == BOOTM_ERR_UNIMPLEMENTED) &#123;</span><br><span class="line">		bootstage_error(BOOTSTAGE_ID_DECOMP_UNIMPL);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret == BOOTM_ERR_RESET) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Resetting the board...\n&quot;</span>);</span><br><span class="line">		reset_cpu();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>do_bootm_linux即boot_fn。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">do_bootm_linux</span><span class="params">(<span class="type">int</span> flag, <span class="keyword">struct</span> bootm_info *bmi)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">bootm_headers</span> *<span class="title">images</span> =</span> bmi-&gt;images;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* No need for those on ARM */</span></span><br><span class="line">	<span class="keyword">if</span> (flag &amp; BOOTM_STATE_OS_BD_T || flag &amp; BOOTM_STATE_OS_CMDLINE)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (flag &amp; BOOTM_STATE_OS_PREP) &#123;</span><br><span class="line">		boot_prep_linux(images);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (flag &amp; (BOOTM_STATE_OS_GO | BOOTM_STATE_OS_FAKE_GO)) &#123;</span><br><span class="line">		boot_jump_linux(images, flag);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	boot_prep_linux(images);</span><br><span class="line">	boot_jump_linux(images, flag);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>boot_selected_os是对boot_fn的封装。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">boot_selected_os</span><span class="params">(<span class="type">int</span> state, <span class="keyword">struct</span> bootm_info *bmi, boot_os_fn *boot_fn)</span></span><br><span class="line">&#123;</span><br><span class="line">	arch_preboot_os();</span><br><span class="line">	board_preboot_os();</span><br><span class="line"></span><br><span class="line">	boot_fn(state, bmi);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Stand-alone may return when &#x27;autostart&#x27; is &#x27;no&#x27; */</span></span><br><span class="line">	<span class="keyword">if</span> (bmi-&gt;images-&gt;os.type == IH_TYPE_STANDALONE ||</span><br><span class="line">	    IS_ENABLED(CONFIG_SANDBOX) ||</span><br><span class="line">	    state == BOOTM_STATE_OS_FAKE_GO) <span class="comment">/* We expect to return */</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	bootstage_error(BOOTSTAGE_ID_BOOT_OS_RETURNED);</span><br><span class="line">	debug(<span class="string">&quot;\n## Control returned to monitor - resetting...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> BOOTM_ERR_RESET;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>boot_jump_linux</code>是启动Linux系统的函数, boot_jump_linux根据不同的芯片架构有不同的实现, 下面所展示的代码为ARM架构的<code>boot_jump_linux</code>函数, 位于arch&#x2F;arm&#x2F;lib&#x2F;bootm.c文件中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">boot_jump_linux</span><span class="params">(<span class="keyword">struct</span> bootm_headers *images, <span class="type">int</span> flag)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_ARM64</span></span><br><span class="line">	<span class="type">void</span> (*kernel_entry)(<span class="type">void</span> *fdt_addr, <span class="type">void</span> *res0, <span class="type">void</span> *res1,</span><br><span class="line">			<span class="type">void</span> *res2);</span><br><span class="line">	<span class="type">int</span> fake = (flag &amp; BOOTM_STATE_OS_FAKE_GO);</span><br><span class="line"></span><br><span class="line">	kernel_entry = (<span class="type">void</span> (*)(<span class="type">void</span> *fdt_addr, <span class="type">void</span> *res0, <span class="type">void</span> *res1,</span><br><span class="line">				<span class="type">void</span> *res2))images-&gt;ep;</span><br><span class="line"></span><br><span class="line">	debug(<span class="string">&quot;## Transferring control to Linux (at address %lx)...\n&quot;</span>,</span><br><span class="line">		(ulong) kernel_entry);</span><br><span class="line">	bootstage_mark(BOOTSTAGE_ID_RUN_OS);</span><br><span class="line"></span><br><span class="line">	announce_and_cleanup(fake);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!fake) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_ARMV8_PSCI</span></span><br><span class="line">		armv8_setup_psci();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">		do_nonsec_virt_switch();</span><br><span class="line"></span><br><span class="line">		update_os_arch_secondary_cores(images-&gt;os.arch);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_ARMV8_SWITCH_TO_EL1</span></span><br><span class="line">		armv8_switch_to_el2((u64)images-&gt;ft_addr, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">				    (u64)switch_to_el1, ES_TO_AARCH64);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">		<span class="keyword">if</span> ((IH_ARCH_DEFAULT == IH_ARCH_ARM64) &amp;&amp;</span><br><span class="line">		    (images-&gt;os.arch == IH_ARCH_ARM))</span><br><span class="line">			armv8_switch_to_el2(<span class="number">0</span>, (u64)gd-&gt;bd-&gt;bi_arch_number,</span><br><span class="line">					    (u64)images-&gt;ft_addr, <span class="number">0</span>,</span><br><span class="line">					    (u64)images-&gt;ep,</span><br><span class="line">					    ES_TO_AARCH32);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			armv8_switch_to_el2((u64)images-&gt;ft_addr, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">					    images-&gt;ep,</span><br><span class="line">					    ES_TO_AARCH64);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ARM64架构的内核的入口是标号head,直接跳转到stext。在stext中会读取引导程序传递的四个参数，并且保存在boot_args中。并且设置处理器一场级别，创建页表映射，并调用函数cpu_setup ，为开启处理器的内存管理单元做准备，初始化处理器。调用函数primary_switch为主处理器开启内存管理单元，搭建c语言执行环境，进入c语言部分的入口函数start_kernel。</p>
<p>下图为bootz命令的调用流程图，bootz命令与booti类似，可以进行参考。</p>
<img src="\img\uboot-boot.png" alt="uboot-boot" style="zoom:67%;" />



<h3 id="uboot与Linux内核"><a href="#uboot与Linux内核" class="headerlink" title="uboot与Linux内核"></a>uboot与Linux内核</h3><h3 id="设备树"><a href="#设备树" class="headerlink" title="设备树"></a>设备树</h3><p>设备树的作用就是描述一个硬件平台的硬件资源。这个“设备树”可以被 bootloader(uboot) 传递到内核，内核可以从设备树中获取硬件信息。以下为和设备树有关的文件：</p>
<ul>
<li><p>dts是一种 ASII 文本格式的设备树描述，一般一个.dts 文件对应一个硬件平台。</p>
</li>
<li><p>dtsi内容和dts相似，是指由芯片厂商提供，是同一芯片平台“共用”的设备树文件。</p>
</li>
<li><p>dtb是设备树源码编译生成的文件，类似于uboot源码编译后的bin文件。</p>
</li>
</ul>
<p>芯片厂商提供的dtsi几乎包含了芯片中所有设备及外设接口，在使用时，我们只需要在我们板卡的dts设备树源文件中 <code>#include</code>dtsi就可以导入指定芯片所有的设备，然后我们再根据板卡上的外设来修改dts文件即可。</p>
<h3 id="Bootargs是如何传递给内核的？"><a href="#Bootargs是如何传递给内核的？" class="headerlink" title="Bootargs是如何传递给内核的？"></a>Bootargs是如何传递给内核的？</h3><p>uboot与内核的数据交换由<code>boot_prep_linux</code>进行, <code>boot_prep_linux</code>函数实现了启动image前的一些初始化工作，boot_prep_linux 主要用于处理环境变量 bootargs，bootargs 保存着传递给 Linux kernel 的参数；</p>
<p>uboot与内核之间传递数据的方式有两种: FDT与TAGS. </p>
<p>TAGS传参方式类似于在uboot与Linux中定义一个相同的结构体, uboot先对结构体赋值, 在uboot启动Linux内核时将该结构体的内存地址传递给Linux内核; 而FDT方式是将参数信息加入设备树中, 随设备树一同传递给Linux内核.</p>
<p><code>boot_prep_linux</code>函数首先判断uboot与内核的传递方式, 若开启了FDT方式, 则跳转至FDT相关函数; 若未开启FDT而开启了TAGS方式, 则跳转至TAGS相关函数; 若两者均为开启, 则报错.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">boot_prep_linux</span><span class="params">(<span class="keyword">struct</span> bootm_headers *images)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> *commandline = env_get(<span class="string">&quot;bootargs&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (CONFIG_IS_ENABLED(OF_LIBFDT) &amp;&amp; IS_ENABLED(CONFIG_LMB) &amp;&amp; images-&gt;ft_len) &#123;</span><br><span class="line">		debug(<span class="string">&quot;using: FDT\n&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span> (image_setup_linux(images)) &#123;</span><br><span class="line">			panic(<span class="string">&quot;FDT creation failed!&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (BOOTM_ENABLE_TAGS) &#123;</span><br><span class="line">		debug(<span class="string">&quot;using: ATAGS\n&quot;</span>);</span><br><span class="line">		setup_start_tag(gd-&gt;bd);</span><br><span class="line">		<span class="keyword">if</span> (BOOTM_ENABLE_SERIAL_TAG)</span><br><span class="line">			setup_serial_tag(&amp;params);</span><br><span class="line">		<span class="keyword">if</span> (BOOTM_ENABLE_CMDLINE_TAG)</span><br><span class="line">			setup_commandline_tag(gd-&gt;bd, commandline);</span><br><span class="line">		<span class="keyword">if</span> (BOOTM_ENABLE_REVISION_TAG)</span><br><span class="line">			setup_revision_tag(&amp;params);</span><br><span class="line">		<span class="keyword">if</span> (BOOTM_ENABLE_MEMORY_TAGS)</span><br><span class="line">			setup_memory_tags(gd-&gt;bd);</span><br><span class="line">		<span class="keyword">if</span> (BOOTM_ENABLE_INITRD_TAG) &#123;</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * In boot_ramdisk_high(), it may relocate ramdisk to</span></span><br><span class="line"><span class="comment">			 * a specified location. And set images-&gt;initrd_start &amp;</span></span><br><span class="line"><span class="comment">			 * images-&gt;initrd_end to relocated ramdisk&#x27;s start/end</span></span><br><span class="line"><span class="comment">			 * addresses. So use them instead of images-&gt;rd_start &amp;</span></span><br><span class="line"><span class="comment">			 * images-&gt;rd_end when possible.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">if</span> (images-&gt;initrd_start &amp;&amp; images-&gt;initrd_end) &#123;</span><br><span class="line">				setup_initrd_tag(gd-&gt;bd, images-&gt;initrd_start,</span><br><span class="line">						 images-&gt;initrd_end);</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (images-&gt;rd_start &amp;&amp; images-&gt;rd_end) &#123;</span><br><span class="line">				setup_initrd_tag(gd-&gt;bd, images-&gt;rd_start,</span><br><span class="line">						 images-&gt;rd_end);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		setup_board_tags(&amp;params);</span><br><span class="line">		setup_end_tag(gd-&gt;bd);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		panic(<span class="string">&quot;FDT and ATAGS support not compiled in\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	board_prep_linux(images);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>若使用FDT方式进行传参, 则会进入<code>image_setup_linux</code>函数, 该函数用于配置ramdisk, fdt. <code>image_setup_linux</code>的步骤如下:</p>
<ul>
<li><p>获取image镜像的LMB (logical memory blocks). lmb为uboot下的一种内存管理机制，用于管理镜像的内存。lmb所记录的内存信息最终会传递给kernel。在&#x2F;include&#x2F;lmb.h和&#x2F;lib&#x2F;lmb.c中有对lmb的接口和定义的具体描述。</p>
</li>
<li><p>调用<code>boot_fdt_add_mem_rsv_regions</code>为设备树预留内存地址空间, 这里的地址为<code>do_booti</code>函数中从命令参数中获取的fdt地址;</p>
</li>
<li><p>调用<code>boot_get_cmdline</code>初始化内核命令行;</p>
</li>
<li><p>调用<code>boot_relocate_fdt</code>将fdt搬移至指定内存地址;</p>
</li>
<li><p>调用<code>image_setup_libfdt</code>函数, 为设备树增加参数;</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Set up the FDT to use for booting a kernel</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This performs ramdisk setup, sets up the FDT if required, and adds</span></span><br><span class="line"><span class="comment"> * paramters to the FDT if libfdt is available.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param images	Images information</span></span><br><span class="line"><span class="comment"> * Return: 0 if ok, &lt;0 on failure</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">image_setup_linux</span><span class="params">(<span class="keyword">struct</span> bootm_headers *images)</span></span><br><span class="line">&#123;</span><br><span class="line">	ulong of_size = images-&gt;ft_len;</span><br><span class="line">	<span class="type">char</span> **of_flat_tree = &amp;images-&gt;ft_addr;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">lmb</span> *<span class="title">lmb</span> =</span> images_lmb(images);</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* This function cannot be called without lmb support */</span></span><br><span class="line">	<span class="keyword">if</span> (!IS_ENABLED(CONFIG_LMB))</span><br><span class="line">		<span class="keyword">return</span> -EFAULT;</span><br><span class="line">	<span class="keyword">if</span> (CONFIG_IS_ENABLED(OF_LIBFDT))</span><br><span class="line">		boot_fdt_add_mem_rsv_regions(lmb, *of_flat_tree);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (IS_ENABLED(CONFIG_SYS_BOOT_GET_CMDLINE)) &#123;</span><br><span class="line">		ret = boot_get_cmdline(lmb, &amp;images-&gt;cmdline_start,</span><br><span class="line">				       &amp;images-&gt;cmdline_end);</span><br><span class="line">		<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">			<span class="built_in">puts</span>(<span class="string">&quot;ERROR with allocation of cmdline\n&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> ret;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (CONFIG_IS_ENABLED(OF_LIBFDT)) &#123;</span><br><span class="line">		ret = boot_relocate_fdt(lmb, of_flat_tree, &amp;of_size);</span><br><span class="line">		<span class="keyword">if</span> (ret)</span><br><span class="line">			<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (CONFIG_IS_ENABLED(OF_LIBFDT) &amp;&amp; of_size) &#123;</span><br><span class="line">		ret = image_setup_libfdt(images, *of_flat_tree, lmb);</span><br><span class="line">		<span class="keyword">if</span> (ret)</span><br><span class="line">			<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>image_setup_libfdt</code>用于在FDT中增加要传给linux内核的参数.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">image_setup_libfdt</span><span class="params">(<span class="keyword">struct</span> bootm_headers *images, <span class="type">void</span> *blob,</span></span><br><span class="line"><span class="params">		       <span class="keyword">struct</span> lmb *lmb)</span></span><br><span class="line">&#123;</span><br><span class="line">	ulong *initrd_start = &amp;images-&gt;initrd_start;</span><br><span class="line">	ulong *initrd_end = &amp;images-&gt;initrd_end;</span><br><span class="line">	<span class="type">int</span> ret, fdt_ret, of_size;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (IS_ENABLED(CONFIG_OF_ENV_SETUP)) &#123;</span><br><span class="line">		<span class="type">const</span> <span class="type">char</span> *fdt_fixup;</span><br><span class="line"></span><br><span class="line">		fdt_fixup = env_get(<span class="string">&quot;fdt_fixup&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span> (fdt_fixup) &#123;</span><br><span class="line">			set_working_fdt_addr(map_to_sysmem(blob));</span><br><span class="line">			ret = run_command_list(fdt_fixup, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">			<span class="keyword">if</span> (ret)</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;WARNING: fdt_fixup command returned %d\n&quot;</span>,</span><br><span class="line">				       ret);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ret = -EPERM;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (fdt_root(blob) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;ERROR: root node setup failed\n&quot;</span>);</span><br><span class="line">		<span class="keyword">goto</span> err;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//传递bootargs参数</span></span><br><span class="line">	<span class="keyword">if</span> (fdt_chosen(blob) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;ERROR: /chosen node create failed\n&quot;</span>);</span><br><span class="line">		<span class="keyword">goto</span> err;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (arch_fixup_fdt(blob) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;ERROR: arch-specific fdt fixup failed\n&quot;</span>);</span><br><span class="line">		<span class="keyword">goto</span> err;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fdt_ret = optee_copy_fdt_nodes(blob);</span><br><span class="line">	<span class="keyword">if</span> (fdt_ret) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;ERROR: transfer of optee nodes to new fdt failed: %s\n&quot;</span>,</span><br><span class="line">		       fdt_strerror(fdt_ret));</span><br><span class="line">		<span class="keyword">goto</span> err;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Store name of configuration node as u-boot,bootconf in /chosen node */</span></span><br><span class="line">	<span class="keyword">if</span> (images-&gt;fit_uname_cfg)</span><br><span class="line">		fdt_find_and_setprop(blob, <span class="string">&quot;/chosen&quot;</span>, <span class="string">&quot;u-boot,bootconf&quot;</span>,</span><br><span class="line">					images-&gt;fit_uname_cfg,</span><br><span class="line">					<span class="built_in">strlen</span>(images-&gt;fit_uname_cfg) + <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Update ethernet nodes */</span></span><br><span class="line">	fdt_fixup_ethernet(blob);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> IS_ENABLED(CONFIG_CMD_PSTORE)</span></span><br><span class="line">	<span class="comment">/* Append PStore configuration */</span></span><br><span class="line">	fdt_fixup_pstore(blob);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">if</span> (IS_ENABLED(CONFIG_OF_BOARD_SETUP)) &#123;</span><br><span class="line">		<span class="type">const</span> <span class="type">char</span> *skip_board_fixup;</span><br><span class="line"></span><br><span class="line">		skip_board_fixup = env_get(<span class="string">&quot;skip_board_fixup&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span> (skip_board_fixup &amp;&amp; ((<span class="type">int</span>)simple_strtol(skip_board_fixup, <span class="literal">NULL</span>, <span class="number">10</span>) == <span class="number">1</span>)) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;skip board fdt fixup\n&quot;</span>);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			fdt_ret = ft_board_setup(blob, gd-&gt;bd);</span><br><span class="line">			<span class="keyword">if</span> (fdt_ret) &#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;ERROR: board-specific fdt fixup failed: %s\n&quot;</span>,</span><br><span class="line">				       fdt_strerror(fdt_ret));</span><br><span class="line">				<span class="keyword">goto</span> err;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (IS_ENABLED(CONFIG_OF_SYSTEM_SETUP)) &#123;</span><br><span class="line">		fdt_ret = ft_system_setup(blob, gd-&gt;bd);</span><br><span class="line">		<span class="keyword">if</span> (fdt_ret) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;ERROR: system-specific fdt fixup failed: %s\n&quot;</span>,</span><br><span class="line">			       fdt_strerror(fdt_ret));</span><br><span class="line">			<span class="keyword">goto</span> err;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (fdt_initrd(blob, *initrd_start, *initrd_end))</span><br><span class="line">		<span class="keyword">goto</span> err;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!ft_verify_fdt(blob))</span><br><span class="line">		<span class="keyword">goto</span> err;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* after here we are using a livetree */</span></span><br><span class="line">	<span class="keyword">if</span> (!of_live_active() &amp;&amp; CONFIG_IS_ENABLED(EVENT)) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">event_ft_fixup</span> <span class="title">fixup</span>;</span></span><br><span class="line"></span><br><span class="line">		fixup.tree = oftree_from_fdt(blob);</span><br><span class="line">		fixup.images = images;</span><br><span class="line">		<span class="keyword">if</span> (oftree_valid(fixup.tree)) &#123;</span><br><span class="line">			ret = event_notify(EVT_FT_FIXUP, &amp;fixup, <span class="keyword">sizeof</span>(fixup));</span><br><span class="line">			<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;ERROR: fdt fixup event failed: %d\n&quot;</span>,</span><br><span class="line">				       ret);</span><br><span class="line">				<span class="keyword">goto</span> err;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Delete the old LMB reservation */</span></span><br><span class="line">	<span class="keyword">if</span> (lmb)</span><br><span class="line">		lmb_free(lmb, map_to_sysmem(blob), fdt_totalsize(blob));</span><br><span class="line"></span><br><span class="line">	ret = fdt_shrink_to_minimum(blob, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> err;</span><br><span class="line">	of_size = ret;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Create a new LMB reservation */</span></span><br><span class="line">	<span class="keyword">if</span> (lmb)</span><br><span class="line">		lmb_reserve(lmb, map_to_sysmem(blob), of_size);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_ARCH_KEYSTONE)</span></span><br><span class="line">	<span class="keyword">if</span> (IS_ENABLED(CONFIG_OF_BOARD_SETUP))</span><br><span class="line">		ft_board_setup_ex(blob, gd-&gt;bd);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">err:</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot; - must RESET the board to recover.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从uboot环境变量bootargs获取需要传递的参数，uboot引导内核时会根据bootargs环境变量值，修改内存设备树里面的bootargs参数。通过&#x2F;boot&#x2F;fdt_support.c中的fdt_chosen函数实现:</p>
<ul>
<li><code>str = board_fdt_chosen_bootargs();</code>获取bootargs参数;</li>
<li>调用<code>fdt_setprop(fdt, nodeoffset, &quot;bootargs&quot;, str,strlen(str) + 1);</code>将bootargs参数插入设备树中.</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * board_fdt_chosen_bootargs - boards may override this function to use</span></span><br><span class="line"><span class="comment"> *                             alternative kernel command line arguments</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">__weak <span class="type">char</span> *<span class="title function_">board_fdt_chosen_bootargs</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> env_get(<span class="string">&quot;bootargs&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fdt_chosen</span><span class="params">(<span class="type">void</span> *fdt)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">abuf</span> <span class="title">buf</span> =</span> &#123;&#125;;</span><br><span class="line">	<span class="type">int</span>   nodeoffset;</span><br><span class="line">	<span class="type">int</span>   err;</span><br><span class="line">	<span class="type">char</span>  *str;		<span class="comment">/* used to set string properties */</span></span><br><span class="line"></span><br><span class="line">	err = fdt_check_header(fdt);</span><br><span class="line">	<span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;fdt_chosen: %s\n&quot;</span>, fdt_strerror(err));</span><br><span class="line">		<span class="keyword">return</span> err;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* find or create &quot;/chosen&quot; node. */</span></span><br><span class="line">	nodeoffset = fdt_find_or_add_subnode(fdt, <span class="number">0</span>, <span class="string">&quot;chosen&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (nodeoffset &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> nodeoffset;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (IS_ENABLED(CONFIG_BOARD_RNG_SEED) &amp;&amp; !board_rng_seed(&amp;buf)) &#123;</span><br><span class="line">		err = fdt_setprop(fdt, nodeoffset, <span class="string">&quot;rng-seed&quot;</span>,</span><br><span class="line">				  abuf_data(&amp;buf), abuf_size(&amp;buf));</span><br><span class="line">		abuf_uninit(&amp;buf);</span><br><span class="line">		<span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;WARNING: could not set rng-seed %s.\n&quot;</span>,</span><br><span class="line">			       fdt_strerror(err));</span><br><span class="line">			<span class="keyword">return</span> err;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	str = board_fdt_chosen_bootargs();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (str) &#123;</span><br><span class="line">		err = fdt_setprop(fdt, nodeoffset, <span class="string">&quot;bootargs&quot;</span>, str,</span><br><span class="line">				  <span class="built_in">strlen</span>(str) + <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;WARNING: could not set bootargs %s.\n&quot;</span>,</span><br><span class="line">			       fdt_strerror(err));</span><br><span class="line">			<span class="keyword">return</span> err;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* add u-boot version */</span></span><br><span class="line">	err = fdt_setprop(fdt, nodeoffset, <span class="string">&quot;u-boot,version&quot;</span>, PLAIN_VERSION,</span><br><span class="line">			  <span class="built_in">strlen</span>(PLAIN_VERSION) + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;WARNING: could not set u-boot,version %s.\n&quot;</span>,</span><br><span class="line">		       fdt_strerror(err));</span><br><span class="line">		<span class="keyword">return</span> err;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> fdt_fixup_stdout(fdt, nodeoffset);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="uboot是如何将设备树文件传递给Linux的？"><a href="#uboot是如何将设备树文件传递给Linux的？" class="headerlink" title="uboot是如何将设备树文件传递给Linux的？"></a>uboot是如何将设备树文件传递给Linux的？</h3><p>在boot_jump_linux函数中, 启动64位linux内核时调用了<code>armv8_switch_to_el2((u64)images-&gt;ft_addr, 0, 0, 0,images-&gt;ep, ES_TO_AARCH64);</code>, 该函数用汇编实现, 用于启动Linux内核并将设备树地址传递给内核, 该函数的声明如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * armv8_switch_to_el2() - switch from EL3 to EL2 for ARMv8</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @args:        For loading 64-bit OS, fdt address.</span></span><br><span class="line"><span class="comment"> *               For loading 32-bit OS, zero.</span></span><br><span class="line"><span class="comment"> * @mach_nr:     For loading 64-bit OS, zero.</span></span><br><span class="line"><span class="comment"> *               For loading 32-bit OS, machine nr</span></span><br><span class="line"><span class="comment"> * @fdt_addr:    For loading 64-bit OS, zero.</span></span><br><span class="line"><span class="comment"> *               For loading 32-bit OS, fdt address.</span></span><br><span class="line"><span class="comment"> * @arg4:	 Input argument.</span></span><br><span class="line"><span class="comment"> * @entry_point: kernel entry point</span></span><br><span class="line"><span class="comment"> * @es_flag:     execution state flag, ES_TO_AARCH64 or ES_TO_AARCH32</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> __noreturn <span class="title function_">armv8_switch_to_el2</span><span class="params">(u64 args, u64 mach_nr, u64 fdt_addr,</span></span><br><span class="line"><span class="params">				    u64 arg4, u64 entry_point, u64 es_flag)</span>;</span><br></pre></td></tr></table></figure>

<p>参考资料</p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzAxODI5ODMwOA==&mid=2666570161&idx=1&sn=251126f93335302a65ab66d88cf87708&chksm=81152ef30b028a6e8527dc93b16e73ca9a97f59fc198a82e689d1d4fa474612c23eca8f843ef&xtrack=1&scene=90&subscene=93&sessionid=1714135101&flutter_pos=27&clicktime=1714135116&enterid=1714135116&finder_biz_enter_id=4&ranksessionid=1714135101&ascene=56&fasttmpl_type=0&fasttmpl_fullversion=7177687-zh_CN-zip&fasttmpl_flag=0&realreporttime=1714135116334&devicetype=android-34&version=28002f51&nettype=cmnet&abtest_cookie=AAACAA==&lang=zh_CN&session_us=gh_9f1efcd6f4ab&countrycode=CN&exportkey=n_ChQIAhIQdeO1u/PmkezQCnG1xsTSRRLrAQIE97dBBAEAAAAAAINnE0bBh9wAAAAOpnltbLcz9gKNyK89dVj0LhawdNnVxRK1O3+ANpSGNzdnRMf4hjlq1rLPcT/egIzj6R4U39Ra7p4XnmmHCDD5f4qX7Vw05ITphh9FUXRkncSb6AiqT4fG9Rv6L35SCSZv0pWV0MP7yrv0iPLQtf22Su2URsYhT7Dr4rTcFjYrHFKeY32J7m9y/U8kUUnkgvffv4FJNU4dTFek1yIOVvks9wDrTFlE1qvt4ithYTI2uPIjZy1yezKqFvNhYx2/GQakoTkKYCG6vHkAYA6ubAPiHuBvn68=&pass_ticket=qpRLHEhkIYqSEKBo2Fr+QEQUC8kATZLFiO/pop0tPtqhUfNsTFQ/Rc6TluWrmRlYhS+rt1phI/1Tu2rmaZZueg==&wx_header=3">完全理解ARM启动流程：Uboot-Kernel</a></p>
<p><a target="_blank" rel="noopener" href="https://krinkinmu.github.io/2020/11/29/PL011.html">ARMs PL011 UART</a></p>
<p><a target="_blank" rel="noopener" href="https://krinkinmu.github.io/2023/08/21/how-u-boot-loads-linux-kernel.html">How U-boot loads Linux kernel</a></p>
<p><a target="_blank" rel="noopener" href="http://www.wowotech.net/device_model/why-dt.html">Device Tree</a></p>
<p><a target="_blank" rel="noopener" href="http://www.wowotech.net/u-boot/fit_image_overview.html">FIT IMAGE</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/dongxb/p/16717565.html">Secure Boot</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/jzcn/p/16966628.html">Uboot启动流程</a></p>
</div></article></div></main><footer><div class="paginator"><a href="/2024/06/09/rbtree_linux/" class="prev">PREV</a><a href="/2024/05/02/Linux_boot/" class="next">NEXT</a></div><div class="copyright"><p>© 2022 - 2024 <a href="https://big7ng.github.io">Big7ng</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>