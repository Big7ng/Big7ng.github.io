<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Linux内核中红黑树实现机制的探索 · Big7ng's Blog</title><meta name="description" content="Linux内核中红黑树实现机制的探索 - Big7ng"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://big7ng.github.io/atom.xml" title="Big7ng's Blog"><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="Big7ng's Blog" type="application/atom+xml">
</head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/Big7ng" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Linux内核中红黑树实现机制的探索</h1><div class="post-info">Jun 9, 2024</div><div class="post-content"><p>Linux中有着大量的红黑树的应用：</p>
<ul>
<li><p>进程调度—<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.15.155/source/include/linux/sched.h#L527">CFS完全公平调度</a></p>
</li>
<li><p>虚拟内存管理<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.15.155/source/include/linux/mm_types.h#L402">mm_struct</a>, <a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.15.155/source/include/linux/vmalloc.h#L77">vmap_area</a></p>
</li>
<li><p>文件系统</p>
<ul>
<li>ext4文件系统中，红黑树被用来管理文件的逻辑块到物理块的映射（<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.15.155/source/fs/ext4/extents_status.h#L60">extend</a>）、<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.15.155/source/fs/ext4/dir.c#L407">目录的索引</a>、管理空闲块的分配（<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.15.155/source/fs/ext4/mballoc.c#L811">mballoc</a>）</li>
<li>Btrfs 文件系统</li>
</ul>
</li>
<li><p>TCP网络堆栈<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.15.155/source/include/linux/skbuff.h#L761">sk_buff</a></p>
</li>
<li><p>高精度定时器<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.15.155/source/include/linux/hrtimer.h#L118">HR-Timer</a></p>
</li>
<li><p>多路复用<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.15.155/source/fs/eventpoll.c#L177">epoll</a></p>
</li>
</ul>
<p>因此为了更好地了解内核，有必要对Linux内核中红黑树的实现进行分析，本次分析的内核源码版本为5.15.155。</p>
<p>内核源码中与红黑树定义有关的文件包括：<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.15.155/source/include/linux/rbtree.h">&#x2F;include&#x2F;linux&#x2F;rbtree.h</a>、<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.15.155/source/include/linux/rbtree_augmented.h">&#x2F;include&#x2F;linux&#x2F;rbtree_augmented.h</a>、<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.15.155/source/include/linux/rbtree_types.h">&#x2F;inclue&#x2F;linux&#x2F;rbtree_types.h</a>、<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.15.155/source/lib/rbtree.c">&#x2F;lib&#x2F;rbtree.c</a>。本文将对这四个文件中的关键代码进行探索。</p>
<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><ul>
<li><p><code>rb_node</code>是内核红黑树中最基础的数据结构, 用于表示红黑树节点。</p>
<p>  该结构包含四个信息：父节点指针、颜色、左子节点指针、右子节点指针，但是结构体中只有三个变量。由于指针通常是对齐的（例如，4字节或8字节对齐），最低有效位可以安全地用作存储其他信息而不影响指针的正确性，因此<code>rbtree</code>结构体将颜色信息嵌入到<code>__rb_parent_color</code>成员变量的最低有效位中，因此该变量中包含了父节点指针和颜色信息。</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>  __rb_parent_color;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">rb_right</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">rb_left</span>;</span></span><br><span class="line">&#125; __attribute__((aligned(<span class="keyword">sizeof</span>(<span class="type">long</span>))));	<span class="comment">//指定 rb_node 结构体的起始地址将按 `long` 类型的大小对齐。</span></span><br><span class="line"><span class="comment">/* The alignment might seem pointless, but allegedly CRIS needs it */</span></span><br></pre></td></tr></table></figure>
<p>  该结构体中没有<code>key</code>域，这是<code>linux</code>数据结构的一大特色，就是结构不包括数据，而是由数据和基本结构被包括在同一个<code>struct</code>中。如果我们需要创建一个结构体，并用红黑树进行组织，可以向如下代码这样组织：</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mytype</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> <span class="title">node</span>;</span></span><br><span class="line">  <span class="type">char</span> *keystring;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//linux的rbtree的功能是由多种接口组成,相比于我们c++的面向对象实现的红黑树或者其他数据结构，我们实现一个链表类都是将所有的功能完全的在一个类中实现，而对于linux(不过linux大部分源码都是c实现的，所以没有面向对象的思想)，则是写成很多的接口。至于写成接口的好处就是：当linux实现完链表的结构后，后面实现栈和队列的时候，可以不用赋值链表的源码或者在实现栈和队列时引用链表类，这里可以直接使用链表的接口。就可以大大缩减代码量和内存空间。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>rb_root</code>变量存储了根节点指针，用于表示一颗红黑树。</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">rb_node</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>struct rb_root_cached</code> 是一个用来表示红黑树（Red-Black Tree）的结构体，并且它增加了一个缓存（<code>rb_leftmost</code>）来存储树中最左边的节点。</p>
<p>  通常，找到红黑树中的最小节点需要从根节点开始，调用<code>rb_frist()</code>沿着左子树一路遍历到最左边的叶子节点。而有了 rb_leftmost 指针后，可以直接通过这个指针访问最小节点，避免了每次查找时的遍历操作。</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rb_root_cached</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">rb_root</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">rb_leftmost</span>;</span> <span class="comment">//指向红黑树中最左边（也就是最小）的节点</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>dummy_callbacks</code>是一个包含占位符回调函数的结构体，这些回调函数目前都是空实现（什么都不做）。这些占位符通常在需要红黑树的增强功能（augmented red-black tree）的场景中被实际的逻辑所替换，例如更新某些附加信息。当前的空实现可以视为一个默认的、不需要任何额外操作的基础实现。</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">dummy_propagate</span><span class="params">(<span class="keyword">struct</span> rb_node *node, <span class="keyword">struct</span> rb_node *stop)</span> &#123;&#125;</span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">dummy_copy</span><span class="params">(<span class="keyword">struct</span> rb_node *old, <span class="keyword">struct</span> rb_node *new)</span> &#123;&#125;</span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">dummy_rotate</span><span class="params">(<span class="keyword">struct</span> rb_node *old, <span class="keyword">struct</span> rb_node *new)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">rb_augment_callbacks</span> <span class="title">dummy_callbacks</span> =</span> &#123;</span><br><span class="line">    .propagate = dummy_propagate,</span><br><span class="line">    .copy = dummy_copy,</span><br><span class="line">    .rotate = dummy_rotate</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="辅助函数"><a href="#辅助函数" class="headerlink" title="辅助函数"></a>辅助函数</h1><p>辅助函数一般为宏定义，用于便捷地获取与设置红黑树节点的值。</p>
<ul>
<li><p><code>rb_parent</code>用于获取输入节点的父节点地址。由于父节点指针和颜色信息都存储在同一个字段中,所以需要通过位操作来分离出父节点指针。(r)-&gt;__rb_parent_color &amp; ~3 可以将最后两个位（存储颜色信息）清零,得到的就是父节点指针的值。</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> rb_parent(r)   ((struct rb_node *)((r)-&gt;__rb_parent_color &amp; ~3))</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>rb_color</code>用于获取节点的颜色</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> rb_color(rb)       __rb_color((rb)-&gt;__rb_parent_color)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __rb_color(pc)     ((pc) &amp; 1)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>rb_is_red</code>用于判断节点是否为红色, rb_is_black同理</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#define rb_is_red(rb)      __rb_is_red((rb)-&gt;__rb_parent_color)</span><br><span class="line">#define __rb_is_red(pc)    (!__rb_color(pc))</span><br><span class="line">#define __rb_color(pc)     ((pc) &amp; 1)</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>rb_red_parent</code>从 <code>__rb_parent_color</code> 字段中提取当前节点的父节点指针,并检查父节点是否为红色。</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> rb_node *<span class="title function_">rb_red_parent</span><span class="params">(<span class="keyword">struct</span> rb_node *red)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> (<span class="keyword">struct</span> rb_node *)red-&gt;__rb_parent_color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>RB_EMPTY_ROOT</code>用于判断节点是否为空</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> RB_EMPTY_ROOT(root)  (READ_ONCE((root)-&gt;rb_node) == NULL)</span></span><br></pre></td></tr></table></figure>
<p>  <code>READ_ONCE</code> 是一个内核级别的宏,它主要用于确保在多线程&#x2F;多核环境下安全地读取一个变量的值。<br>  在多线程&#x2F;多核环境下,一个变量可能会被多个线程&#x2F;CPU同时访问和修改。如果不采取特殊措施,编译器可能会对变量的访问进行优化,导致读取到不正确的值。<br>  <code>READ_ONCE</code> 宏能够禁止编译器对变量的访问进行优化,确保每次读取都是从内存中直接获取变量的最新值,而不是使用寄存器中缓存的旧值。</p>
</li>
<li><p><code>rb_set_parent</code>用于设置parent节点, <code>rb_set_parent_color</code>用于设置parent节点与当前节点的颜色.</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">rb_set_parent</span><span class="params">(<span class="keyword">struct</span> rb_node *rb, <span class="keyword">struct</span> rb_node *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    rb-&gt;__rb_parent_color = rb_color(rb) | (<span class="type">unsigned</span> <span class="type">long</span>)p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">rb_set_parent_color</span><span class="params">(<span class="keyword">struct</span> rb_node *rb,</span></span><br><span class="line"><span class="params">                       <span class="keyword">struct</span> rb_node *p, <span class="type">int</span> color)</span></span><br><span class="line">&#123;</span><br><span class="line">    rb-&gt;__rb_parent_color = (<span class="type">unsigned</span> <span class="type">long</span>)p | color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>rb_link_node</code>用于将新节点插入树中，把parent设为node的父结点，并且让rb_link指向node。</p>
</li>
<li><pre><code class="c">static inline void rb_link_node(struct rb_node *node, struct rb_node *parent,
                struct rb_node **rb_link)
&#123;
    node-&gt;__rb_parent_color = (unsigned long)parent;
    node-&gt;rb_left = node-&gt;rb_right = NULL;

    *rb_link = node;
&#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* `rb_entry`用于返回包含红黑树节点的结构体。由于红黑树节点中并不包含key，因此需要`rb_entry`来返回包含key和rb_node的结构体。`container_of` 宏是 Linux 内核中常用的一个宏，用于从结构体中的一个成员指针推导出包含该成员的结构体指针。</span><br><span class="line"></span><br><span class="line">  ```c</span><br><span class="line">  #define	rb_entry(ptr, type, member) container_of(ptr, type, member)</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<h1 id="红黑树操作"><a href="#红黑树操作" class="headerlink" title="红黑树操作"></a>红黑树操作</h1><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><p>红黑树的遍历方式与其他二叉树的遍历方式大致相同。Linux内核中对于红黑树的遍历实现了两种顺序：后序遍历与中序遍历。</p>
<ul>
<li><p>后序遍历</p>
<ul>
<li><p><code>rb_first_postorder</code>返回后序遍历中的第一个节点</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> rb_node *<span class="title function_">rb_first_postorder</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> rb_root *root)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root-&gt;rb_node)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rb_left_deepest_node(root-&gt;rb_node);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(rb_first_postorder);</span><br></pre></td></tr></table></figure>


<ul>
<li><p><code>rb_next_postorder</code>返回后序遍历中输入节点的下一个节点</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> rb_node *<span class="title function_">rb_next_postorder</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> rb_node *node)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">parent</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (!node)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    parent = rb_parent(node);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If we&#x27;re sitting on node, we&#x27;ve already seen our children */</span></span><br><span class="line">    <span class="keyword">if</span> (parent &amp;&amp; node == parent-&gt;rb_left &amp;&amp; parent-&gt;rb_right) &#123;</span><br><span class="line">        <span class="comment">/* If we are the parent&#x27;s left node, go to the parent&#x27;s right</span></span><br><span class="line"><span class="comment">         * node then all the way down to the left */</span></span><br><span class="line">        <span class="keyword">return</span> rb_left_deepest_node(parent-&gt;rb_right);</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        <span class="comment">/* Otherwise we are the parent&#x27;s right node, and the parent</span></span><br><span class="line"><span class="comment">         * should be next */</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">struct</span> rb_node *)parent;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(rb_next_postorder);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</li>
<li><p><code>rb_left_deepest_node</code>返回最深且位于最左端的节点, 即后序遍历中的第一个节点</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> rb_node *<span class="title function_">rb_left_deepest_node</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> rb_node *node)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;rb_left)</span><br><span class="line">            node = node-&gt;rb_left;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (node-&gt;rb_right)</span><br><span class="line">            node = node-&gt;rb_right;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">struct</span> rb_node *)node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>中序遍历</p>
<ul>
<li><p><code>rb_last</code>返回中序遍历中的最后一个节点</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> rb_node *<span class="title function_">rb_last</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> rb_root *root)</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span>	*<span class="title">n</span>;</span></span><br><span class="line"></span><br><span class="line">    n = root-&gt;rb_node;</span><br><span class="line">    <span class="keyword">if</span> (!n)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (n-&gt;rb_right)</span><br><span class="line">        n = n-&gt;rb_right;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(rb_last);</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>rb_first</code>返回中序遍历中的第一个节点</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> rb_node *<span class="title function_">rb_first</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> rb_root *root)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span>	*<span class="title">n</span>;</span></span><br><span class="line"></span><br><span class="line">    n = root-&gt;rb_node;</span><br><span class="line">    <span class="keyword">if</span> (!n)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (n-&gt;rb_left)</span><br><span class="line">        n = n-&gt;rb_left;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(rb_first);</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>rb_next</code>返回指定节点中序遍历中的下一个节点, 即后继节点</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> rb_node *<span class="title function_">rb_next</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> rb_node *node)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">parent</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (RB_EMPTY_NODE(node))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * If we have a right-hand child, go down and then left as far</span></span><br><span class="line"><span class="comment">     * as we can.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (node-&gt;rb_right) &#123;</span><br><span class="line">        node = node-&gt;rb_right;</span><br><span class="line">        <span class="keyword">while</span> (node-&gt;rb_left)</span><br><span class="line">            node = node-&gt;rb_left;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">struct</span> rb_node *)node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * No right-hand children. Everything down and left is smaller than us,</span></span><br><span class="line"><span class="comment">     * so any &#x27;next&#x27; node must be in the general direction of our parent.</span></span><br><span class="line"><span class="comment">     * Go up the tree; any time the ancestor is a right-hand child of its</span></span><br><span class="line"><span class="comment">     * parent, keep going up. First time it&#x27;s a left-hand child of its</span></span><br><span class="line"><span class="comment">     * parent, said parent is our &#x27;next&#x27; node.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">while</span> ((parent = rb_parent(node)) &amp;&amp; node == parent-&gt;rb_right)</span><br><span class="line">        node = parent;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> parent;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(rb_next);</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>rb_prev</code>返回指定节点中序遍历中的上一个节点, 即前驱节点</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> rb_node *<span class="title function_">rb_prev</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> rb_node *node)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">parent</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (RB_EMPTY_NODE(node))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * If we have a left-hand child, go down and then right as far</span></span><br><span class="line"><span class="comment">     * as we can.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (node-&gt;rb_left) &#123;</span><br><span class="line">        node = node-&gt;rb_left;</span><br><span class="line">        <span class="keyword">while</span> (node-&gt;rb_right)</span><br><span class="line">            node = node-&gt;rb_right;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">struct</span> rb_node *)node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * No left-hand children. Go up till we find an ancestor which</span></span><br><span class="line"><span class="comment">     * is a right-hand child of its parent.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">while</span> ((parent = rb_parent(node)) &amp;&amp; node == parent-&gt;rb_left)</span><br><span class="line">        node = parent;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> parent;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(rb_prev);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p>内核中遍历的具体实现方式有两种：</p>
<p>第一种是使用内核内部实现的查找函数, 由于内核红黑树的节点结构体中并不包含key，因此在实现查找操作时需要自定义<code>cmp</code>函数。内核中的查找函数如下：</p>
<ul>
<li><p><code>rb_next_match</code>用于判断下一个节点是否包含指定key, 若包含key则返回该节点指针, 否则返回空NULL</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __always_inline <span class="keyword">struct</span> rb_node *</span><br><span class="line"><span class="title function_">rb_next_match</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *key, <span class="keyword">struct</span> rb_node *node,</span></span><br><span class="line"><span class="params">          <span class="type">int</span> (*cmp)(<span class="type">const</span> <span class="type">void</span> *key, <span class="type">const</span> <span class="keyword">struct</span> rb_node *))</span></span><br><span class="line">&#123;</span><br><span class="line">    node = rb_next(node);</span><br><span class="line">    <span class="keyword">if</span> (node &amp;&amp; cmp(key, node))</span><br><span class="line">        node = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>rb_find_first</code>返回红黑树中第一个包含指定key的节点</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * rb_find_first() - find the first @key in @tree</span></span><br><span class="line"><span class="comment"> * @key: key to match</span></span><br><span class="line"><span class="comment"> * @tree: tree to search</span></span><br><span class="line"><span class="comment"> * @cmp: operator defining node order</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns the leftmost node matching @key, or NULL.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> __always_inline <span class="keyword">struct</span> rb_node *</span><br><span class="line"><span class="title function_">rb_find_first</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *key, <span class="type">const</span> <span class="keyword">struct</span> rb_root *tree,</span></span><br><span class="line"><span class="params">          <span class="type">int</span> (*cmp)(<span class="type">const</span> <span class="type">void</span> *key, <span class="type">const</span> <span class="keyword">struct</span> rb_node *))</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">node</span> =</span> tree-&gt;rb_node;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">match</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (node) &#123;</span><br><span class="line">        <span class="type">int</span> c = cmp(key, node);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (c &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!c)</span><br><span class="line">                match = node;</span><br><span class="line">            node = node-&gt;rb_left;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            node = node-&gt;rb_right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> match;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>rb_for_each</code>通过<code>rb_find_first</code>与<code>rb_next_match</code>来遍历所有包含指定key的节点</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> rb_for_each(node, key, tree, cmp) \</span></span><br><span class="line"><span class="meta">    for ((node) = rb_find_first((key), (tree), (cmp)); \</span></span><br><span class="line"><span class="meta">         (node); (node) = rb_next_match((key), (node), (cmp)))</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>如<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.15.155/source/kernel/sched/core.c#L199">&#x2F;kernel&#x2F;sched&#x2F;core.c</a>所示，其定义了<code>rb_sched_core_cmp</code>比较函数并作为函数指针传入了<code>rb_find_first</code>中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Find left-most (aka, highest priority) task matching @cookie.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> task_struct *<span class="title function_">sched_core_find</span><span class="params">(<span class="keyword">struct</span> rq *rq, <span class="type">unsigned</span> <span class="type">long</span> cookie)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">node</span>;</span></span><br><span class="line"></span><br><span class="line">	node = rb_find_first((<span class="type">void</span> *)cookie, &amp;rq-&gt;core_tree, rb_sched_core_cmp);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * The idle task always matches any cookie!</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!node)</span><br><span class="line">		<span class="keyword">return</span> idle_sched_class.pick_task(rq);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> __node_2_sc(node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">rb_sched_core_cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *key, <span class="type">const</span> <span class="keyword">struct</span> rb_node *node)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">p</span> =</span> __node_2_sc(node);</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> cookie = (<span class="type">unsigned</span> <span class="type">long</span>)key;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (cookie &lt; p-&gt;core_cookie)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (cookie &gt; p-&gt;core_cookie)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __node_2_sc(node) rb_entry((node), struct task_struct, core_node)</span></span><br></pre></td></tr></table></figure>

<p>第二种为不调用上述遍历函数，自己通过while循环实现遍历，如<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.15.155/source/mm/vmalloc.c#L824">&#x2F;mm&#x2F;vmalloc.c</a>所示。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">vmap_area</span> *__<span class="title">find_vmap_area</span>(<span class="title">unsigned</span> <span class="title">long</span> <span class="title">addr</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">n</span> =</span> vmap_area_root.rb_node;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (n) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">vmap_area</span> *<span class="title">va</span>;</span></span><br><span class="line"></span><br><span class="line">		va = rb_entry(n, <span class="keyword">struct</span> vmap_area, rb_node);</span><br><span class="line">		<span class="keyword">if</span> (addr &lt; va-&gt;va_start)</span><br><span class="line">			n = n-&gt;rb_left;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (addr &gt;= va-&gt;va_end)</span><br><span class="line">			n = n-&gt;rb_right;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> va;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h3><ul>
<li><p><code>rb_replace_node</code> 是一个同步操作,它会直接修改红黑树的结构,并确保整个过程是原子性的。适用于单线程或者独占访问红黑树的情况,因为它可以快速完成节点替换。由于是同步操作,在高并发场景下可能会导致性能瓶颈。</p>
<p>  源码如下所示，victim为被替换的节点，new为需要替换的节点。首先找出victim的父节点，然后将victim节点的内容（颜色，父、儿子节点指针）复制到new中，将victim子节点的父节点指针指向new节点，最后调用<code>__rb_change_child</code>函数将parent的子节点指针指向的old替换为new。</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">rb_replace_node</span><span class="params">(<span class="keyword">struct</span> rb_node *victim, <span class="keyword">struct</span> rb_node *new,</span></span><br><span class="line"><span class="params">             <span class="keyword">struct</span> rb_root *root)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">parent</span> =</span> rb_parent(victim);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Copy the pointers/colour from the victim to the replacement */</span></span><br><span class="line">    *new = *victim;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set the surrounding nodes to point to the replacement */</span></span><br><span class="line">    <span class="keyword">if</span> (victim-&gt;rb_left)</span><br><span class="line">        rb_set_parent(victim-&gt;rb_left, new);</span><br><span class="line">    <span class="keyword">if</span> (victim-&gt;rb_right)</span><br><span class="line">        rb_set_parent(victim-&gt;rb_right, new);</span><br><span class="line">    __rb_change_child(victim, new, parent, root);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(rb_replace_node);</span><br></pre></td></tr></table></figure>

<p>  为了解决高并发场景下的性能瓶颈，linux内核提供了另一个替换函数：<code>rb_replace_node_rcu</code>。<code>rb_replace_node_rcu</code> 则是一种基于 RCU（Read-Copy-Update）机制的替换操作,它可以在不阻塞读取操作的情况下替换节点。</p>
</li>
<li><p><code>rb_replace_node_cached</code>是<code>rb_replace_node</code>的cached版本，其主要的功能是维护<code>rb_root_cached</code>结构体中的leftmost节点。其首先判断被替换的节点是否为leftmost节点，若是，则更新<code>rb_root_cached</code>结构体中的<code>rb_leftmost</code>变量，最后调用<code>rb_replace_node</code>，进行替换。</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">rb_replace_node_cached</span><span class="params">(<span class="keyword">struct</span> rb_node *victim,</span></span><br><span class="line"><span class="params">                      <span class="keyword">struct</span> rb_node *new,</span></span><br><span class="line"><span class="params">                      <span class="keyword">struct</span> rb_root_cached *root)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;rb_leftmost == victim)</span><br><span class="line">        root-&gt;rb_leftmost = new;</span><br><span class="line">    rb_replace_node(victim, new, &amp;root-&gt;rb_root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h3><p>红黑树中的旋转操作流程如下所示，代码中以兄弟节点为轴，向左旋转：</p>
<ol>
<li><p>以兄弟节点为轴；</p>
</li>
<li><p>调用两次<code>WRITE_ONCE</code>将父节点的右子节点替换为兄弟节点的左子节点，将兄弟节点的左子节点替换为父节点；</p>
</li>
<li><p>调用<code>rb_set_parent_color</code>将兄弟节点的左子节点的parent指针指向父节点，并染为黑色；</p>
</li>
<li><p>调用<code>__rb_rotate_set_parents</code>将兄弟节点的parent指针指向祖父节点并染成与父节点相同的颜色，将父节点的parent指针指向兄弟节点并染成红色，将祖父节点的子节点指针指向兄弟节点。</p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*     P               S</span></span><br><span class="line"><span class="comment">*    / \             / \</span></span><br><span class="line"><span class="comment">*   N   s    --&gt;    p   Sr</span></span><br><span class="line"><span class="comment">*      / \         / \</span></span><br><span class="line"><span class="comment">*     Sl  Sr      N   Sl</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">tmp1 = sibling-&gt;rb_left;</span><br><span class="line">WRITE_ONCE(parent-&gt;rb_right, tmp1);</span><br><span class="line">WRITE_ONCE(sibling-&gt;rb_left, parent);</span><br><span class="line">rb_set_parent_color(tmp1, parent, RB_BLACK);</span><br><span class="line">__rb_rotate_set_parents(parent, sibling, root, RB_RED);</span><br></pre></td></tr></table></figure>

<p><code>__rb_rotate_set_parents</code>函数首先找到old节点的父节点parent，将old节点的父指针与颜色信息复制到new节点中，调用<code>rb_set_parent_color</code>将old节点的父指针指向new节点、颜色设置为<code>color</code>，最后调用<code>__rb_change_child</code>将parent的子节点指针指向的old替换为new。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span></span><br><span class="line">__rb_rotate_set_parents(<span class="keyword">struct</span> rb_node *old, <span class="keyword">struct</span> rb_node *new,</span><br><span class="line">			<span class="keyword">struct</span> rb_root *root, <span class="type">int</span> color)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">parent</span> =</span> rb_parent(old);</span><br><span class="line">	new-&gt;__rb_parent_color = old-&gt;__rb_parent_color;</span><br><span class="line">	rb_set_parent_color(old, new, color);</span><br><span class="line">	__rb_change_child(old, new, parent, root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><ul>
<li><p><code>rb_add</code>是在红黑树中插入节点的接口。首先调用while循环找到要插入的位置，调用<code>rb_link_node</code>将node节点插入红黑树中, 最后调用<code>rb_insert_color</code>对红黑树进行平衡。</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span></span><br><span class="line"><span class="title function_">rb_add</span><span class="params">(<span class="keyword">struct</span> rb_node *node, <span class="keyword">struct</span> rb_root *tree,</span></span><br><span class="line"><span class="params">       <span class="type">bool</span> (*less)(<span class="keyword">struct</span> rb_node *, <span class="type">const</span> <span class="keyword">struct</span> rb_node *))</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> **<span class="title">link</span> =</span> &amp;tree-&gt;rb_node;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">parent</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (*link) &#123;</span><br><span class="line">        parent = *link;</span><br><span class="line">        <span class="keyword">if</span> (less(node, parent))</span><br><span class="line">            link = &amp;parent-&gt;rb_left;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            link = &amp;parent-&gt;rb_right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    rb_link_node(node, parent, link);</span><br><span class="line">    rb_insert_color(node, tree);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  <code>rb_insert_color</code>用于向插入节点添加颜色，其作为外部访问的接口, 调用内部的<code>__rb_inset</code>函数.</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">rb_insert_color</span><span class="params">(<span class="keyword">struct</span> rb_node *node, <span class="keyword">struct</span> rb_root *root)</span></span><br><span class="line">&#123;</span><br><span class="line">    __rb_insert(node, root, dummy_rotate);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(rb_insert_color);</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>rb_add_cached</code>是rb_add的cached版本。首先调用while循环找到要插入的位置, 并判断插入节点是否为leftmost节点，调用<code>rb_link_node</code>将node节点插入红黑树中, 最后调用<code>rb_insert_color_cached</code>对红黑树进行平衡。</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __always_inline <span class="keyword">struct</span> rb_node *</span><br><span class="line"><span class="title function_">rb_add_cached</span><span class="params">(<span class="keyword">struct</span> rb_node *node, <span class="keyword">struct</span> rb_root_cached *tree,</span></span><br><span class="line"><span class="params">          <span class="type">bool</span> (*less)(<span class="keyword">struct</span> rb_node *, <span class="type">const</span> <span class="keyword">struct</span> rb_node *))</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> **<span class="title">link</span> =</span> &amp;tree-&gt;rb_root.rb_node;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">parent</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">bool</span> leftmost = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (*link) &#123;</span><br><span class="line">        parent = *link;</span><br><span class="line">        <span class="keyword">if</span> (less(node, parent)) &#123;</span><br><span class="line">            link = &amp;parent-&gt;rb_left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            link = &amp;parent-&gt;rb_right;</span><br><span class="line">            leftmost = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    rb_link_node(node, parent, link);</span><br><span class="line">    rb_insert_color_cached(node, tree, leftmost);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> leftmost ? node : <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  <code>rb_insert_color_cached</code>是<code>rb_insert_color</code>的cached版本，其主要的功能是维护<code>rb_root_cached</code>结构体中的leftmost节点。其首先判断插入的节点是否为leftmost节点，若是，则更新<code>rb_root_cached</code>结构体中的<code>rb_leftmost</code>变量，最后调用<code>rb_insert_color</code>，进行插入。</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">rb_insert_color_cached</span><span class="params">(<span class="keyword">struct</span> rb_node *node,</span></span><br><span class="line"><span class="params">                      <span class="keyword">struct</span> rb_root_cached *root,</span></span><br><span class="line"><span class="params">                      <span class="type">bool</span> leftmost)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (leftmost)</span><br><span class="line">        root-&gt;rb_leftmost = node;</span><br><span class="line">    rb_insert_color(node, &amp;root-&gt;rb_root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><code>__rb_insert</code>是插入操作的主要函数，它的处理逻辑如下：</p>
<ul>
<li><p>若父节点为空, 则表明插入节点为根节点, 无需其他操作;</p>
</li>
<li><p>若父节点为黑色, 则无需其他操作直接插入;</p>
</li>
<li><p>若父节点为红色：</p>
<ul>
<li>父节点为祖父节点的左子节点<ul>
<li>插入节点为父节点的左子节点<ul>
<li>叔节点为红色，父叔变黑，祖父变红</li>
<li>叔节点为黑色，将子节点与父、祖父节点处于同意方向，父节点向叔节点方向进行旋转</li>
</ul>
</li>
<li>插入节点为父节点的右子节点<ul>
<li>叔节点为红色</li>
<li>叔节点为黑色</li>
</ul>
</li>
</ul>
</li>
<li>父节点为祖父节点的右子节点<ul>
<li>插入节点为父节点的右子节点<ul>
<li>叔节点为红色</li>
<li>叔节点为黑色</li>
</ul>
</li>
<li>插入节点为父节点的左子节点<ul>
<li>叔节点为红色</li>
<li>叔节点为黑色</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span></span><br><span class="line">__rb_insert(<span class="keyword">struct</span> rb_node *node, <span class="keyword">struct</span> rb_root *root,</span><br><span class="line">	    <span class="type">void</span> (*augment_rotate)(<span class="keyword">struct</span> rb_node *old, <span class="keyword">struct</span> rb_node *new))</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">parent</span> =</span> rb_red_parent(node), *gparent, *tmp;	<span class="comment">//声明三个节点变量-parent,gparent,tmp</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">		<span class="comment">//情况1：插入节点为根节点</span></span><br><span class="line">		<span class="keyword">if</span> (unlikely(!parent)) &#123;</span><br><span class="line">			</span><br><span class="line">			rb_set_parent_color(node, <span class="literal">NULL</span>, RB_BLACK);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//情况2：插入节点的父节点为黑色</span></span><br><span class="line">		<span class="keyword">if</span>(rb_is_black(parent))</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		</span><br><span class="line">        <span class="comment">//情况3：插入节点的父节点为红色</span></span><br><span class="line">		gparent = rb_red_parent(parent);</span><br><span class="line"></span><br><span class="line">		tmp = gparent-&gt;rb_right;	<span class="comment">//此时tmp为叔节点</span></span><br><span class="line">		<span class="keyword">if</span> (parent != tmp) &#123;	<span class="comment">//父节点为祖父节点的左子节点</span></span><br><span class="line">			<span class="keyword">if</span> (tmp &amp;&amp; rb_is_red(tmp)) &#123;	</span><br><span class="line">				<span class="comment">/*</span></span><br><span class="line"><span class="comment">				 * Case 1 - 叔节点为红色</span></span><br><span class="line"><span class="comment">				 *</span></span><br><span class="line"><span class="comment">				 *       G            g</span></span><br><span class="line"><span class="comment">				 *      / \          / \</span></span><br><span class="line"><span class="comment">				 *     p   u  --&gt;   P   U</span></span><br><span class="line"><span class="comment">				 *    /            /</span></span><br><span class="line"><span class="comment">				 *   n            n</span></span><br><span class="line"><span class="comment">				 *</span></span><br><span class="line"><span class="comment">				 * However, since g&#x27;s parent might be red, and</span></span><br><span class="line"><span class="comment">				 * 4) does not allow this, we need to recurse</span></span><br><span class="line"><span class="comment">				 * at g.</span></span><br><span class="line"><span class="comment">				 */</span></span><br><span class="line">				rb_set_parent_color(tmp, gparent, RB_BLACK);	<span class="comment">//叔节点变为黑色</span></span><br><span class="line">				rb_set_parent_color(parent, gparent, RB_BLACK);	<span class="comment">//父节点变为黑色</span></span><br><span class="line">				node = gparent;</span><br><span class="line">				parent = rb_parent(node);</span><br><span class="line">				rb_set_parent_color(node, parent, RB_RED);		<span class="comment">//祖父节点变为红色</span></span><br><span class="line">                <span class="comment">//此时祖父节点为红色，其父节点可能也为红色，需要将node指向祖父节点继续循环处理</span></span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">            </span><br><span class="line">			tmp = parent-&gt;rb_right;		<span class="comment">//此时，tmp指向父节点的右子节点</span></span><br><span class="line">			<span class="keyword">if</span> (node == tmp) &#123;			<span class="comment">//判断插入节点是否为父节点的右子节点</span></span><br><span class="line">				<span class="comment">/*</span></span><br><span class="line"><span class="comment">				 * Case 2 - 叔节点为黑色，插入节点为父节点的右子节点</span></span><br><span class="line"><span class="comment">				 *</span></span><br><span class="line"><span class="comment">				 *      G             G</span></span><br><span class="line"><span class="comment">				 *     / \           / \</span></span><br><span class="line"><span class="comment">				 *    p   U  --&gt;    n   U</span></span><br><span class="line"><span class="comment">				 *     \           /</span></span><br><span class="line"><span class="comment">				 *      n         p</span></span><br><span class="line"><span class="comment">				 *</span></span><br><span class="line"><span class="comment">				 * 此时变成Case 3，进入Case 3的处理流程</span></span><br><span class="line"><span class="comment">				 */</span></span><br><span class="line">				tmp = node-&gt;rb_left;	<span class="comment">//此时，tmp指向子节点的左子节点</span></span><br><span class="line">                <span class="comment">//进行左旋操作</span></span><br><span class="line">				WRITE_ONCE(parent-&gt;rb_right, tmp);</span><br><span class="line">				WRITE_ONCE(node-&gt;rb_left, parent);</span><br><span class="line">				<span class="keyword">if</span> (tmp)	<span class="comment">//如果子节点的左子节点存在，则将其parent指针指向父节点，并变成黑色</span></span><br><span class="line">					rb_set_parent_color(tmp, parent, RB_BLACK);		</span><br><span class="line">				rb_set_parent_color(parent, node, RB_RED);		<span class="comment">//将父节点parent指针指向node，将parent染为红色</span></span><br><span class="line">				augment_rotate(parent, node);		<span class="comment">//调用rotate回调函数，增强型红黑树中才会使用</span></span><br><span class="line">				parent = node;			<span class="comment">//parent节点变为node</span></span><br><span class="line">				tmp = node-&gt;rb_right;	<span class="comment">//将tmp恢复为父节点的右子节点</span></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * Case 3 - 叔节点为黑色，插入节点为父节点的左子节点</span></span><br><span class="line"><span class="comment">			 *</span></span><br><span class="line"><span class="comment">			 *        G           P</span></span><br><span class="line"><span class="comment">			 *       / \         / \</span></span><br><span class="line"><span class="comment">			 *      p   U  --&gt;  n   g</span></span><br><span class="line"><span class="comment">			 *     /                 \</span></span><br><span class="line"><span class="comment">			 *    n                   U</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">           <span class="comment">//进行右旋操作</span></span><br><span class="line">			WRITE_ONCE(gparent-&gt;rb_left, tmp);</span><br><span class="line">			WRITE_ONCE(parent-&gt;rb_right, gparent);</span><br><span class="line">			<span class="keyword">if</span> (tmp)	<span class="comment">//如果父节点的右子节点存在，则将其父节点指针指向gparent，并变成黑色</span></span><br><span class="line">				rb_set_parent_color(tmp, gparent, RB_BLACK);</span><br><span class="line">            <span class="comment">//将父节点的parent指针指向祖父节点的父节点，并染成祖父节点的颜色；将祖父节点的parent指针指向父节点，并染成红色</span></span><br><span class="line">			__rb_rotate_set_parents(gparent, parent, root, RB_RED);	</span><br><span class="line">			augment_rotate(gparent, parent);		<span class="comment">//调用rotate回调函数</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">//父节点为祖父节点的右子节点的情况，与上述步骤类似，不重复描述</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><ul>
<li><p><code>rb_erase</code>调用<code>__rb_erase_augmented</code>将指定节点删除，并返回红黑树是否需要重新平衡。如果需要，则调用<code>____rb_erase_color</code>。在这里调用了增强版红黑树的接口<code>__rb_erase_augmented</code>，但由于传入的回调函数指针为dummy_rotate，因此体现不出增强性质。</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">rb_erase</span><span class="params">(<span class="keyword">struct</span> rb_node *node, <span class="keyword">struct</span> rb_root *root)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">rebalance</span>;</span></span><br><span class="line">    rebalance = __rb_erase_augmented(node, root, &amp;dummy_callbacks);</span><br><span class="line">    <span class="keyword">if</span> (rebalance)</span><br><span class="line">        ____rb_erase_color(rebalance, root, dummy_rotate);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(rb_erase);</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>rb_erase_cached</code>为<code>rb_erase</code>的cached版本，其主要的功能是维护<code>rb_root_cached</code>结构体中的leftmost节点。其首先判断需要删除的节点是否为当前红黑树的leftmost节点，如果是，则调用<code>rb_next()</code>将leftmost节点更新为其后继节点，再调用<code>rb_erase</code>进行删除。</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> rb_node *</span><br><span class="line"><span class="title function_">rb_erase_cached</span><span class="params">(<span class="keyword">struct</span> rb_node *node, <span class="keyword">struct</span> rb_root_cached *root)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">leftmost</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (root-&gt;rb_leftmost == node)</span><br><span class="line">        leftmost = root-&gt;rb_leftmost = rb_next(node);</span><br><span class="line"></span><br><span class="line">    rb_erase(node, &amp;root-&gt;rb_root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><code>__rb_erase_color</code>调用<code>__rb_erase_color</code>函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Non-inline version for rb_erase_augmented() use */</span></span><br><span class="line"><span class="type">void</span> __rb_erase_color(<span class="keyword">struct</span> rb_node *parent, <span class="keyword">struct</span> rb_root *root,</span><br><span class="line">	<span class="type">void</span> (*augment_rotate)(<span class="keyword">struct</span> rb_node *old, <span class="keyword">struct</span> rb_node *new))</span><br><span class="line">&#123;</span><br><span class="line">	____rb_erase_color(parent, root, augment_rotate);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(__rb_erase_color);</span><br></pre></td></tr></table></figure>

<p><code>__rb_erase_color</code>是对删除后的节点进行染色的主要函数。其染色逻辑如下：</p>
<ul>
<li>兄弟节点为红：以父节点为轴，向左方向旋转，再进行染色；</li>
<li>兄弟节点为黑：<ul>
<li>兄弟节点的右子节点为黑：<ul>
<li>兄弟节点的左子节为黑：兄弟节点变红。若父节点为红，父节点变黑，完成染色；若父节点为黑，上移至祖父节点继续染色；</li>
<li>兄弟节点的左子节为红：以兄弟节点为轴，向右旋转，变为兄弟节点的右子节点为红的情况；</li>
</ul>
</li>
<li>兄弟节点的右子节点为红：兄弟节点变为父节点的颜色，父节点变黑，右子节点变黑，以父节点为轴，向左旋转。</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span></span><br><span class="line">____rb_erase_color(<span class="keyword">struct</span> rb_node *parent, <span class="keyword">struct</span> rb_root *root,</span><br><span class="line">	<span class="type">void</span> (*augment_rotate)(<span class="keyword">struct</span> rb_node *old, <span class="keyword">struct</span> rb_node *new))</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">node</span> =</span> <span class="literal">NULL</span>, *sibling, *tmp1, *tmp2;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Loop invariants:</span></span><br><span class="line"><span class="comment">		 * - node is black (or NULL on first iteration)</span></span><br><span class="line"><span class="comment">		 * - node is not the root (parent is not NULL)</span></span><br><span class="line"><span class="comment">		 * - All leaf paths going through parent and node have a</span></span><br><span class="line"><span class="comment">		 *   black node count that is 1 lower than other leaf paths.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		sibling = parent-&gt;rb_right;</span><br><span class="line">		<span class="keyword">if</span> (node != sibling) &#123;	<span class="comment">/* node为parent的左子节点 */</span></span><br><span class="line">			<span class="keyword">if</span> (rb_is_red(sibling)) &#123;</span><br><span class="line">				<span class="comment">/*</span></span><br><span class="line"><span class="comment">				 * Case 1 - 兄弟节点为红色，进行左旋</span></span><br><span class="line"><span class="comment">				 * 小写字母代表红色，大写字母代表黑色</span></span><br><span class="line"><span class="comment">				 *</span></span><br><span class="line"><span class="comment">				 *     P               S</span></span><br><span class="line"><span class="comment">				 *    / \             / \</span></span><br><span class="line"><span class="comment">				 *   N   s    --&gt;    p   Sr</span></span><br><span class="line"><span class="comment">				 *      / \         / \</span></span><br><span class="line"><span class="comment">				 *     Sl  Sr      N   Sl</span></span><br><span class="line"><span class="comment">				 */</span></span><br><span class="line">				tmp1 = sibling-&gt;rb_left;</span><br><span class="line">				WRITE_ONCE(parent-&gt;rb_right, tmp1);</span><br><span class="line">				WRITE_ONCE(sibling-&gt;rb_left, parent);</span><br><span class="line">				rb_set_parent_color(tmp1, parent, RB_BLACK);</span><br><span class="line">				__rb_rotate_set_parents(parent, sibling, root,</span><br><span class="line">							RB_RED);	<span class="comment">//旋转后兄弟节点变为parent的颜色，parent变为红色，</span></span><br><span class="line">				augment_rotate(parent, sibling);</span><br><span class="line">				sibling = tmp1;		<span class="comment">//旋转后变更兄弟节点，继续判断</span></span><br><span class="line">			&#125;</span><br><span class="line">            <span class="comment">//兄弟节点为黑</span></span><br><span class="line">			tmp1 = sibling-&gt;rb_right;</span><br><span class="line">			<span class="keyword">if</span> (!tmp1 || rb_is_black(tmp1)) &#123;	<span class="comment">//兄弟节点的右子节点为黑</span></span><br><span class="line">				tmp2 = sibling-&gt;rb_left;</span><br><span class="line">				<span class="keyword">if</span> (!tmp2 || rb_is_black(tmp2)) &#123;	<span class="comment">//兄弟节点的左子节点为黑</span></span><br><span class="line">					<span class="comment">/*</span></span><br><span class="line"><span class="comment">					 * Case 2 - 兄弟节点为黑，子节点均为黑</span></span><br><span class="line"><span class="comment">					 * 进行颜色翻转</span></span><br><span class="line"><span class="comment">					 * (p)表示p可以为任意颜色</span></span><br><span class="line"><span class="comment">					 *</span></span><br><span class="line"><span class="comment">					 *    (p)           (p)</span></span><br><span class="line"><span class="comment">					 *    / \           / \</span></span><br><span class="line"><span class="comment">					 *   N   S    --&gt;  N   s</span></span><br><span class="line"><span class="comment">					 *      / \           / \</span></span><br><span class="line"><span class="comment">					 *     Sl  Sr        Sl  Sr</span></span><br><span class="line"><span class="comment">					 *</span></span><br><span class="line"><span class="comment">					 */</span></span><br><span class="line">					rb_set_parent_color(sibling, parent, RB_RED); <span class="comment">//将兄弟节点变为红色</span></span><br><span class="line">					<span class="keyword">if</span> (rb_is_red(parent))	<span class="comment">//父节点为红，则将父节点变为黑色</span></span><br><span class="line">						rb_set_black(parent);</span><br><span class="line">					<span class="keyword">else</span> &#123;					<span class="comment">//父节点为黑</span></span><br><span class="line">						node = parent;</span><br><span class="line">						parent = rb_parent(node);	<span class="comment">//将父节点切换为祖父节点，继续进行判断</span></span><br><span class="line">						<span class="keyword">if</span> (parent)</span><br><span class="line">							<span class="keyword">continue</span>;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">/*</span></span><br><span class="line"><span class="comment">				 * Case 3 - 兄弟节点为黑，左子节点为红，右子节点为黑</span></span><br><span class="line"><span class="comment">				 * 以兄弟节点为轴右旋</span></span><br><span class="line"><span class="comment">				 *</span></span><br><span class="line"><span class="comment">				 *   (p)           (p)</span></span><br><span class="line"><span class="comment">				 *   / \           / \</span></span><br><span class="line"><span class="comment">				 *  N   S    --&gt;  N   sl</span></span><br><span class="line"><span class="comment">				 *     / \             \</span></span><br><span class="line"><span class="comment">				 *    sl  Sr            S</span></span><br><span class="line"><span class="comment">				 *                       \</span></span><br><span class="line"><span class="comment">				 *                        Sr</span></span><br><span class="line"><span class="comment">				 */</span></span><br><span class="line">				tmp1 = tmp2-&gt;rb_right;</span><br><span class="line">				WRITE_ONCE(sibling-&gt;rb_left, tmp1);</span><br><span class="line">				WRITE_ONCE(tmp2-&gt;rb_right, sibling);</span><br><span class="line">				WRITE_ONCE(parent-&gt;rb_right, tmp2);</span><br><span class="line">				<span class="keyword">if</span> (tmp1)</span><br><span class="line">					rb_set_parent_color(tmp1, sibling,</span><br><span class="line">							    RB_BLACK);</span><br><span class="line">				augment_rotate(sibling, tmp2);</span><br><span class="line">				tmp1 = sibling;</span><br><span class="line">				sibling = tmp2;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * Case 4 - 兄弟节点为黑，右子节点为红，左子节点为任意颜色</span></span><br><span class="line"><span class="comment">			 *	以父节点为轴左旋 + 颜色翻转</span></span><br><span class="line"><span class="comment">			 *</span></span><br><span class="line"><span class="comment">			 *      (p)             (s)</span></span><br><span class="line"><span class="comment">			 *      / \             / \</span></span><br><span class="line"><span class="comment">			 *     N   S     --&gt;   P   Sr</span></span><br><span class="line"><span class="comment">			 *        / \         / \</span></span><br><span class="line"><span class="comment">			 *      (sl) sr      N  (sl)</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			tmp2 = sibling-&gt;rb_left;</span><br><span class="line">			WRITE_ONCE(parent-&gt;rb_right, tmp2);</span><br><span class="line">			WRITE_ONCE(sibling-&gt;rb_left, parent);</span><br><span class="line">			rb_set_parent_color(tmp1, sibling, RB_BLACK);</span><br><span class="line">			<span class="keyword">if</span> (tmp2)</span><br><span class="line">				rb_set_parent(tmp2, parent);</span><br><span class="line">			__rb_rotate_set_parents(parent, sibling, root,</span><br><span class="line">						RB_BLACK);</span><br><span class="line">			augment_rotate(parent, sibling);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">//父节点为祖父节点的右子节点的情况，与上述步骤类似，不重复描述</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="红黑树增强版"><a href="#红黑树增强版" class="headerlink" title="红黑树增强版"></a>红黑树增强版</h1><p>内核中的红黑树实现了增强的接口，称之为Augmented rbtrees。增强版红黑树在每个节点中存储了一些附加的数据，其中节点N的附加数据为以节点N为根节点的子树中所有节点内容的函数。想要使用增强版红黑树，在插入和删除结点时必须调用增强型接口并提供增强型回调函数。</p>
<ul>
<li><p>插入节点时，用户必须更新通往被插入节点的路径上的增强信息，然后像往常一样调用<code>rb_link_node()</code>。增强版插入接口是<code>rb_augment_inserted()</code>而不是平时的<code>rb_insert_color()</code>。如果 <code>rb_augment_inserted()</code>再平衡了红黑树，它将回调至一个用户提供的函数来更新受影响的子树上的增强信息。</p>
</li>
<li><p>删除节点时，用户必须调用<code>rb_erase_augmented()</code>而不是<code>rb_erase()</code>。 <code>rb_erase_augmented()</code>回调一个用户提供的函数来更新受影响的子树上的增强信息。</p>
</li>
</ul>
<p>在上述情况下，回调都是通过<code>rb_augment_callbacks</code>结构体提供的。增强版红黑树必须定义3个回调：</p>
<ul>
<li>一个传播回调propagate，它更新一个给定结点和它的祖先们的增强数据，直到一个给定的停止点 （如果是NULL，将更新一路更新到树根）。</li>
<li>一个复制回调copy，它将一颗给定子树的增强数据复制到一个新指定的子树树根。</li>
<li>一个树旋转回调rotate，它将一颗给定的子树的增强值复制到新指定的子树树根上，并重新计算 先前的子树树根的增强值。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rb_augment_callbacks</span> &#123;</span></span><br><span class="line">    <span class="type">void</span> (*propagate)(<span class="keyword">struct</span> rb_node *node, <span class="keyword">struct</span> rb_node *stop);</span><br><span class="line">    <span class="type">void</span> (*copy)(<span class="keyword">struct</span> rb_node *old, <span class="keyword">struct</span> rb_node *new);</span><br><span class="line">    <span class="type">void</span> (*rotate)(<span class="keyword">struct</span> rb_node *old, <span class="keyword">struct</span> rb_node *new);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="插入-1"><a href="#插入-1" class="headerlink" title="插入"></a>插入</h3><ul>
<li><p><code>rb_insert_augmented</code>调用<code>__rb_insert_augmented</code></p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">rb_insert_augmented</span><span class="params">(<span class="keyword">struct</span> rb_node *node, <span class="keyword">struct</span> rb_root *root,</span></span><br><span class="line"><span class="params">            <span class="type">const</span> <span class="keyword">struct</span> rb_augment_callbacks *augment)</span></span><br><span class="line">&#123;</span><br><span class="line">    __rb_insert_augmented(node, root, augment-&gt;rotate);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>rb_insert_augmented_cached</code>将插入节点替换为了rb_root_cached结构体中的rb_leftmost节点，即中序遍历中最小的点。</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">rb_insert_augmented_cached</span><span class="params">(<span class="keyword">struct</span> rb_node *node,</span></span><br><span class="line"><span class="params">               <span class="keyword">struct</span> rb_root_cached *root, <span class="type">bool</span> newleft,</span></span><br><span class="line"><span class="params">               <span class="type">const</span> <span class="keyword">struct</span> rb_augment_callbacks *augment)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (newleft)</span><br><span class="line">        root-&gt;rb_leftmost = node;</span><br><span class="line">    rb_insert_augmented(node, &amp;root-&gt;rb_root, augment);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><code>__rb_insert_augmented</code>调用了普通红黑树的插入操作<code>__rb_insert</code>，与普通红黑树插入操作不同的是，增强版插入用<code>augment_rotate</code>替代<code>dummy_rotate</code>作为回调函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __rb_insert_augmented(<span class="keyword">struct</span> rb_node *node, <span class="keyword">struct</span> rb_root *root,</span><br><span class="line">	<span class="type">void</span> (*augment_rotate)(<span class="keyword">struct</span> rb_node *old, <span class="keyword">struct</span> rb_node *new))</span><br><span class="line">&#123;</span><br><span class="line">	__rb_insert(node, root, augment_rotate);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h3><ul>
<li><p><code>rb_erase_augmented</code>首先调用<code>__rb_erase_augmented</code>函数删除节点，并返回是否需要重新平衡。若需要重新平衡，则调用<code>__rb_erase_color</code>函数。</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span></span><br><span class="line"><span class="title function_">rb_erase_augmented</span><span class="params">(<span class="keyword">struct</span> rb_node *node, <span class="keyword">struct</span> rb_root *root,</span></span><br><span class="line"><span class="params">           <span class="type">const</span> <span class="keyword">struct</span> rb_augment_callbacks *augment)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">rebalance</span> =</span> __rb_erase_augmented(node, root, augment);</span><br><span class="line">    <span class="keyword">if</span> (rebalance)</span><br><span class="line">        __rb_erase_color(rebalance, root, augment-&gt;rotate);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>rb_erase_augmented_cached</code>是<code>rb_erase_augmented</code>的cached版本，使用<code>rb_root_cached</code>结构体来获取红黑树中key值最小的节点。</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span></span><br><span class="line"><span class="title function_">rb_erase_augmented_cached</span><span class="params">(<span class="keyword">struct</span> rb_node *node, <span class="keyword">struct</span> rb_root_cached *root,</span></span><br><span class="line"><span class="params">              <span class="type">const</span> <span class="keyword">struct</span> rb_augment_callbacks *augment)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;rb_leftmost == node)</span><br><span class="line">        root-&gt;rb_leftmost = rb_next(node);</span><br><span class="line">    rb_erase_augmented(node, &amp;root-&gt;rb_root, augment);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><code>__rb_erase_augmented</code>实现了指定节点的删除，其删除逻辑如下：</p>
<ul>
<li>若删除的节点没有子节点，直接删除，需要根据删除节点的颜色判断是否需要重新平衡红黑树；</li>
<li>若删除的节点只有一个子节点（其本身一定为黑，子节点一定为红），则直接用其子节点替代它本身，不需要重新平衡红黑树；</li>
<li>若删除的节点有两个子节点，则找出中序遍历顺序中它的后继节点并代替它本身，具体流程如下：<ul>
<li>若其右子节点没有左子节点，则直接用右子节点代替需要删除的节点；</li>
<li>若其右子节点有左子节点，则调用while循环找出右子树中的leftmost节点，用leftmost节点替换需要删除的节点。</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __always_inline <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *</span></span><br><span class="line"><span class="class">__<span class="title">rb_erase_augmented</span>(<span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">node</span>, <span class="keyword">struct</span> <span class="title">rb_root</span> *<span class="title">root</span>,</span></span><br><span class="line"><span class="class">		     <span class="title">const</span> <span class="keyword">struct</span> <span class="title">rb_augment_callbacks</span> *<span class="title">augment</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">child</span> =</span> node-&gt;rb_right;	<span class="comment">//删除节点的右子节点</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">tmp</span> =</span> node-&gt;rb_left;	<span class="comment">//删除节点的左子节点</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">parent</span>, *<span class="title">rebalance</span>;</span>		<span class="comment">//parent为删除节点的父节点，rebalance为需要进行染色操作的节点</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> pc;	<span class="comment">//parent_color</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!tmp) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * node只有一个右子节点或没有子节点</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * 如果只有一个子节点，那子节点一定是红色的，他本身一定是黑色的</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		pc = node-&gt;__rb_parent_color;</span><br><span class="line">		parent = __rb_parent(pc);</span><br><span class="line">		__rb_change_child(node, child, parent, root);</span><br><span class="line">		<span class="keyword">if</span> (child) &#123;</span><br><span class="line">            <span class="comment">//存在右子节点，直接用右子节点替换其本身，不需要重新平衡</span></span><br><span class="line">			child-&gt;__rb_parent_color = pc;</span><br><span class="line">			rebalance = <span class="literal">NULL</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span></span><br><span class="line">            <span class="comment">//没有子节点的情况。若删除节点为黑色，需要重新平衡；若为红色，不需要重新平衡</span></span><br><span class="line">			rebalance = __rb_is_black(pc) ? parent : <span class="literal">NULL</span>;</span><br><span class="line">		tmp = parent;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!child) &#123;</span><br><span class="line">		<span class="comment">/* node只有一个左子节点 */</span></span><br><span class="line">		tmp-&gt;__rb_parent_color = pc = node-&gt;__rb_parent_color;</span><br><span class="line">		parent = __rb_parent(pc);</span><br><span class="line">		__rb_change_child(node, tmp, parent, root);</span><br><span class="line">		rebalance = <span class="literal">NULL</span>;	</span><br><span class="line">		tmp = parent;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* node有两个子节点， */</span></span><br><span class="line">		<span class="keyword">struct</span> rb_node *successor = child, *child2;</span><br><span class="line"></span><br><span class="line">		tmp = child-&gt;rb_left;</span><br><span class="line">		<span class="keyword">if</span> (!tmp) &#123;</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * node的后继节点为它的右子节点</span></span><br><span class="line"><span class="comment">			 *</span></span><br><span class="line"><span class="comment">			 *    (n)          (s)</span></span><br><span class="line"><span class="comment">			 *    / \          / \</span></span><br><span class="line"><span class="comment">			 *  (x) (s)  -&gt;  (x) (c)</span></span><br><span class="line"><span class="comment">			 *        \</span></span><br><span class="line"><span class="comment">			 *        (c)</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			parent = successor;</span><br><span class="line">			child2 = successor-&gt;rb_right;</span><br><span class="line"></span><br><span class="line">			augment-&gt;copy(node, successor);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * node的后继节点为右子树的leftmost节点</span></span><br><span class="line"><span class="comment">			 *</span></span><br><span class="line"><span class="comment">			 *    (n)          (s)</span></span><br><span class="line"><span class="comment">			 *    / \          / \</span></span><br><span class="line"><span class="comment">			 *  (x) (y)  -&gt;  (x) (y)</span></span><br><span class="line"><span class="comment">			 *      /            /</span></span><br><span class="line"><span class="comment">			 *    (p)          (p)</span></span><br><span class="line"><span class="comment">			 *    /            /</span></span><br><span class="line"><span class="comment">			 *  (s)          (c)</span></span><br><span class="line"><span class="comment">			 *    \</span></span><br><span class="line"><span class="comment">			 *    (c)</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">do</span> &#123;</span><br><span class="line">				parent = successor;</span><br><span class="line">				successor = tmp;</span><br><span class="line">				tmp = tmp-&gt;rb_left;</span><br><span class="line">			&#125; <span class="keyword">while</span> (tmp);	<span class="comment">//找到右子树的leftmost节点</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//由于leftmost节点没有左子节点，因此直接用leftmost节点的右子节点替换它本身。</span></span><br><span class="line">			child2 = successor-&gt;rb_right;</span><br><span class="line">			WRITE_ONCE(parent-&gt;rb_left, child2);</span><br><span class="line">			WRITE_ONCE(successor-&gt;rb_right, child);</span><br><span class="line">			rb_set_parent(child, successor);</span><br><span class="line"></span><br><span class="line">			augment-&gt;copy(node, successor);</span><br><span class="line">			augment-&gt;propagate(parent, successor);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//用leftmost节点替换node节点</span></span><br><span class="line">		tmp = node-&gt;rb_left;</span><br><span class="line">		WRITE_ONCE(successor-&gt;rb_left, tmp);</span><br><span class="line">		rb_set_parent(tmp, successor);</span><br><span class="line"></span><br><span class="line">		pc = node-&gt;__rb_parent_color;</span><br><span class="line">		tmp = __rb_parent(pc);</span><br><span class="line">		__rb_change_child(node, successor, tmp, root);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (child2) &#123;</span><br><span class="line">            <span class="comment">//leftmost的右子节点存在，此时右子节点一定为红色，将右子节点染为黑色，不需要重新平衡红黑树</span></span><br><span class="line">			rb_set_parent_color(child2, parent, RB_BLACK);</span><br><span class="line">			rebalance = <span class="literal">NULL</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//leftmost的右子节点不存在，如果leftmost节点为黑色，需要重新平衡红黑树，如果为红色，则不需要。</span></span><br><span class="line">			rebalance = rb_is_black(successor) ? parent : <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		successor-&gt;__rb_parent_color = pc;</span><br><span class="line">		tmp = successor;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//结束删除操作，调用propagate，函数返回。</span></span><br><span class="line">	augment-&gt;propagate(tmp, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">return</span> rebalance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h3><p>一种增强型红黑树的使用案例为区间树（线段树），定义在<a href="/include/linux/interval_tree.h">&#x2F;include&#x2F;linux&#x2F;interval_tree.h</a>中。</p>
<p>区间树在内核中的使用场景有以下几个：</p>
<ul>
<li>mmu的管理—<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.15.155/source/include/linux/mmu_notifier.h#L258">mmu_interval_notifier</a></li>
<li>文件系统中的fuse与dax—<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.15.155/source/fs/fuse/dax.c#L44">fuse_dax_mapping</a></li>
</ul>
<p>经典的红黑树只有一个键，它不能直接用来存储像[lo:hi]这样的区间范围，也不能快速查找与新的[lo:hi]重叠的部分，或者查找是否有与新的[lo:hi]完全匹配的部分。</p>
<p>然而，内核通过增强型红黑树，以一种结构化的方式来存储这种区间范围，使得高效的查找和精确匹配成为可能。</p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h3 id="WRITE-ONCE"><a href="#WRITE-ONCE" class="headerlink" title="WRITE_ONCE"></a>WRITE_ONCE</h3><p><code>WRITE_ONCE</code> 是一个用于确保对变量进行一次性写操作的宏，是对volatile和内存屏障的封装。<code>WRITE_ONCE</code> 的用处是对变量赋值，它的目的是避免编译器优化对变量的写操作，从而确保写操作的有序性、原子性和可见性，特别是在多线程环境中。</p>
<p>编译器在优化代码的时候，会对一些操作进行重排序，或者删掉一些它认为无用的操作。这些优化在单线程的环境下不存在问题，但是对于操作系统而言，时刻都存在着并行的计算，这样的乱序处理很可能会造成问题。为了保证代码之间不乱序，我们可以使用<code>READ_ONCE()</code>和<code>WRITE_ONCE()</code>宏，告知编译器涉及到的操作之间不能乱序。</p>
<p><code>WRITE_ONCE</code>的宏定义位于&#x2F;tools&#x2F;include&#x2F;linux&#x2F;<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.15.155/source/tools/include/linux/compiler.h#L184">compiler.h</a>，其运行流程如下：</p>
<ol>
<li><p><code>(&#123; ... &#125;)</code>: 这是一个GNU扩展的语法块（statement expression），允许在块的最后返回一个值。这个语法在标准C中并不支持，但在GCC等编译器中是可以使用的。它是用于代替<code>do &#123; ... &#125; while (0)</code>表达式的。</p>
</li>
<li><p><code>union &#123; typeof(x) __val; char __c[1]; &#125; __u = &#123; .__val = (val) &#125;;</code>定义联合<code>__u</code>, 通过这种联合，可以在不改变底层数据的情况下，将 <code>__val</code> 解释成一个字符数组 <code>__c</code>。虽然数组长度为1，但它实际目的是指向联合的内存区域的起始位置，从而可以访问整个变量的字节。</p>
</li>
<li><p><code>__write_once_size</code>将 <code>__u.__c</code>（也就是 __val 按字节形式）写入到 x 的地址，并且写入的大小是 x 的大小。</p>
</li>
<li><p>最后，返回联合体中的 __val 成员的值，这样宏的返回值就是赋值后的 val。</p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> WRITE_ONCE(x, val)				\</span></span><br><span class="line"><span class="meta">(&#123;							\</span></span><br><span class="line"><span class="meta">	union &#123; typeof(x) __val; char __c[1]; &#125; __u =	\</span></span><br><span class="line"><span class="meta">		&#123; .__val = (val) &#125;; 			\</span></span><br><span class="line"><span class="meta">	__write_once_size(&amp;(x), __u.__c, sizeof(x));	\</span></span><br><span class="line"><span class="meta">	__u.__val;					\</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> __write_once_size(<span class="keyword">volatile</span> <span class="type">void</span> *p, <span class="type">void</span> *res, <span class="type">int</span> size)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">switch</span> (size) &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">1</span>: *(<span class="keyword">volatile</span>  <span class="type">__u8_alias_t</span> *) p = *(<span class="type">__u8_alias_t</span>  *) res; <span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">2</span>: *(<span class="keyword">volatile</span> <span class="type">__u16_alias_t</span> *) p = *(<span class="type">__u16_alias_t</span> *) res; <span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">4</span>: *(<span class="keyword">volatile</span> <span class="type">__u32_alias_t</span> *) p = *(<span class="type">__u32_alias_t</span> *) res; <span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">8</span>: *(<span class="keyword">volatile</span> <span class="type">__u64_alias_t</span> *) p = *(<span class="type">__u64_alias_t</span> *) res; <span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		barrier();	<span class="comment">//内存屏障函数 barrier()，防止编译器对内存操作进行重排序。</span></span><br><span class="line">		__builtin_memcpy((<span class="type">void</span> *)p, (<span class="type">const</span> <span class="type">void</span> *)res, size);	<span class="comment">//进行内存复制，将 res 指向的内容复制到 p 指向的地址</span></span><br><span class="line">		barrier();	<span class="comment">//再次调用内存屏障函数 barrier()，确保 memcpy 的操作不会被重排序。</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="RCU"><a href="#RCU" class="headerlink" title="RCU"></a>RCU</h3><p>上文替换操作中的<code>rb_replace_node()</code>函数是一个同步操作,它会直接修改红黑树的结构,并确保整个过程是原子性的。适用于单线程或者独占访问红黑树的情况,因为它可以快速完成节点替换。由于是同步操作,在高并发场景下可能会导致性能瓶颈。</p>
<p><code>rb_replace_node_rcu</code> 则是一种基于 RCU（Read-Copy-Update）机制的替换操作,它可以在不阻塞读取操作的情况下替换节点。适用于多线程并发访问红黑树的情况,它可以在不影响读取操作的情况下替换节点。由于引入了 RCU 机制,在高并发场景下性能会更好,但也增加了一定的复杂度。</p>
<p>RCU方法首先在新的位置插入新的节点,然后再将旧节点从树中删除。这样可以确保在删除旧节点之前,所有的读取操作都可以访问到正确的数据。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">rb_replace_node_rcu</span><span class="params">(<span class="keyword">struct</span> rb_node *victim, <span class="keyword">struct</span> rb_node *new,</span></span><br><span class="line"><span class="params">			 <span class="keyword">struct</span> rb_root *root)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">parent</span> =</span> rb_parent(victim);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Copy the pointers/colour from the victim to the replacement */</span></span><br><span class="line">	*new = *victim;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Set the surrounding nodes to point to the replacement */</span></span><br><span class="line">	<span class="keyword">if</span> (victim-&gt;rb_left)</span><br><span class="line">		rb_set_parent(victim-&gt;rb_left, new);</span><br><span class="line">	<span class="keyword">if</span> (victim-&gt;rb_right)</span><br><span class="line">		rb_set_parent(victim-&gt;rb_right, new);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Set the parent&#x27;s pointer to the new node last after an RCU barrier</span></span><br><span class="line"><span class="comment">	 * so that the pointers onwards are seen to be set correctly when doing</span></span><br><span class="line"><span class="comment">	 * an RCU walk over the tree.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	__rb_change_child_rcu(victim, new, parent, root);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(rb_replace_node_rcu);</span><br></pre></td></tr></table></figure>

<p><code>rb_replace_node()</code>和<code>rb_replace_node_rcu()</code>的差异在于<code>__rb_change_child()</code>和<code>__rb_change_child_rcu()</code>, 而<code>__rb_change_child()</code>与<code>__rb_change_child_rcu()</code>的差异在于<code>WRITE_ONCE</code>和<code>rcu_assign_pointer</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span></span><br><span class="line">__rb_change_child(<span class="keyword">struct</span> rb_node *old, <span class="keyword">struct</span> rb_node *new,</span><br><span class="line">		  <span class="keyword">struct</span> rb_node *parent, <span class="keyword">struct</span> rb_root *root)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (parent) &#123;</span><br><span class="line">		<span class="keyword">if</span> (parent-&gt;rb_left == old)</span><br><span class="line">			WRITE_ONCE(parent-&gt;rb_left, new);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			WRITE_ONCE(parent-&gt;rb_right, new);</span><br><span class="line">	&#125; <span class="keyword">else</span></span><br><span class="line">		WRITE_ONCE(root-&gt;rb_node, new);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span></span><br><span class="line">__rb_change_child_rcu(<span class="keyword">struct</span> rb_node *old, <span class="keyword">struct</span> rb_node *new,</span><br><span class="line">		      <span class="keyword">struct</span> rb_node *parent, <span class="keyword">struct</span> rb_root *root)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (parent) &#123;</span><br><span class="line">		<span class="keyword">if</span> (parent-&gt;rb_left == old)</span><br><span class="line">			rcu_assign_pointer(parent-&gt;rb_left, new);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			rcu_assign_pointer(parent-&gt;rb_right, new);</span><br><span class="line">	&#125; <span class="keyword">else</span></span><br><span class="line">		rcu_assign_pointer(root-&gt;rb_node, new);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>rcu_assign_pointer</code>的定义位于&#x2F;include&#x2F;linux&#x2F;<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.15.155/source/include/linux/rcupdate.h#L496">rcupdate.h</a>，用于将v复制到p指向的内存地址。</p>
<ol>
<li><code>do &#123; ... &#125; while (0)</code>: 使用 do … while (0) 结构包裹宏定义，以确保宏在使用时的语法一致性和安全性。</li>
<li><code>rcu_check_sparse(p, __rcu);</code>: 调用 rcu_check_sparse 函数（或宏），检查 p 是否是一个合法的 RCU 指针。这一步通常用于静态代码分析或编译期检查，以确保类型安全。</li>
<li><code>WRITE_ONCE((p), (typeof(p))(_r_a_p__v));</code>: 如果 v 是一个编译时常量且等于 NULL，则使用 WRITE_ONCE 宏将 _r_a_p__v 的值写入 p，确保写操作的原子性和可见性。</li>
<li><code>smp_store_release(&amp;p, RCU_INITIALIZER((typeof(p))_r_a_p__v));</code>: 使用 <code>smp_store_release</code> 函数（或内建函数）执行带有内存屏障的存储操作，将 <code>RCU_INITIALIZER((typeof(p))_r_a_p__v)</code> 的值写入 <code>p</code>。<ul>
<li><code>RCU_INITIALIZER((typeof(p))_r_a_p__v)</code>: 是一个宏或函数，用于初始化 RCU 指针，确保指针的正确性。</li>
<li><code>smp_store_release(&amp;p, ...)</code>: 确保存储操作在多处理器环境中是有序的，防止编译器和 CPU 重排序。</li>
</ul>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> rcu_assign_pointer(p, v)					      \</span></span><br><span class="line"><span class="meta">do &#123;									      \</span></span><br><span class="line"><span class="meta">	uintptr_t _r_a_p__v = (uintptr_t)(v);				      \</span></span><br><span class="line"><span class="meta">	rcu_check_sparse(p, __rcu);					      \</span></span><br><span class="line"><span class="meta">									      \</span></span><br><span class="line"><span class="meta">	<span class="keyword">if</span> (__builtin_constant_p(v) &amp;&amp; (_r_a_p__v) == (uintptr_t)NULL)	      \</span></span><br><span class="line"><span class="meta">		WRITE_ONCE((p), (typeof(p))(_r_a_p__v));		      \</span></span><br><span class="line"><span class="meta">	<span class="keyword">else</span>								      \</span></span><br><span class="line"><span class="meta">		smp_store_release(&amp;p, RCU_INITIALIZER((typeof(p))_r_a_p__v)); \</span></span><br><span class="line"><span class="meta">&#125; while (0)</span></span><br></pre></td></tr></table></figure>

<p>除<code>rb_replace_node()</code>外，<code>rb_link_node</code>函数也有RCU版本，rb_link_node直接对rb_link赋值node，而rb_link_node_rcu调用<code>rcu_assign_pointer</code>对rb_link进行赋值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">rb_link_node</span><span class="params">(<span class="keyword">struct</span> rb_node *node, <span class="keyword">struct</span> rb_node *parent,</span></span><br><span class="line"><span class="params">				<span class="keyword">struct</span> rb_node **rb_link)</span></span><br><span class="line">&#123;</span><br><span class="line">	node-&gt;__rb_parent_color = (<span class="type">unsigned</span> <span class="type">long</span>)parent;</span><br><span class="line">	node-&gt;rb_left = node-&gt;rb_right = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	*rb_link = node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">rb_link_node_rcu</span><span class="params">(<span class="keyword">struct</span> rb_node *node, <span class="keyword">struct</span> rb_node *parent,</span></span><br><span class="line"><span class="params">				    <span class="keyword">struct</span> rb_node **rb_link)</span></span><br><span class="line">&#123;</span><br><span class="line">	node-&gt;__rb_parent_color = (<span class="type">unsigned</span> <span class="type">long</span>)parent;</span><br><span class="line">	node-&gt;rb_left = node-&gt;rb_right = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	rcu_assign_pointer(*rb_link, node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="EXPORT-SYMBOL"><a href="#EXPORT-SYMBOL" class="headerlink" title="EXPORT_SYMBOL"></a>EXPORT_SYMBOL</h3><p><code>EXPORT_SYMBOL()</code>是宏定义，用于将内核符号导出到内核符号表中。<code>EXPORT_SYMBOL()</code> 定义的函数或者符号对全部内核代码公开，不用修改内核代码就可以在其它内核模块中直接调用，即使用 EXPORT_SYMBOL 可以将一个函数以符号的方式导出给其他模块使用。</p>
<p>其定义位于<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.15.155/source/include/linux/export.h">&#x2F;inclue&#x2F;linux&#x2F;export.h</a>中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> EXPORT_SYMBOL(sym)		_EXPORT_SYMBOL(sym, <span class="string">&quot;&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _EXPORT_SYMBOL(sym, sec)	__EXPORT_SYMBOL(sym, sec, <span class="string">&quot;&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ___EXPORT_SYMBOL(sym, sec, ns)						\</span></span><br><span class="line"><span class="meta">	extern typeof(sym) sym;							\</span></span><br><span class="line"><span class="meta">	extern const char __kstrtab_##sym[];					\</span></span><br><span class="line"><span class="meta">	extern const char __kstrtabns_##sym[];					\</span></span><br><span class="line"><span class="meta">	__CRC_SYMBOL(sym, sec);							\</span></span><br><span class="line"><span class="meta">	asm(<span class="string">&quot;	.section \&quot;__ksymtab_strings\&quot;,\&quot;aMS\&quot;,%progbits,1	\n&quot;</span>	\</span></span><br><span class="line"><span class="meta">	    <span class="string">&quot;__kstrtab_&quot;</span> #sym <span class="string">&quot;:					\n&quot;</span>	\</span></span><br><span class="line"><span class="meta">	    <span class="string">&quot;	.asciz 	\&quot;&quot;</span> #sym <span class="string">&quot;\&quot;					\n&quot;</span>	\</span></span><br><span class="line"><span class="meta">	    <span class="string">&quot;__kstrtabns_&quot;</span> #sym <span class="string">&quot;:					\n&quot;</span>	\</span></span><br><span class="line"><span class="meta">	    <span class="string">&quot;	.asciz 	\&quot;&quot;</span> ns <span class="string">&quot;\&quot;					\n&quot;</span>	\</span></span><br><span class="line"><span class="meta">	    <span class="string">&quot;	.previous						\n&quot;</span>);	\</span></span><br><span class="line"><span class="meta">	__KSYMTAB_ENTRY(sym, sec)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __KSYMTAB_ENTRY(sym, sec)					\</span></span><br><span class="line"><span class="meta">	static const struct kernel_symbol __ksymtab_##sym		\</span></span><br><span class="line"><span class="meta">	__attribute__((section(<span class="string">&quot;___ksymtab&quot;</span> sec <span class="string">&quot;+&quot;</span> #sym), used))	\</span></span><br><span class="line"><span class="meta">	__aligned(sizeof(void *))					\</span></span><br><span class="line"><span class="meta">	= &#123; (unsigned long)&amp;sym, __kstrtab_##sym, __kstrtabns_##sym &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kernel_symbol</span> &#123;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> value;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *namespace;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/master/Documentation/core-api/rbtree.rst">Linux rbtree document</a></p>
<p><a target="_blank" rel="noopener" href="https://www.kernel.org/doc/html/latest/translations/zh_CN/core-api/rbtree.html">Linux rbtree document（中文）</a></p>
<p><a target="_blank" rel="noopener" href="https://linux.laoqinren.net/posts/rbtree-linux-kernel/">红黑树(二)——linux 内核的设计实现</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/theseventhson/p/15848260.html">红黑树在内核的应用——timer定时器</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/wicub/p/6031093.html">do{…}while(0)的意义和用法</a></p>
<p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1801450">WRITE_ONCE与volatile</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/google/kernel-sanitizers/blob/master/other/READ_WRITE_ONCE.md">Why kernel code should use READ_ONCE and WRITE_ONCE for shared memory accesses</a></p>
<p><a target="_blank" rel="noopener" href="https://oi-wiki.org/ds/seg/">OI-wiki线段树</a></p>
</div></article></div></main><footer><div class="paginator"><a href="/2024/07/31/lineageos/" class="prev">PREV</a><a href="/2024/05/15/uboot_booti/" class="next">NEXT</a></div><div class="copyright"><p>© 2022 - 2024 <a href="https://big7ng.github.io">Big7ng</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>