<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Big7ng&#39;s Blog</title>
  
  
  <link href="https://big7ng.github.io/atom.xml" rel="self"/>
  
  <link href="https://big7ng.github.io/"/>
  <updated>2024-03-23T16:39:15.144Z</updated>
  <id>https://big7ng.github.io/</id>
  
  <author>
    <name>Big7ng</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>使用C++ fastdeploy库部署yolov5lite模型</title>
    <link href="https://big7ng.github.io/2024/03/24/fastdeploy/"/>
    <id>https://big7ng.github.io/2024/03/24/fastdeploy/</id>
    <published>2024-03-23T16:35:54.365Z</published>
    <updated>2024-03-23T16:39:15.144Z</updated>
    
    <content type="html"><![CDATA[<p>使用python的fastdeploy库部署yolov5lite模型非常简单，只需要pip命令安装即可，但其运行速度慢，不适合在生产环境中使用，因此本文使用C++ fastdeploy库部署yolov5lite模型。</p><h1 id="运行官方demo"><a href="#运行官方demo" class="headerlink" title="运行官方demo"></a>运行官方demo</h1><p>clone官方源码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/PaddlePaddle/FastDeploy.git</span><br></pre></td></tr></table></figure><p>进入yolov5lite example目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ./FastDeploy/examples/vison/detection/yolov5lite</span><br></pre></td></tr></table></figure><p>下载预编译Fastdeploy库，需要在根据自己的硬件平台下载相应版本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir build</span><br><span class="line">cd build</span><br><span class="line">wget https://bj.bcebos.com/fastdeploy/release/cpp/fastdeploy-linux-aarch64-1.0.0.tgz</span><br><span class="line">tar xvf fastdeploy-linux-aarch64-1.0.0.tgz</span><br></pre></td></tr></table></figure><p>编译demo程序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cmake .. -DFASTDEPLOY_INSTALL_DIR=$&#123;PWD&#125;/fastdeploy-linux-aarch64-1.0.0.tgz</span><br><span class="line">make -j</span><br></pre></td></tr></table></figure><p>下载官方提供的模型与文件（也可以自己准备）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://bj.bcebos.com/paddlehub/fastdeploy/v5Lite-g-sim-640.onnx</span><br><span class="line">wget https://gitee.com/paddlepaddle/PaddleDetection/raw/release/2.4/demo/000000014439.jpg</span><br></pre></td></tr></table></figure><p>运行程序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./infer_demo v5Lite-g-sim-640.onnx 000000014439.jpg 0</span><br></pre></td></tr></table></figure><p>如果运行程序后出现了这个错误：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./infer_demo: error while loading shared libraries: libonnxruntime.so.1.12.0: cannot open shared object file: No such file or directory</span><br></pre></td></tr></table></figure><p>通过执行如下命令，将FastDeploy的库路径添加到环境变量之后，重新执行二进制程序。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source /home/user/FastDeploy/build/compiled_fastdeploy_sdk/fastdeploy_init.sh</span><br></pre></td></tr></table></figure><h1 id="编译Fastdeploy"><a href="#编译Fastdeploy" class="headerlink" title="编译Fastdeploy"></a>编译Fastdeploy</h1><p>官方提供的Fastdeploy库自带的opencv库<strong>无法支持Video的读取</strong>，以及<strong>imshow等可视化界面功能</strong>。若要使用这些功能，则需要自行编译，编译时通过<code>-DOPENCV_DIRECTORY</code>来指定环境中的OpenCV。</p><p>使用包管理器下载Opencv库，opencv库的地址一般在&#x2F;usr&#x2F;lib&#x2F;aarch64-linux-gnu&#x2F;cmake&#x2F;opencv4下，需要根据自己的硬件平台切换。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install libopencv-dev</span><br></pre></td></tr></table></figure><p>开始编译，本文只需要实现视觉功能，更多编译参数参考<a href="https://github.com/PaddlePaddle/FastDeploy/blob/develop/docs/cn/build_and_install/cpu.md">官方文档</a>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cmake .. -DENABLE_ORT_BACKEND=ON \</span><br><span class="line">         -DCMAKE_INSTALL_PREFIX=$&#123;PWD&#125;/compiled_fastdeploy_sdk \</span><br><span class="line">         -DENABLE_VISION=ON \</span><br><span class="line">         -DOPENCV_DIRECTORY=/usr/lib/aarch64-linux-gnu/cmake/opencv4 </span><br><span class="line">make -j1</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>根据编译出的sdk位置编译demo程序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cmake .. -DFASTDEPLOY_INSTALL_DIR=/home/user/FastDeploy/build/compiled_fastdeploy_sdk/</span><br><span class="line">make -j</span><br></pre></td></tr></table></figure><h1 id="踩坑点"><a href="#踩坑点" class="headerlink" title="踩坑点"></a>踩坑点</h1><p>官方提供的demo程序只支持以640结尾的模型，即只支持640输入，因为model类的默认size为640，若要改用320模型，需要在代码模型对象中进行修改：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">auto model = fastdeploy::vision::detection::YOLOv5Lite(model_file);</span><br><span class="line">model.size = &#123;320, 320&#125;; #添加这一行</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;使用python的fastdeploy库部署yolov5lite模型非常简单，只需要pip命令安装即可，但其运行速度慢，不适合在生产环境中使用，因此本文使用C++ fastdeploy库部署yolov5lite模型。&lt;/p&gt;
&lt;h1 id=&quot;运行官方demo&quot;&gt;&lt;a hre</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>源码编译ffmpeg</title>
    <link href="https://big7ng.github.io/2024/03/21/ffmpeg/"/>
    <id>https://big7ng.github.io/2024/03/21/ffmpeg/</id>
    <published>2024-03-21T05:54:46.313Z</published>
    <updated>2024-03-23T16:35:15.799Z</updated>
    
    <content type="html"><![CDATA[<p>使用ffmpeg把非原始格式的内容输入videoloopback设备时发生如下错误</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">V4L2 output device supports only a single raw video stream</span><br></pre></td></tr></table></figure><p>查看<a href="https://github.com/umlaeute/v4l2loopback/issues/130">github issue</a>发现原因为debian包管理器自带的ffmpeg版本太低，不支持把非原始格式的内容输入videoloopback设备，需要重新编译高版本ffmpeg，具体可以参考官方<a href="https://trac.ffmpeg.org/wiki/CompilationGuide/Ubuntu">ubuntu编译文档</a>。</p><h1 id="下载源码"><a href="#下载源码" class="headerlink" title="下载源码"></a>下载源码</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p ~/ffmpeg_sources ~/bin</span><br><span class="line">cd mkdir ~/ffmpeg_sources</span><br><span class="line">wget https://ffmpeg.org/releases/ffmpeg-5.1.4.tar.gz</span><br><span class="line">tar xzvf ffmpeg-5.1.4.tar.gz</span><br><span class="line">cd ffmpeg-5.1.4/</span><br></pre></td></tr></table></figure><h1 id="安装第三方库"><a href="#安装第三方库" class="headerlink" title="安装第三方库"></a>安装第三方库</h1><p>ffmpeg在编译时可以选择是否包含某些额外功能，这些额外功能需要安装特定的第三方库</p><h3 id="nasm"><a href="#nasm" class="headerlink" title="nasm"></a>nasm</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install nasm</span><br></pre></td></tr></table></figure><p>需要版本大于2.13，包管理器下载的版本为2.15</p><h3 id="libx264"><a href="#libx264" class="headerlink" title="libx264"></a>libx264</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libx264-dev</span><br></pre></td></tr></table></figure><p>需要版本大于118，包管理器下载的版本为160</p><p>在编译时需要开启 <code>--enable-gpl --enable-libx264</code>选项</p><h3 id="libvpx"><a href="#libvpx" class="headerlink" title="libvpx"></a>libvpx</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libvpx-dev</span><br></pre></td></tr></table></figure><p>需要版本大于1.4.0 ，包管理器下载的版本为1.9.0</p><p>在编译时需要开启<code>--enable-libvpx</code>选项</p><h3 id="libfdk-aac"><a href="#libfdk-aac" class="headerlink" title="libfdk-aac"></a>libfdk-aac</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libfdk-aac-dev</span><br></pre></td></tr></table></figure><p>无版本要求</p><p>编译时需开启 <code>--enable-libfdk-aac --enable-nonfree</code>选项</p><h3 id="libdav1d"><a href="#libdav1d" class="headerlink" title="libdav1d"></a>libdav1d</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libdav1d-dev</span><br></pre></td></tr></table></figure><p>无版本要求</p><p>编译时需开启<code>--enable-libdav1d</code>选项</p><h1 id="编译ffmpeg"><a href="#编译ffmpeg" class="headerlink" title="编译ffmpeg"></a>编译ffmpeg</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">./configure \</span><br><span class="line">  --prefix=&quot;$HOME/ffmpeg_build&quot; \</span><br><span class="line">  --extra-cflags=&quot;-I$HOME/ffmpeg_build/include&quot; \</span><br><span class="line">  --extra-ldflags=&quot;-L$HOME/ffmpeg_build/lib&quot; \</span><br><span class="line">  --extra-libs=&quot;-lpthread -lm&quot; \</span><br><span class="line">  --ld=&quot;g++&quot; \</span><br><span class="line">  --bindir=&quot;$HOME/bin&quot; \</span><br><span class="line">  --enable-gpl \</span><br><span class="line">  --enable-gnutls \</span><br><span class="line">  --enable-libass \</span><br><span class="line">  --enable-libfdk-aac \</span><br><span class="line">  --enable-libfreetype \</span><br><span class="line">  --enable-libmp3lame \</span><br><span class="line">  --enable-libdav1d \</span><br><span class="line">  --enable-libvorbis \</span><br><span class="line">  --enable-libvpx \</span><br><span class="line">  --enable-libx264 \</span><br><span class="line">  --enable-nonfree</span><br><span class="line">  </span><br><span class="line"> PATH=&quot;$HOME/bin:$PATH&quot; make -j4</span><br><span class="line"> make install</span><br><span class="line"> source ~/.profile</span><br></pre></td></tr></table></figure><p>此时可以直接在终端中输入ffmpeg、ffplay进行使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -version</span><br><span class="line">ffplay -version</span><br></pre></td></tr></table></figure><p>但是发现在终端上输入以上命令仍然是老版本，需要指定ffmpeg、ffplay执行文件才行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~/bin/ffmpeg -version</span><br><span class="line">~/bin/ffmpeg -version</span><br></pre></td></tr></table></figure><h1 id="卸载ffmpeg"><a href="#卸载ffmpeg" class="headerlink" title="卸载ffmpeg"></a>卸载ffmpeg</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf ~/ffmpeg_build ~/bin/&#123;ffmpeg,ffprobe,ffplay,x264,x265&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;使用ffmpeg把非原始格式的内容输入videoloopback设备时发生如下错误&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>使用v4l2loopback实现一个摄像头同时实现IP摄像头和OpenCV视频处理</title>
    <link href="https://big7ng.github.io/2024/03/18/v4l2/"/>
    <id>https://big7ng.github.io/2024/03/18/v4l2/</id>
    <published>2024-03-18T08:41:48.322Z</published>
    <updated>2024-03-23T16:34:41.914Z</updated>
    
    <content type="html"><![CDATA[<p>一个程序在读取摄像头时，如果另一个程序读取这个摄像头，会提示“设备繁忙”的错误，本文使用v4l2loopback将一个真实摄像头虚拟成两个，实现两个程序读取同一个摄像头拍摄的视频。</p><h1 id="v4l-utils"><a href="#v4l-utils" class="headerlink" title="v4l-utils"></a>v4l-utils</h1><p>v4l-utils使用来管理媒体设备的一系列工具，首先安装v4l-utils工具</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install v4l-utils</span><br></pre></td></tr></table></figure><p>将媒体设备与开发板连接（USB摄像头），若连接成功，在<code>/dev/</code>目录下会出现video设备</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> /dev/video*</span><br></pre></td></tr></table></figure><p>使用v4l-utils中的v4l-ctl命令工具查看设备信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">v4l2-ctl --list-devices <span class="comment">#查看连接的v4l2设备</span></span><br><span class="line">v4l2-ctl --list-formats  <span class="comment">#查看设备支持的拍摄格式</span></span><br><span class="line">v4l2-ctl -d  /dev/video0 --all <span class="comment">#查看设备的详细信息</span></span><br></pre></td></tr></table></figure><p>需要注意的是，如果摄像头不支持h264格式录制（例如本博客使用的摄像头支持MJPG与YUYV），那传输视频流的时候只能使用rtsp或rtmp。http+flv、hls等格式无法使用，因为他们只支持h264格式的视频流。</p><h1 id="v4l2rtspserver"><a href="#v4l2rtspserver" class="headerlink" title="v4l2rtspserver"></a>v4l2rtspserver</h1><h4 id="RTSP协议"><a href="#RTSP协议" class="headerlink" title="RTSP协议"></a>RTSP协议</h4><p>Real-Time Messaging Protocol（RTMP）和The Real-Time Streaming Protocol (RTSP)是目前使用较广泛的流媒体协议之一。</p><p>RTSP传输一般需要2-3个通道，命令和数据通道分离，HTTP和RTMP一般在TCP一个通道上传输命令和数据。RTSP 本身不传输数据流，而是配合 RTP&#x2F;RTCP 一起使用，RTSP 负责控制传输。</p><p>由于 Flash 的普及度降低，chrome与firefox均停止了对Flash的支持，RTMP 的使用也在逐渐减少，被如 HLS（HTTP Live Streaming）和 DASH（Dynamic Adaptive Streaming over HTTP）等其他流媒体传输协议替代。</p><h4 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h4><p><a href="https://github.com/mpromonet/v4l2rtspserver">v4l2rtspserver</a>是一个v4l2设备的rtsp服务器，首先下载v4l2rtpserver源码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone --recursive https://github.com/mpromonet/v4l2rtspserver.git </span><br></pre></td></tr></table></figure><p>v4l2rtspsever的依赖库如下：</p><ul><li>liblivemedia-dev：会在编译的时候自动下载</li><li>libv4l2cpp：已作为子模块包含在源码中</li><li>liblog4cpp5-dev ：可选项，增强日志功能</li><li>libasound2-dev ：可选项，增加音频传输功能</li></ul><p>开始编译</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd v4l2rtspserver</span><br><span class="line">cmake . &amp;&amp; make</span><br></pre></td></tr></table></figure><p>编译完成后，开始运行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./videortspserver -v -W 640 -H 480 /dev/video0</span><br></pre></td></tr></table></figure><p>运行该命令后会输出直播url，可以输入至VLC播放器或者IP摄像头app进行远程查看。</p><p>.&#x2F;ffmpeg -f v4l2 -input_format mjpeg -i &#x2F;dev&#x2F;video0 -c:v mjpeg -f v4l2 &#x2F;dev&#x2F;video2</p><h1 id="v4l2loopback"><a href="#v4l2loopback" class="headerlink" title="v4l2loopback"></a>v4l2loopback</h1><p>v4l2loopback可以创建多个虚拟的媒体设备，我们可以把虚拟设备当作摄像头来使用，下载v4l2源码并进行编译</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/umlaeute/v4l2loopback.git</span><br><span class="line">cd v4l2loopback</span><br><span class="line">make</span><br></pre></td></tr></table></figure><p>以下命令可以不执行，不影响使用，执行的话可以使用<code>modprobe</code>命令更方便地实现内核模块安装，但是本文在这一步出现了问题，因此放弃了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo make install </span><br></pre></td></tr></table></figure><p>在v4l2loopback目录中执行以下命令，安装v4l2loopback内核模块，一下命令将</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo insmod v4l2loopback.ko devices=2 exclusive_caps=1,1 video_nr=2,3 card_label=<span class="string">&quot;IP Camera&quot;</span>,<span class="string">&quot;OpenCV Camera&quot;</span></span><br></pre></td></tr></table></figure><p>也可以使用v4l2loopback-ctl来动态管理虚拟设备，但是还没有测试过</p><h1 id="Mplayer"><a href="#Mplayer" class="headerlink" title="Mplayer"></a>Mplayer</h1><p>可以使用mplayer来测试虚拟设备，使用包管理器自带的mplayer会报错</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mplayer: symbol lookup error: mplayer: undefined symbol: av_alloc_vdpaucontext, version LIBAVCODEC_58</span><br></pre></td></tr></table></figure><p>重新编译mplayer可以解决这个问题</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sudo apt remove mplayer</span><br><span class="line">wget https://mplayerhq.hu/MPlayer/releases/MPlayer-1.5.tar.gz</span><br><span class="line">tar -xzvf MPlayer-1.5.tar.gz</span><br><span class="line"><span class="built_in">cd</span> MPlayer-1.5/</span><br><span class="line">./configure </span><br><span class="line">make -j6</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><p>开始播放</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mplayer tv:// -tv driver=v4l2:device=/dev/video0</span><br></pre></td></tr></table></figure><h1 id="ffmpeg"><a href="#ffmpeg" class="headerlink" title="ffmpeg"></a>ffmpeg</h1><p>使用ffmpeg把视频流&#x2F;真实摄像头输入虚拟设备中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -f v4l2 -i /dev/video0 -f v4l2 /dev/video2</span><br><span class="line">ffplay /dev/video2</span><br></pre></td></tr></table></figure><p>使用ffmpeg将摄像头的内容复制到<code>/dev/video2</code>与<code>/dev/video3</code>两个虚拟设备中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./ffmpeg -f v4l2 -input_format mjpeg -i /dev/video0 -c:v copy -f v4l2 /dev/video2 -c:v copy -f v4l2 /dev/video3</span><br></pre></td></tr></table></figure><p>此时就可以使用v4l2rtspserver读取<code>/dev/video2</code>中的内容，使用opencv读取<code>/dev/video3</code>中的内容了</p><h1 id="v4l2tools"><a href="#v4l2tools" class="headerlink" title="v4l2tools"></a>v4l2tools</h1><p>v4l2tools是一个可以压缩、复制v4l2设备的工具，本文中使用ffmpeg代替了这个工具</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install libtool autoconf</span><br><span class="line">git clone --recursive https://github.com/mpromonet/v4l2tools</span><br><span class="line">make </span><br><span class="line">make install</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;一个程序在读取摄像头时，如果另一个程序读取这个摄像头，会提示“设备繁忙”的错误，本文使用v4l2loopback将一个真实摄像头虚拟成两个，实现两个程序读取同一个摄像头拍摄的视频。&lt;/p&gt;
&lt;h1 id=&quot;v4l-utils&quot;&gt;&lt;a href=&quot;#v4l-utils&quot; cl</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>编译并使用Qemu运行一个基于busybox的最小操作系统</title>
    <link href="https://big7ng.github.io/2024/02/19/busybox_kernel/"/>
    <id>https://big7ng.github.io/2024/02/19/busybox_kernel/</id>
    <published>2024-02-19T07:23:59.743Z</published>
    <updated>2024-02-19T20:00:19.042Z</updated>
    
    <content type="html"><![CDATA[<p>编译环境为ubuntu 18.04</p><h1 id="编译kernel"><a href="#编译kernel" class="headerlink" title="编译kernel"></a>编译kernel</h1><p>安装编译工具</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install bc binutils bison dwarves flex gcc git gnupg2 gzip libelf-dev libncurses5-dev libssl-dev make openssl pahole perl-base rsync tar xz-utils</span><br></pre></td></tr></table></figure><p>下载并编译内核代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">wget https://cdn.kernel.org/pub/linux/kernel/v4.x/linux-4.9.229.tar.xz</span><br><span class="line">tar xvf linux-4.9.229.tar.xz</span><br><span class="line"><span class="built_in">cd</span> linux-4.9.229/</span><br><span class="line"><span class="built_in">export</span> ARCH=x86</span><br><span class="line">make x86_64_defconfig</span><br><span class="line">make menuconfig</span><br><span class="line">make</span><br></pre></td></tr></table></figure><p>令编译的内核支持ramdisk驱动</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">General setup  ---&gt;</span><br><span class="line"></span><br><span class="line">       [*] Initial RAM filesystem and RAM disk (initramfs/initrd) support</span><br><span class="line"></span><br><span class="line">Device Drivers  ---&gt;</span><br><span class="line"></span><br><span class="line">       [*] Block devices  ---&gt;</span><br><span class="line"></span><br><span class="line">               &lt;*&gt;   RAM block device support</span><br><span class="line"></span><br><span class="line">               (65536) Default RAM disk size (kbytes)</span><br></pre></td></tr></table></figure><h1 id="Busybox"><a href="#Busybox" class="headerlink" title="Busybox"></a>Busybox</h1><p>编译Busybox</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tar xvf busybox-1.30.0.tar.bz2</span><br><span class="line"><span class="built_in">cd</span> busybox-1.30.0/</span><br><span class="line">make menuconfig</span><br><span class="line">make</span><br></pre></td></tr></table></figure><p>把busybox配置为静态编译，这样busybox在运行的时候就不需要额外的动态链接库了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Busybox Settings  ---&gt;</span><br><span class="line">      Build Options  ---&gt;</span><br><span class="line">            [*] Build BusyBox as a static binary (no shared libs)</span><br></pre></td></tr></table></figure><p>配置根文件系统</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> _install/</span><br><span class="line"><span class="built_in">mkdir</span> etc dev mnt</span><br><span class="line"><span class="built_in">mkdir</span> -p proc sys tmp mnt</span><br><span class="line"><span class="built_in">mkdir</span> -p etc/init.d</span><br><span class="line">vim etc/fstab</span><br><span class="line">vim etc/init.d/rcS</span><br><span class="line"><span class="built_in">chmod</span> 755 etc/init.d/rcS</span><br><span class="line">vim etc/inittab</span><br><span class="line"><span class="built_in">chmod</span> 755 etc/inittab</span><br><span class="line"><span class="built_in">cd</span> dev/</span><br><span class="line">sudo su</span><br><span class="line"><span class="built_in">mknod</span> console c 5 1<span class="comment">#mknod [选项] [名称] [类型] [主设备号] [次设备号]</span></span><br><span class="line"><span class="built_in">mknod</span> null c 1 3</span><br><span class="line"><span class="built_in">mknod</span> tty1 c 4 1</span><br></pre></td></tr></table></figure><p>其中, fstab文件:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">proc        /proc           proc         defaults        0        0</span><br><span class="line">tmpfs       /tmp            tmpfs    　　defaults        0        0</span><br><span class="line">sysfs       /sys            sysfs        defaults        0        0 </span><br></pre></td></tr></table></figure><p>rcS文件:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;Welcome to tinyLinux&quot;</span></span><br><span class="line">/bin/mount -a<span class="comment">#挂载 /etc/fstab 文件中定义的所有文件系统。-a 参数表示挂载所有在 /etc/fstab 文件中列出的文件系统。</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;Remounting the root filesystem&quot;</span></span><br><span class="line">mount  -o  remount,rw  /<span class="comment">#以读写模式重新挂载根文件系统（通常是 /），使其可写入。-o remount,rw 参数表示重新挂载为读写模式。</span></span><br><span class="line"><span class="built_in">mkdir</span> -p /dev/pts<span class="comment">#挂载伪终端文件系统 (devpts) 到 /dev/pts 目录。-t devpts 参数指定文件系统类型为 devpts。</span></span><br><span class="line">mount -t devpts devpts /dev/pts</span><br><span class="line"><span class="built_in">echo</span> /sbin/mdev &gt; /proc/sys/kernel/hotplug<span class="comment">#把/sbin/mdev写到/proc/sys/kernel/hotplug文件里,当有热插拔事件产生时，内核会调用/proc/sys/kernel/hotplug文件里指定的应用程序来处理热插拔事件</span></span><br><span class="line">mdev -s<span class="comment">#启动 mdev 守护进程，它用于在 Linux 系统中自动创建和管理设备节点。-s 参数表示以守护进程模式运行。</span></span><br></pre></td></tr></table></figure><p>mdev是busybox提供的一个工具，相当于简化版的udev。通过描述sysfs下的dev节点，在系统启动和热插拔或动态加载驱动程序时，自动创建设备节点。文件系统中的&#x2F;dev目录下的设备节点都是由mdev创建的。</p><p><a href="https://git.busybox.net/busybox/tree/examples/inittab">inittab</a>文件:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># Format for each entry: &lt;id&gt;:&lt;runlevels&gt;:&lt;action&gt;:&lt;process&gt;</span><br><span class="line"># &lt;id&gt;: WARNING: This field has a non-traditional meaning for BusyBox init!</span><br><span class="line"># &lt;runlevels&gt;: The runlevels field is completely ignored.</span><br><span class="line"># &lt;action&gt;: Valid actions include: sysinit, wait, once, respawn, askfirst, shutdown, restart and ctrlaltdel.</span><br><span class="line"># &lt;process&gt;: Specifies the process to be executed and it&#x27;s command line.</span><br><span class="line"></span><br><span class="line"># Note below that we prefix the shell commands with a &quot;-&quot; to indicate to the</span><br><span class="line"># shell that it is supposed to be a login shell.  Normally this is handled by</span><br><span class="line"># login, but since we are bypassing login in this case, BusyBox lets you do</span><br><span class="line"># this yourself...</span><br><span class="line"></span><br><span class="line">::sysinit:/etc/init.d/rcS</span><br><span class="line">::respawn:-/bin/sh</span><br><span class="line">::askfirst:-/bin/sh</span><br><span class="line">::ctrlaltdel:/bin/umount -a -r</span><br></pre></td></tr></table></figure><p>烧录镜像文件</p><p>将如下内容拷贝至<code>make_rootfs.sh</code>文件中:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">rm</span> -rf rootfs.ext3</span><br><span class="line"><span class="built_in">rm</span> -rf fs</span><br><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/zero of=./rootfs.ext3 bs=1M count=32</span><br><span class="line">mkfs.ext3 rootfs.ext3</span><br><span class="line"><span class="built_in">mkdir</span> fs</span><br><span class="line">mount -o loop rootfs.ext3 ./fs</span><br><span class="line"><span class="built_in">cp</span> -rf ./_install/* ./fs</span><br><span class="line">umount ./fs</span><br><span class="line">gzip --best -c rootfs.ext3 &gt; rootfs.img.gz</span><br></pre></td></tr></table></figure><p>运行脚本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh make_rootfs.sh</span><br></pre></td></tr></table></figure><h1 id="运行系统"><a href="#运行系统" class="headerlink" title="运行系统"></a>运行系统</h1><p>安装qemu</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install qemu</span><br></pre></td></tr></table></figure><p>启动qemu</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-x86_64   -kernel ./linux-4.9.229/arch/x86_64/boot/bzImage    -initrd ./busybox-1.30.0/rootfs.img.gz     -append <span class="string">&quot;root=/dev/ram init=/linuxrc&quot;</span>    -serial file:output.txt  -curses</span><br></pre></td></tr></table></figure><ul><li><code>-curses</code>: Normally, QEMU uses SDL to display the VGA output. With this option, QEMU can display the VGA output when in text mode using a curses&#x2F;ncurses interface. Nothing is displayed in graphical mode.<code>-curses</code> works over ssh.</li><li><code>-serial</code>:用于配置虚拟机的串行端口。该选项可以用于将虚拟机与主机之间建立串行通信连接，以便在虚拟机中模拟串行设备的输入和输出。使用 <code>-serial file:filename</code> 将串行输出保存到文件中进行分析。以下是一些常用的 <code>-serial</code> 选项参数：<ul><li><code>stdio</code>：将虚拟机的串行输入输出重定向到主机的标准输入输出（通常是终端窗口）。</li><li><code>file:filename</code>：将虚拟机的串行输出重定向到指定的文件中。</li><li><code>tcp:host:port</code>：通过 TCP&#x2F;IP 连接将虚拟机的串行输入输出重定向到指定的主机和端口。</li><li><code>udp:host:port</code>：通过 UDP 连接将虚拟机的串行输入输出重定向到指定的主机和端口。</li></ul></li><li><code>-append</code>:用于指定要传递给内核的命令行参数。当使用 -kernel 选项加载一个内核映像时，通常需要将一些参数传递给内核，以配置虚拟机的启动行为。这些参数可以通过 -append 选项来指定。</li></ul><p>在生成的终端中关闭系统, 即可退出qemu</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">poweroff</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;编译环境为ubuntu 18.04&lt;/p&gt;
&lt;h1 id=&quot;编译kernel&quot;&gt;&lt;a href=&quot;#编译kernel&quot; class=&quot;headerlink&quot; title=&quot;编译kernel&quot;&gt;&lt;/a&gt;编译kernel&lt;/h1&gt;&lt;p&gt;安装编译工具&lt;/p&gt;
&lt;figure cl</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>rk3568开发板使用Docker安装Openwrt实现旁路由</title>
    <link href="https://big7ng.github.io/2024/01/23/docker_bypass/"/>
    <id>https://big7ng.github.io/2024/01/23/docker_bypass/</id>
    <published>2024-01-23T11:39:00.182Z</published>
    <updated>2024-01-23T17:37:19.361Z</updated>
    
    <content type="html"><![CDATA[<p>开发板为Lubancat2n<br>系统为ubuntu20.04<br>主路由器网段为192.168.124.0&#x2F;24,  网关为192.168.124.1</p><img src="\img\network_tp.png" style="zoom:25%;" /><h1 id="安装与配置Docker"><a href="#安装与配置Docker" class="headerlink" title="安装与配置Docker"></a>安装与配置Docker</h1><p>根据<a href="https://docs.docker.com/engine/install/ubuntu/">官网的步骤</a>, 安装Docker。<br>安装portainer容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume create portainer_data</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 8000:8000 -p 9443:9443 --name portainer --restart=always -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer-ce:latest</span><br></pre></td></tr></table></figure><p>安装piaoyizy提供的<a href="https://hub.docker.com/r/piaoyizy/openwrt-aarch64">openwrt镜像</a>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull piaoyizy/openwrt-aarch64:latest</span><br></pre></td></tr></table></figure><p>将选用的网卡打开混杂模式, 需要将下述命令中的<code>eth3</code>修改为实际使用的网卡:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ip link set eth3 promisc on</span><br></pre></td></tr></table></figure><ul><li><p>可以使用<code>ip a</code>或<code>ifconfig</code>查看本机的网卡.</p></li><li><p>混杂模式（promiscuous mode）是计算机网络中的术语。是指一台机器的网卡能够接收所有经过它的数据流，而不论其目的地址是否是它。</p><p><em>一般计算机网卡都工作在非混杂模式下，此时网卡只接受来自网络端口的目的地址指向自己的数据。当网卡工作在混杂模式下时，网卡将来自接口的所有数据都捕获并交给相应的驱动程序。网卡的混杂模式一般在网络管理员分析网络数据作为网络故障诊断手段时用到，同时这个模式也被网络黑客利用来作为网络数据窃听的入口。</em></p></li></ul><p>创建docker network, 这里需要将网段与网关修改以符合主路由的设置, 将<code>parent</code>设置为使用的物理网卡:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network create -d macvlan --subnet=192.168.124.0/24 --gateway=192.168.124.1 -o parent=eth3 macnet</span><br></pre></td></tr></table></figure><ul><li>macvlan为Docker network<a href="https://docs.docker.com/network/drivers/">提供的驱动</a>中的一种。 macvlan是linux中网络虚拟化的一种技术，这种技术能将 <strong>一块物理网卡虚拟成多块虚拟网卡</strong> ，相当于物理网卡施展了多重影分身之术 ，由一个变多个。 深入macvlan可以参考如下文章：<a href="https://mp.weixin.qq.com/s?__biz=MzI1OTY2MzMxOQ==&mid=2247485246&idx=1&sn=c42a3618c357ebf5f6b7b7ce78ae568f&chksm=ea743386dd03ba90ad65940321385f68f9315fec16d82a08efa12c18501d8cadf95cf9e614a2&scene=21#wechat_redirect">Macvlan</a>，<a href="https://www.cnblogs.com/bakari/p/10893589.html">Docker 网络模型之 macvlan 详解</a>，<a href="https://docs.docker.com/network/drivers/macvlan/">Docker Macvlan文档</a>。</li></ul><p>运行容器:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name=OpenWrt --restart always --privileged --network macnet --ip 192.168.124.20 piaoyizy/openwrt-aarch64:latest</span><br></pre></td></tr></table></figure><p>此时在浏览器中输入旁路由地址还不能访问openwrt页面,  因为容器中默认使用的静态分配IP地址与我们使用的不同，需要进入bash设置，在portainer控制台中进入openwrt容器的命令行界面.</p><img src="\img\portainer.png" style="zoom:67%;" /><p>修改配置文件:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/config/network</span><br></pre></td></tr></table></figure><p>替换lan网络配置如下(根据自己的网络情况填写):</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">config interface &#x27;lan&#x27;</span><br><span class="line">        option type &#x27;bridge&#x27;</span><br><span class="line">        option ifname &#x27;eth0&#x27;</span><br><span class="line">        option proto &#x27;static&#x27;</span><br><span class="line">        option ipaddr &#x27;192.168.124.20&#x27;</span><br><span class="line">        option netmask &#x27;255.255.255.0&#x27;</span><br><span class="line">        option gateway &#x27;192.168.124.1&#x27;</span><br><span class="line">        option dns &#x27;192.168.124.1&#x27;</span><br></pre></td></tr></table></figure><p>重启网络:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/network restart</span><br></pre></td></tr></table></figure><p>此时在浏览器中输入目标地址,即可访问openwrt页面,  默认账号 root 密码 password。</p><p>登录openwrt界面后, 在openwrt的网络配置中，点击接口选项，修改名为LAN的接口。</p><p>在<code>物理配置</code>中，取消勾选<code>桥接接口</code>；在<code>最下方的基本配置</code>中，关闭DHCP，勾选忽略此接口；<code>最下方的IPV6设置</code>中，<code>路由通告服务</code>、<code>DHCPv6 服务</code>和<code>NDP 代理</code>全部选择<code>已禁用</code>;<code>入站数据</code>、<code>出站数据</code>和<code>转发</code>全部选择接受；</p><h1 id="配置OpenClash"><a href="#配置OpenClash" class="headerlink" title="配置OpenClash"></a>配置OpenClash</h1><p>piaoyizy提供的openwrt镜像中包含了passwall, openClash等插件，我们可以很方便的进行使用。</p><p>在使用openClash时，出现了如下问题：<br>    开启服务后，Clash占用CPU、内存过大，Openwrt内显示的下载与上传速度非常高。后发现日志系统设置为Info模式，Clash内核会把所有的代理信息发送到网页控制台（9090端口），而这个代理信息的发送到端口9090的过程也会被当作Info再次发送到端口9090，导致无穷无尽地发送，使内核占用资源非常多。将日志信息模式修改为Warning模式即可。</p><h1 id="配置客户端"><a href="#配置客户端" class="headerlink" title="配置客户端"></a>配置客户端</h1><p>在完成上述配置后，在操作系统网络设置中关闭客户端的DHCP自动分配，选择静态分配IP，将客户端的网关、DNS服务器指向在Docker中新搭建的openwrt。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;开发板为Lubancat2n&lt;br&gt;系统为ubuntu20.04&lt;br&gt;主路由器网段为192.168.124.0&amp;#x2F;24,  网关为192.168.124.1&lt;/p&gt;
&lt;img src=&quot;&#92;img&#92;network_tp.png&quot; style=&quot;zoom:25%;&quot; </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Debian系统中实现局域网共享文件夹（samba）</title>
    <link href="https://big7ng.github.io/2023/11/05/samba/"/>
    <id>https://big7ng.github.io/2023/11/05/samba/</id>
    <published>2023-11-05T14:26:01.522Z</published>
    <updated>2023-11-05T14:54:08.468Z</updated>
    
    <content type="html"><![CDATA[<p>本文将在Debian12 bookworm系统中，通过samba服务实现网络共享文件夹，并实现外置硬盘的自动挂载。</p><h1 id="Samba"><a href="#Samba" class="headerlink" title="Samba"></a>Samba</h1><h4 id="安装samba"><a href="#安装samba" class="headerlink" title="安装samba"></a>安装samba</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install samba</span><br></pre></td></tr></table></figure><p>查看samba安装状态</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl status smbd</span><br></pre></td></tr></table></figure><p>smbd处于running状态,则安装成功</p><h4 id="配置samba"><a href="#配置samba" class="headerlink" title="配置samba"></a>配置samba</h4><p>进入samba配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/samba/smb.conf</span><br></pre></td></tr></table></figure><p>在文件末尾添加如下内容,<code>path</code>为需要共享的文件夹</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[sambashare]</span><br><span class="line">    comment = Samba on debian</span><br><span class="line">    path = /mnt/study</span><br><span class="line">    read only = no</span><br><span class="line">    browsable = yes</span><br><span class="line">    guest ok = yes</span><br></pre></td></tr></table></figure><p>配置samba登录用户名与密码,用户名需与系统用户名相同</p><p>如果在配置文件中声明<code>guest ok = yes</code>,则这一步可以跳过</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo smbpasswd -a username</span><br></pre></td></tr></table></figure><p>重启samba服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl restart smbd.service</span><br></pre></td></tr></table></figure><h1 id="自动挂载"><a href="#自动挂载" class="headerlink" title="自动挂载"></a>自动挂载</h1><p>将外置硬盘插入主机中,我们可以使用<code>mount</code>命令来挂载,如果系统重启,我们需要重新mount,接下来将配置自动挂载.</p><p>首先将硬盘插入主机,使用<code>sudo fdisk -l</code>查看块设备.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Disk /dev/sda: 931.51 GiB, 1000204886016 bytes, 1953525168 sectors</span><br><span class="line">Disk model: RTL9210 NVME</span><br><span class="line">Units: sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 33553920 bytes</span><br><span class="line">Disklabel type: gpt</span><br><span class="line">Disk identifier: 64950C9B-606E-4BBA-93D1-C032DA79C574</span><br><span class="line"></span><br><span class="line">Device     Start        End    Sectors   Size Type</span><br><span class="line">/dev/sda1     34      32767      32734    16M Microsoft reserved</span><br><span class="line">/dev/sda2  32768 1953523711 1953490944 931.5G Microsoft basic data</span><br></pre></td></tr></table></figure><p>使用mount命令挂载</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mount /dev/sda2 /mnt/study</span><br></pre></td></tr></table></figure><p>挂载后,使用<code>lsblk -f</code>查看设备信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">user@starfive:~$ lsblk -f</span><br><span class="line">NAME        FSTYPE FSVER LABEL UUID                                 FSAVAIL FSUSE% MOUNTPOINTS</span><br><span class="line">sda</span><br><span class="line">|-sda1</span><br><span class="line">`-sda2      ntfs               2921CF502C42771A                        726G    22% /mnt/study</span><br><span class="line">mtdblock0</span><br><span class="line">mtdblock1</span><br><span class="line">mtdblock2</span><br><span class="line">mmcblk1</span><br><span class="line">|-mmcblk1p1</span><br><span class="line">|-mmcblk1p2</span><br><span class="line">|-mmcblk1p3 vfat   FAT16       DC47-E0F8</span><br><span class="line">`-mmcblk1p4 ext4   1.0   root  93d1b271-9260-4414-99ba-55edab9106e7  109.1G     8% /</span><br><span class="line">nvme0n1     ext4   1.0         9decbacf-f688-4442-a107-140863a2c42f</span><br></pre></td></tr></table></figure><p>记下需要自动挂载的设备的UUID与FSTYPE,修改<code>/etc/fstab</code>文件,添加以下内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UUID=2921CF502C42771A   /mnt/study      ntfs    default 0       0</span><br></pre></td></tr></table></figure><p>保存后,下次重新启动即可实现自动挂载.</p><p>自此,samba服务就算是配置完成了,在windows系统的文件资源管理器中输入地址<code>\\&#123;配置samba服务的主机网络地址&#125;</code>即可访问共享文件夹.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文将在Debian12 bookworm系统中，通过samba服务实现网络共享文件夹，并实现外置硬盘的自动挂载。&lt;/p&gt;
&lt;h1 id=&quot;Samba&quot;&gt;&lt;a href=&quot;#Samba&quot; class=&quot;headerlink&quot; title=&quot;Samba&quot;&gt;&lt;/a&gt;Samba&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>使用Visionfive2开发板搭建clash旁路由</title>
    <link href="https://big7ng.github.io/2023/09/24/visionfive2/"/>
    <id>https://big7ng.github.io/2023/09/24/visionfive2/</id>
    <published>2023-09-24T14:07:22.654Z</published>
    <updated>2023-12-17T16:02:52.422Z</updated>
    
    <content type="html"><![CDATA[<p>作者使用的是riscv架构的Visionfive2开发板，本博客内的步骤也适用于其他开发板。交叉编译环境为ubuntu20.04。</p><h2 id="编译内核"><a href="#编译内核" class="headerlink" title="编译内核"></a>编译内核</h2><p>由于visionfive2开发板官方提供的debian镜像中的kernel未开启netfilter模块，因此我们需要重新编译内核以开启该功能，如果开启了该功能，可跳过这部分。</p><ol><li><p>安装所需工具</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install -y build-essential gcc-riscv64-linux-gnu libncurses-dev git </span><br><span class="line">sudo apt install -y flex bc bison </span><br></pre></td></tr></table></figure></li><li><p>下载源码</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/starfive-tech/linux.git</span><br><span class="line"><span class="comment"># 执行以下命令，切换到代码分支：</span></span><br><span class="line"><span class="built_in">cd</span> linux</span><br><span class="line">git checkout origin/JH7110_VisionFive2_devel</span><br><span class="line">git pull</span><br></pre></td></tr></table></figure></li><li><p>设置编译Linux内核的默认设置</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make starfive_visionfive2_defconfig CROSS_COMPILE=riscv64-linux-gnu- ARCH=riscv</span><br></pre></td></tr></table></figure><p> 修改编译Linux内核的设置，我们先使用默认的设置进行编译，编译完成后再进行修改，因此可以直接退出</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make CROSS_COMPILE=riscv64-linux-gnu- ARCH=riscv -j4 bindeb-pkg LOCALVERSION=-<span class="built_in">test</span></span><br></pre></td></tr></table></figure></li><li><p>编译内核</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make CROSS_COMPILE=riscv64-linux-gnu- ARCH=riscv -jX</span><br></pre></td></tr></table></figure></li><li><p>编译完成后，再次打开Linux内核配置页面，依次进入<code>Networking  support</code> -&gt; <code>Network option</code> -&gt;<code>Network packet filtering framework(Netfilter)</code>-&gt;<code>Core Netfilter Configuration</code>，增加内核对netfilter的redirect、nat、reject功能的支持。再次进行编译。</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make CROSS_COMPILE=riscv64-linux-gnu- ARCH=riscv menuconfig</span><br><span class="line">make CROSS_COMPILE=riscv64-linux-gnu- ARCH=riscv -j4 bindeb-pkg LOCALVERSION=-netfilter</span><br></pre></td></tr></table></figure></li></ol><p>编译完成后<code>..</code>目录会出现三个安装包, 分别为<code>linux-image-*.deb</code>、<code>linux-libc-dev_*.deb</code>与<code>linux-headers-*.deb</code>, 这里我们只需要使用image内核安装包。</p><h2 id="安装内核"><a href="#安装内核" class="headerlink" title="安装内核"></a>安装内核</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dpkg -i linux-image-5.15.0-netfilter_5.15.0-netfilter-1_riscv64.deb <span class="comment">#安装内核</span></span><br><span class="line">dpkg --get-selections | grep linux-image <span class="comment">#查看已安装的内核信息</span></span><br></pre></td></tr></table></figure><p>修改<code>extlinux.conf</code>文件,将默认启动项修改为我们刚刚编译的kernel</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /boot/extlinux/extlinux.conf</span><br></pre></td></tr></table></figure><p>重启系统，查看内核信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">uname</span> -srm</span><br></pre></td></tr></table></figure><h2 id="内核安装失败的问题"><a href="#内核安装失败的问题" class="headerlink" title="内核安装失败的问题"></a>内核安装失败的问题</h2><p>博主在重启失败时出现了内核启动失败的问题，具体问题如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[FAILED] Failed to mount Huge Pages File System.</span><br><span class="line">[FAILED] Failed to mount POSIX Message Queue File System.</span><br><span class="line">[FAILED] Failed to mount Kernel Debug File System.</span><br><span class="line">[FAILED] Failed to mount FUSE Control File System.</span><br><span class="line">[FAILED] Failed to mount Kernel Configuration File System.</span><br></pre></td></tr></table></figure><p>经过了很长时间的筛查，发现是gcc编译器的问题：一开始博主通过目标机编译kernel，而不是交叉编译，而开发板中自带的gcc版本较低，导致编译出来的kernel无法被加载。更换为ubuntu20.04进行交叉编译后，解决了这个问题。</p><h2 id="安装clash"><a href="#安装clash" class="headerlink" title="安装clash"></a>安装clash</h2><p>在开发板上下载clash-core，并解压</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gzip -d clash-linux-riscv64-v1.18.0.gz</span><br><span class="line">install clash-linux-riscv64-v1.18.0 /usr/local/bin/clash</span><br></pre></td></tr></table></figure><p>创建clash的systemd文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/systemd/system/clash.service</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Clash daemon, A rule-based proxy in Go.</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=simple</span><br><span class="line">Restart=always</span><br><span class="line">ExecStart=/usr/local/bin/clash -d /etc/clash</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><p>设置clash为开机启动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> clash --now</span><br><span class="line">systemctl status clash</span><br></pre></td></tr></table></figure><p>配置clash管理页面</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone -b gh-pages --depth 1 https://github.com/haishanh/yacd.git /opt/clash-dashboard</span><br></pre></td></tr></table></figure><h2 id="开启-Linux-内核的转发功能"><a href="#开启-Linux-内核的转发功能" class="headerlink" title="开启 Linux 内核的转发功能"></a>开启 Linux 内核的转发功能</h2><ol><li><p>编辑配置文件 <code>/etc/sysctl.conf</code> 并向其中添加如下内容</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.ip_forward=1</span><br></pre></td></tr></table></figure></li><li><p>保存退出后，执行以下命令使修改生效</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysctl -p</span><br></pre></td></tr></table></figure></li><li><p>查看 <code>/proc/sys/net/ipv4/ip_forward</code> 的内容，如果是 <code>1</code> 表示设置成功生效</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/sys/net/ipv4/ip_forward</span><br></pre></td></tr></table></figure></li></ol><h2 id="配置nftables"><a href="#配置nftables" class="headerlink" title="配置nftables"></a>配置nftables</h2><p>安装nftables</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt -y install nftables</span><br></pre></td></tr></table></figure><p>创建 nftables 配置文件扩展目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir /etc/nftables.conf.d</span><br></pre></td></tr></table></figure><p>创建私有地址的定义文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">define private_list = &#123;</span><br><span class="line">    0.0.0.0/8,</span><br><span class="line">    10.0.0.0/8,</span><br><span class="line">    127.0.0.0/8,</span><br><span class="line">    169.254.0.0/16,</span><br><span class="line">    172.16.0.0/12,</span><br><span class="line">    192.168.0.0/16,</span><br><span class="line">    224.0.0.0/4,</span><br><span class="line">    240.0.0.0/4</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改 nftalbes 配置文件，内容如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/sbin/nft -f</span><br><span class="line"></span><br><span class="line">include &quot;/etc/nftables.conf.d/private.nft&quot;</span><br><span class="line"></span><br><span class="line">table ip nat &#123;</span><br><span class="line">    chain proxy &#123;</span><br><span class="line">        ip daddr $private_list return</span><br><span class="line">            ip protocol tcp redirect to :7892</span><br><span class="line">    &#125;</span><br><span class="line">    chain prerouting &#123;</span><br><span class="line">        type nat hook prerouting priority 0; policy accept;</span><br><span class="line">        jump proxy</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>清空 nftalbes 规则，并使新规则生效, 查看 nftalbes 当前规则</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nft -f /etc/nftables.conf</span><br><span class="line">nft flush ruleset</span><br><span class="line">nft list ruleset</span><br></pre></td></tr></table></figure><p>设置 <code>nftalbes</code> 开机自启动</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable nftables --now</span><br></pre></td></tr></table></figure><h2 id="配置机场订阅"><a href="#配置机场订阅" class="headerlink" title="配置机场订阅"></a>配置机场订阅</h2><p>将机场订阅文件下载至<code>/etc/clash</code>文件夹内, 并添加如下内容。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">external-controller: &#x27;0.0.0.0:9090&#x27;</span><br><span class="line">secret: &#x27;&#x27;</span><br><span class="line">external-ui: /opt/clash-dashboard #web控制台文件地址</span><br></pre></td></tr></table></figure><p>重启clash</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart clash</span><br><span class="line">systemctl status clash</span><br></pre></td></tr></table></figure><p>通过<code>http://server-ip:9090/ui</code>网页访问clash控制台。</p><ul><li><p>测试代理</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> http_proxy=<span class="string">&quot;http://127.0.0.1:7890&quot;</span></span><br><span class="line"><span class="built_in">export</span> https_proxy=<span class="string">&quot;http://127.0.0.1:7890&quot;</span></span><br><span class="line"><span class="built_in">export</span> -p <span class="comment">#查看环境变量</span></span><br><span class="line">curl google.com</span><br></pre></td></tr></table></figure></li><li><p>查看clash日志</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">journalctl -u clash.service</span><br></pre></td></tr></table></figure></li></ul><p>使用了代理后使用apt install出现了如下报错</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">E: Failed to fetch https://snapshot.debian.org/archive/debian-ports/20221225T084846Z/pool/main/t/toilet/toilet-fonts_0.3-1.4_all.deb  Unsupported proxy configured: 127.0.0.1://7890</span><br><span class="line">E: Failed to fetch https://snapshot.debian.org/archive/debian-ports/20221225T084846Z/pool-riscv64/main/t/toilet/toilet_0.3-1.4%2bb1_riscv64.deb  Unsupported proxy configured: 127.0.0.1://7890</span><br><span class="line">E: Failed to fetch https://snapshot.debian.org/archive/debian-ports/20221225T084846Z/pool-riscv64/main/w/w3m/w3m_0.5.3%2bgit20220429-1%2bb2_riscv64.deb  Unsupported proxy configured: 127.0.0.1://7890</span><br></pre></td></tr></table></figure><p>原因为<code>export http_proxy=&quot;http://127.0.0.1:7890&quot;</code>写成了<code>export http_proxy=&quot;127.0.0.1:7890&quot;</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;作者使用的是riscv架构的Visionfive2开发板，本博客内的步骤也适用于其他开发板。交叉编译环境为ubuntu20.04。&lt;/p&gt;
&lt;h2 id=&quot;编译内核&quot;&gt;&lt;a href=&quot;#编译内核&quot; class=&quot;headerlink&quot; title=&quot;编译内核&quot;&gt;&lt;/a&gt;编</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>为使用国产SF19A2890芯片的gl-sft1200路由器编译第三方固件</title>
    <link href="https://big7ng.github.io/2023/09/11/glinet/"/>
    <id>https://big7ng.github.io/2023/09/11/glinet/</id>
    <published>2023-09-11T04:14:10.541Z</published>
    <updated>2023-09-11T12:46:59.166Z</updated>
    
    <content type="html"><![CDATA[<p>因为要在寝室里使用，选来选去最终购买了sft1200这款路由器，看重了它的小巧不占空间以及开放源码。<br><img src="\img\sft1200.jpg" alt="sft1200" style="zoom:50%;" /></p><p>本次编译使用vmware虚拟机，操作系统为ubuntu20.04。</p><h1 id="编译固件"><a href="#编译固件" class="headerlink" title="编译固件"></a>编译固件</h1><p>首先下载第三方固件源码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/Big7ng/openwrt-sf-sft1200.git</span><br></pre></td></tr></table></figure><p>进入openwrt目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> openwrt-18.06</span><br></pre></td></tr></table></figure><p>更新feeds</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./scripts/feeds update -a&amp;&amp; ./scripts/feeds install -a</span><br></pre></td></tr></table></figure><p>根据所使用的路由器型号选择配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> .config.sf1200 .config  <span class="comment">#如果使用sf路由器则 cp .config.sf1200 .config</span></span><br></pre></td></tr></table></figure><p>配置所需要的luci-app以及luci-theme</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make menuconfig</span><br></pre></td></tr></table></figure><p>依次点击LuCI-&gt;Applications\Themes,然后选择需要编译安装的应用,我这里选择安装了Openclash以及argon主题。</p><img src="\img\vmware_sBGwsBqf1i.png" alt="vmware_sBGwsBqf1i" style="zoom:50%;" /><img src="\img\vmware_xfmucOtP3D.png" alt="vmware_xfmucOtP3D" style="zoom: 67%;" /><p>下载编译所需工具，<code>n</code>为使用处理器数量</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make -jn download</span><br><span class="line">make V=s -jn</span><br></pre></td></tr></table></figure><p>使用官方SDK时，下载时会出现xxd工具<a href="https://github.com/openwrt/openwrt/issues/10555">无法下载的问题</a>，具体的原因为源码配置的连接类型为http，而该网站之后拒绝了http请求，导致无法下载，我们只需要将原url中的http改为https即可。</p><p>编译完成后，打开<code>./bin/targets/siflower</code>文件夹，将<code>immortalwrt-siflower-sf19a28-fullmask-glinet_gl-sft1200-squashfs-factory.img</code>文件保存起来为后续烧录使用。</p><h1 id="烧录固件"><a href="#烧录固件" class="headerlink" title="烧录固件"></a>烧录固件</h1><p>如果现在路由器上使用的是官方固件，那么可以打开管理页面进行Web升级，如果路由器上使用的是第三方固件，那么只能使用uboot刷入，如下所示：</p><p>断开电源，将路由器lan口与电脑连接，按住路由器重置键不放，打开电源，路由器灯闪五下后变成白灯，此时将本机ip改为192.168.1.0网段，然后浏览器输入192.168.1.1进入uboot界面，选择之前编译好的固件。</p><img src="\img\dllhost_UQCpNjowUK.png" alt="dllhost_UQCpNjowUK" style="zoom:50%;" /><img src="\img\chrome_HxQKGEsgQF.png" alt="chrome_HxQKGEsgQF" style="zoom:50%;" /><p>烧入固件成功后，连接名为Openwrt的WIFI，连接成功后进入192.168.1.1管理界面，初始账号为root，密码为passwd。</p><img src="/img/image-20230911201258283.png" alt="image-20230911201258283" style="zoom: 33%;" /><h1 id="使用感悟"><a href="#使用感悟" class="headerlink" title="使用感悟"></a>使用感悟</h1><p>矽昌Siflower的SF19A2890使用了MIPS架构，但对该架构进行了修改，导致无法使用已经编译过的MIPS二进制程序，而需要特定工具链进行编译。Openclash提供的MIPS架构clash内核无法在路由器上使用，需要自行编译，待后续有时间再进行了解，目前就先用一下Passwall吧。</p><p>不过Clash的界面做的真心可以，不管是CFW、clash网页界面还是Openclash，都比其它工具好看，导致我更喜欢用clash。</p><p>参考：</p><ul><li><a href="https://www.right.com.cn/forum/thread-7348817-1-7.html">恩山论坛zheshifandian</a></li><li><a href="https://forum.gl-inet.cn/forum.php?mod=viewthread&tid=3215&extra=page=1">glinet论坛mulder125</a></li></ul><p>​</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;因为要在寝室里使用，选来选去最终购买了sft1200这款路由器，看重了它的小巧不占空间以及开放源码。&lt;br&gt;&lt;img src=&quot;&#92;img&#92;sft1200.jpg&quot; alt=&quot;sft1200&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;本次编译使用vmware虚</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>编译安卓源码并修改开机动画</title>
    <link href="https://big7ng.github.io/2023/07/02/android/"/>
    <id>https://big7ng.github.io/2023/07/02/android/</id>
    <published>2023-07-02T14:13:28.032Z</published>
    <updated>2023-07-02T14:36:41.567Z</updated>
    
    <content type="html"><![CDATA[<p>本文将编译安卓源码，使用自带emulator工具对编译后的系统进行模拟运行，并修改开机动画。</p><h1 id="下载源码并编译安卓"><a href="#下载源码并编译安卓" class="headerlink" title="下载源码并编译安卓"></a>下载源码并编译安卓</h1><h3 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install git-core gnupg flex bison build-essential zip curl zlib1g-dev gcc-multilib g++-multilib libc6-dev-i386 libncurses5 lib32ncurses5-dev x11proto-core-dev libx11-dev lib32z1-dev libgl1-mesa-dev libxml2-utils xsltproc unzip fontconfig</span><br></pre></td></tr></table></figure><p>安装repo工具</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> ~/bin</span><br><span class="line"><span class="built_in">export</span> PATH=~/bin:<span class="variable">$PATH</span></span><br><span class="line">curl -sSL  <span class="string">&#x27;https://gerrit-googlesource.proxy.ustclug.org/git-repo/+/master/repo?format=TEXT&#x27;</span> |<span class="built_in">base64</span> -d &gt; ~/bin/repo</span><br><span class="line"><span class="built_in">chmod</span> a+x ~/bin/repo</span><br></pre></td></tr></table></figure><h3 id="下载源码"><a href="#下载源码" class="headerlink" title="下载源码"></a>下载源码</h3><p>使用<code>repo init</code>的方法不稳定，因此从<a href="https://mirrors.ustc.edu.cn/help/aosp.html">中科大镜像源</a>上直接下载aosp镜像tar包，下载完成后进行提取。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xf aosp_latest.tar</span><br></pre></td></tr></table></figure><p>进入提取后的aosp目录，运行如下命令，进行同步。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repo sync</span><br></pre></td></tr></table></figure><h3 id="开始编译"><a href="#开始编译" class="headerlink" title="开始编译"></a>开始编译</h3><p>初始化环境，每次开启Shell时都需要运行该命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> build/envsetup.sh</span><br></pre></td></tr></table></figure><p>通过<code>lunch</code>命令对构建目标进行配置，我这里选择的是<code>sdk_pc_x86_64-userdebug</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lunch sdk_pc_x86_64-userdebug <span class="comment">#也可以只输入lunch命令，再根据提示进行选择</span></span><br></pre></td></tr></table></figure><p>开始构建，可以通过<code>-jN</code>选项设置线程数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m</span><br></pre></td></tr></table></figure><img src="/img/build.png" width="600"><p>本文使用16线程数、16GB内存以及30GB交换空间进行编译，耗时约两个半小时，编译完成后提示：<br><img src="/img/build_finish.png" width="600"></p><h3 id="运行emulator"><a href="#运行emulator" class="headerlink" title="运行emulator"></a>运行emulator</h3><p>编译完成后，使用<code>emulator</code>命令启动模拟器，在启用模拟器前，需要通过<code>lunch</code>进行设置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">emulator</span><br></pre></td></tr></table></figure><img src="/img/boot.png" width="600"><h1 id="修改开机动画"><a href="#修改开机动画" class="headerlink" title="修改开机动画"></a>修改开机动画</h1><p>打开<code>packages/services/Car/car_product/bootanimations/bootanimation-832.zip</code>目录，将<code>bootanimation-832.zip</code>修改为自定义的开机动画即可。</p><p>修改完成后，将下述代码加入编译时使用到的任意makefile即可，我这里选用的是<code>build/make/core/envsetup.mk</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PRODUCT_COPY_FILES += \</span><br><span class="line">  packages/services/Car/car_product/bootanimations/bootanimation-832.zip:system/media/bootanimation.zip</span><br></pre></td></tr></table></figure><p>重新编译，再运行emulator，即可看到修改后的开机动画。<br><img src="/img/boot2.png" width="600"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文将编译安卓源码，使用自带emulator工具对编译后的系统进行模拟运行，并修改开机动画。&lt;/p&gt;
&lt;h1 id=&quot;下载源码并编译安卓&quot;&gt;&lt;a href=&quot;#下载源码并编译安卓&quot; class=&quot;headerlink&quot; title=&quot;下载源码并编译安卓&quot;&gt;&lt;/a&gt;下载源码并</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>通过GitHub Pages托管Hexo个人博客</title>
    <link href="https://big7ng.github.io/2023/06/06/hexo_blog/"/>
    <id>https://big7ng.github.io/2023/06/06/hexo_blog/</id>
    <published>2023-06-06T11:03:07.979Z</published>
    <updated>2023-06-06T11:29:22.230Z</updated>
    
    <content type="html"><![CDATA[<p>本文将介绍如何通过GitHub Pages托管个人静态页面，博客所使用的框架为<a href="https://hexo.io/zh-cn/index.html">Hexo</a>，Hexo主题为<a href="https://github.com/chongshengsun/hexo-theme-apollo">apollo</a>。</p><h2 id="本地环境搭建"><a href="#本地环境搭建" class="headerlink" title="本地环境搭建"></a>本地环境搭建</h2><h4 id="安装Git、Nodejs"><a href="#安装Git、Nodejs" class="headerlink" title="安装Git、Nodejs"></a>安装Git、Nodejs</h4><h4 id="安装配置Hexo"><a href="#安装配置Hexo" class="headerlink" title="安装配置Hexo"></a>安装配置Hexo</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo</span><br></pre></td></tr></table></figure><p>创建文件夹,初始化Hexo</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure><h4 id="安装apollo主题"><a href="#安装apollo主题" class="headerlink" title="安装apollo主题"></a>安装apollo主题</h4><p>安装依赖项(可能会有警告,但可以不管)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save hexo-renderer-jade hexo-generator-feed hexo-generator-sitemap hexo-browsersync hexo-generator-archive</span><br></pre></td></tr></table></figure><p>下载主题文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/chongshengsun/hexo-theme-apollo.git themes/apollo</span><br></pre></td></tr></table></figure><p>修改<code>_config.yml</code>的<code>theme</code>配置项为<code>apollo</code>:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="comment">## Plugins: https://hexo.io/plugins/</span></span><br><span class="line"><span class="comment">## Themes: https://hexo.io/themes/</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">apollo</span></span><br></pre></td></tr></table></figure><p>apollo主题中的标签栏信息可以在<code>./theme/apollo/_config.yml</code>文件中修改。</p><h2 id="GitHub-Pages配置与部署Hexo"><a href="#GitHub-Pages配置与部署Hexo" class="headerlink" title="GitHub Pages配置与部署Hexo"></a>GitHub Pages配置与部署Hexo</h2><p>一开始打算使用Gitee的页面托管，但是使用该服务需要上传身份证照片，不仅麻烦还不方便写一些特殊技术，遂放弃。如何使用GitHub Pages可以参考<a href="https://docs.github.com/en/pages/quickstart">这篇文章</a>。</p><p>配置好GitHub Pages就可以部署Hexo了.</p><h4 id="部署Hexo"><a href="#部署Hexo" class="headerlink" title="部署Hexo"></a>部署Hexo</h4><p>安装 hexo-deployer-git</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>修改<code>_config.yml</code>配置文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">https://github.com/Big7ng/Big7ng.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure><p>在命令行输入如下命令完成部署</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo generate</span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文将介绍如何通过GitHub Pages托管个人静态页面，博客所使用的框架为&lt;a href=&quot;https://hexo.io/zh-cn/index.html&quot;&gt;Hexo&lt;/a&gt;，Hexo主题为&lt;a href=&quot;https://github.com/chongshengs</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://big7ng.github.io/2023/06/05/hello-world/"/>
    <id>https://big7ng.github.io/2023/06/05/hello-world/</id>
    <published>2023-06-05T14:30:49.978Z</published>
    <updated>2023-06-05T14:30:49.978Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
