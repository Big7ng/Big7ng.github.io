<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Big7ng&#39;s Blog</title>
  
  
  <link href="https://big7ng.github.io/atom.xml" rel="self"/>
  
  <link href="https://big7ng.github.io/"/>
  <updated>2024-07-30T17:57:26.902Z</updated>
  <id>https://big7ng.github.io/</id>
  
  <author>
    <name>Big7ng</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>手动编译LineageOS固件并刷入小米10T</title>
    <link href="https://big7ng.github.io/2024/07/31/lineageos/"/>
    <id>https://big7ng.github.io/2024/07/31/lineageos/</id>
    <published>2024-07-30T17:43:28.730Z</published>
    <updated>2024-07-30T17:57:26.902Z</updated>
    
    <content type="html"><![CDATA[<p>LineageOS是基于原生安卓的开源第三方固件，本文将手动编译LineageOS固件并刷入小米10T（红米K30S）。</p><p>本次编译的配置为Vmware虚拟机ubuntu20.04，内存32GB，swap空间10GB，磁盘空间350GB。需要提醒的是创建虚拟机时建议将虚拟磁盘选择为“拆分为多个文件”，这样可以方便后续编译过程中磁盘空间不足时进行扩容。若设置为“存储为单个文件”，则非常不方便进行扩容（单个文件的扩容原理为创建一个更大的文件，将原始文件中的内容复制过去，若宿主机磁盘空间不足，则会扩容失败）。</p><h1 id="配置编译环境"><a href="#配置编译环境" class="headerlink" title="配置编译环境"></a>配置编译环境</h1><p>下载<a href="https://developer.android.com/tools/releases/platform-tools?hl=zh-cn">Android SDK平台工具</a>并解压</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unzip platform-tools-latest-linux.zip -d ~</span><br></pre></td></tr></table></figure><p>打开 <code>~/.profile</code>文件并添加以下内容，执行<code>source ~/.profile</code> 命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># add Android SDK platform tools to path</span></span><br><span class="line"><span class="keyword">if</span> [ -d <span class="string">&quot;<span class="variable">$HOME</span>/platform-tools&quot;</span> ] ; <span class="keyword">then</span></span><br><span class="line">    PATH=<span class="string">&quot;<span class="variable">$HOME</span>/platform-tools:<span class="variable">$PATH</span>&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>安装编译工具</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install lib32ncurses5-dev libncurses5 libncurses5-dev bc bison build-essential ccache curl flex g++-multilib gcc-multilib git git-lfs gnupg gperf imagemagick lib32readline-dev lib32z1-dev libelf-dev liblz4-tool libsdl1.2-dev libssl-dev libxml2 libxml2-utils lzop pngcrush rsync schedtool squashfs-tools xsltproc zip zlib1g-dev python-is-python3</span><br></pre></td></tr></table></figure><h3 id="配置Git"><a href="#配置Git" class="headerlink" title="配置Git"></a>配置Git</h3><p>配置自己的名字与邮箱，如果后续不涉及commit，仅仅是clone，可以随便设置。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.email <span class="string">&quot;sundaqing2020@gmail.com&quot;</span></span><br><span class="line">git config --global user.name <span class="string">&quot;Big7ng&quot;</span></span><br></pre></td></tr></table></figure><p>初始化<a href="https://git-lfs.com/">Git LFS</a>(Large File Storage)拓展，，它可以在使用Git进行版本控制时处理大型文件。它通过将文件内容存储在外部服务器上，并在Git仓库中保留指向这些文件的引用，从而有效地管理和版本控制大型文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git lfs install</span><br></pre></td></tr></table></figure><h3 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h3><p>为repo下载，LineageOS源码，LineageOS编译创建目录。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p ~/bin</span><br><span class="line"><span class="built_in">mkdir</span> -p ~/android/lineage</span><br></pre></td></tr></table></figure><h3 id="安装repo"><a href="#安装repo" class="headerlink" title="安装repo"></a>安装repo</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl https://mirrors.tuna.tsinghua.edu.cn/git/git-repo &gt; ~/bin/repo</span><br><span class="line"><span class="built_in">chmod</span> a+x ~/bin/repo</span><br></pre></td></tr></table></figure><p>repo的运行过程中会尝试访问官方的git源更新自己，如果想使用tuna的镜像源进行更新，可以将如下内容复制到你的~&#x2F;.bashrc里，执行命令<code>source ~/.bashrc</code>.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export REPO_URL=&#x27;https://mirrors.tuna.tsinghua.edu.cn/git/git-repo&#x27;</span><br></pre></td></tr></table></figure><p> 为了确保终端模拟器能够找到repo的路径，需要保证以下内容在<code>~/.profile</code>文件中, 添加后执行命令<code>source ~/.profile</code>.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># set PATH so it includes user&#x27;s private bin if it exists</span></span><br><span class="line"><span class="keyword">if</span> [ -d <span class="string">&quot;<span class="variable">$HOME</span>/bin&quot;</span> ] ; <span class="keyword">then</span></span><br><span class="line">    PATH=<span class="string">&quot;<span class="variable">$HOME</span>/bin:<span class="variable">$PATH</span>&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><h3 id="使用ccache开启缓存提高编译速度"><a href="#使用ccache开启缓存提高编译速度" class="headerlink" title="使用ccache开启缓存提高编译速度"></a>使用ccache开启缓存提高编译速度</h3><p><a href="https://ccache.dev/">ccache</a> 是一个编译器缓存工具,可以显著加快编译过程，对于大型项目来说效果非常明显。它通过将之前编译的结果缓存下来，当下次编译相同的源文件时,如果没有变化，就可以直接读取缓存结果而不需要重新编译，大大缩短编译时间。</p><p>打开ccache功能后会在用户目录下生成一个<code>.ccache</code>文件夹用以产生编译时的缓存。</p><p>在命令行中输入以下命令以开启ccache功能。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> USE_CCACHE=1</span><br><span class="line"><span class="built_in">export</span> CCACHE_EXEC=/usr/bin/ccache</span><br></pre></td></tr></table></figure><p>通过<code>cache -M SIZE</code>命令来调节缓存大小，SIZE为0表示没有缓存限制，编译Android时建议设置为25-50G。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ccache -M 50G</span><br></pre></td></tr></table></figure><p>注意，这个功能需要充足的磁盘空间，如果磁盘空间比较紧张，建议关闭这个功能。</p><h3 id="配置swap交换空间"><a href="#配置swap交换空间" class="headerlink" title="配置swap交换空间"></a>配置swap交换空间</h3><p>ubuntu自带的swap交换空间为2G，这可能不够用，需要将swapfile增加到10G。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo swapoff /swapfile</span><br><span class="line">sudo fallocate -l 10G /swapfile</span><br><span class="line">sudo mkswap /swapfile</span><br><span class="line">sudo swapon /swapfile</span><br></pre></td></tr></table></figure><h1 id="下载源码"><a href="#下载源码" class="headerlink" title="下载源码"></a>下载源码</h1><p>国内访问谷歌不稳定，因此本文使用清华镜像源下载LineageOS源码。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/android/lineage</span><br><span class="line">repo init -u https://mirrors.tuna.tsinghua.edu.cn/git/lineageOS/LineageOS/android.git -b lineage-20.0 --git-lfs</span><br></pre></td></tr></table></figure><p>打开<code>.repo/manifests/default.xml</code>，将</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;remote  name=&quot;github&quot;</span><br><span class="line">         fetch=&quot;..&quot;</span><br><span class="line">         review=&quot;review.lineageos.org&quot; /&gt;</span><br></pre></td></tr></table></figure><p>改成</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;remote  name=&quot;github&quot;</span><br><span class="line">         fetch=&quot;https://github.com/&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;remote  name=&quot;lineage&quot;</span><br><span class="line">         fetch=&quot;https://mirrors.tuna.tsinghua.edu.cn/git/lineageOS/&quot;</span><br><span class="line">         review=&quot;review.lineageos.org&quot; /&gt;</span><br></pre></td></tr></table></figure><p>将</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;remote  name=&quot;aosp&quot;</span><br><span class="line">         fetch=&quot;https://android.googlesource.com&quot;</span><br></pre></td></tr></table></figure><p>改成</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;remote  name=&quot;aosp&quot;</span><br><span class="line">         fetch=&quot;https://mirrors.tuna.tsinghua.edu.cn/git/AOSP&quot;</span><br></pre></td></tr></table></figure><p>将</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;default revision=&quot;...&quot;</span><br><span class="line">         remote=&quot;github&quot;</span><br></pre></td></tr></table></figure><p>改成</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;default revision=&quot;...&quot;</span><br><span class="line">         remote=&quot;lineage&quot;</span><br></pre></td></tr></table></figure><p>同步源码树</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repo sync</span><br></pre></td></tr></table></figure><h3 id="下载设备特定文件"><a href="#下载设备特定文件" class="headerlink" title="下载设备特定文件"></a>下载设备特定文件</h3><p><code>breakfast &lt;device&gt;</code>命令用于选择特定的设备，本文使用小米10T，因此device为apollon。</p><p>执行下列命令后会下载设备<a href="https://github.com/LineageOS/android_device_xiaomi_apollon">特定的配置文</a>件与Linux内核。分别对应于<code>device/xiaomi/</code>与<code>kernel/xiaomi/sm8250</code>文件夹。sm8250指骁龙865处理器。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/android/lineage</span><br><span class="line"><span class="built_in">source</span> build/envsetup.sh</span><br><span class="line">breakfast apollon</span><br></pre></td></tr></table></figure><p>这一步如果有报错，执行完下一步后返回重新执行一遍。</p><h3 id="从LineageOS刷机包中提取proprietary-blobs"><a href="#从LineageOS刷机包中提取proprietary-blobs" class="headerlink" title="从LineageOS刷机包中提取proprietary blobs"></a>从LineageOS刷机包中提取proprietary blobs</h3><p>首先需要在<a href="https://download.lineageos.org/devices/apollon/builds">LineageOS官网</a>下载LineageOS的Xiaomi10T的刷机包。</p><p>在提取前需要安装两个工具：brotli和sdat2img。</p><p><strong>brotli</strong>是Google推出的一款无损压缩算法，需要使用brotli工具将刷机包中的<code>.br</code>压缩文件解压。</p><p>Android镜像主要有两种格式，分别为raw与sparse：</p><ul><li>raw iamge是完整的ext4分区镜像（包含很多全零的无效填充区），可以直接使用mount进行挂载，因此比较大（一般1G左右）。</li><li>sparse ext4 image，是一个非常普通的dat文件。由于它将raw ext4进行稀疏描述，因此尺寸比较小（没有全零的无效填充区）。</li></ul><p><strong>sdat2img</strong>工具将sparse Android data镜像(.dat)转换为ext4镜像(.img)，然后我们就可以挂载该文件进行提取了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> ~/android/system_dump/</span><br><span class="line"><span class="built_in">cd</span> ~/android/system_dump/</span><br><span class="line">sudo apt-get install brotli</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/xpirt/sdat2img</span><br></pre></td></tr></table></figure><p>安装完成后，可以开始进行提取了，刷机包中需要提取的内容为Android系统的<a href="https://source.android.com/docs/core/architecture/partitions?hl=zh-cn">不同分区</a>内容，将不同分区内的设备特定文件提取出来：</p><p><strong>system 分区</strong>是安卓系统的核心部分,包含了操作系统的基本文件和程序。它是安卓设备启动和运行的基础,确保设备能够正常启动和运行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">unzip ~/Downloads/lineage-*.zip system.transfer.list system.new.dat*</span><br><span class="line">brotli --decompress --output=system.new.dat system.new.dat.br</span><br><span class="line">python sdat2img/sdat2img.py system.transfer.list system.new.dat system.img</span><br><span class="line"><span class="built_in">mkdir</span> system/</span><br><span class="line">sudo mount system.img system/</span><br></pre></td></tr></table></figure><p><strong>vendor 分区</strong>包含了设备制造商特有的驱动程序和配置文件。这些文件确保设备的硬件能够与安卓操作系统正常集成和工作。</p><p>此分区包含所有无法分发给 AOSP 的二进制文件。如果设备不包含专有信息，则可以忽略此分区。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">unzip ~/Downloads/lineage-*.zip vendor.transfer.list vendor.new.dat*</span><br><span class="line">brotli --decompress --output=vendor.new.dat vendor.new.dat.br</span><br><span class="line">python sdat2img/sdat2img.py vendor.transfer.list vendor.new.dat vendor.img</span><br><span class="line">sudo <span class="built_in">rm</span> -r system/vendor</span><br><span class="line">sudo <span class="built_in">mkdir</span> system/vendor</span><br><span class="line">sudo mount vendor.img system/vendor/</span><br></pre></td></tr></table></figure><p><a href="https://source.android.com/docs/core/architecture/partitions/shared-system-image?hl=zh-cn#sys-ext-partition">system_ext分区</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">unzip ~/Downloads/lineage-*.zip system_ext.transfer.list system_ext.new.dat*</span><br><span class="line">brotli --decompress --output=system_ext.new.dat system_ext.new.dat.br</span><br><span class="line">python sdat2img/sdat2img.py system_ext.transfer.list system_ext.new.dat system_ext.img</span><br><span class="line">sudo <span class="built_in">rm</span> system/system_ext -r</span><br><span class="line">sudo <span class="built_in">mkdir</span> system/system_ext</span><br><span class="line">sudo mount system_ext.img system/system_ext/</span><br></pre></td></tr></table></figure><p><a href="https://source.android.com/docs/core/architecture/bootloader/partitions/product-partitions?hl=zh-cn">product分区</a>是特定于设备的定制区域，用于存储与设备相关的应用程序、配置文件和资源。这个分区主要用于制造商和运营商来添加或修改设备上特定的应用程序和服务，而不影响Android系统的核心功能。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">unzip ~/Downloads/lineage-*.zip product.transfer.list product.new.dat*</span><br><span class="line">brotli --decompress --output=product.new.dat product.new.dat.br</span><br><span class="line">python sdat2img/sdat2img.py product.transfer.list product.new.dat product.img</span><br><span class="line">sudo <span class="built_in">rm</span> system/product -r</span><br><span class="line">sudo <span class="built_in">mkdir</span> system/product</span><br><span class="line">sudo mount product.img system/product/</span><br></pre></td></tr></table></figure><p><a href="https://source.android.com/docs/core/architecture/bootloader/partitions/odm-partitions?hl=zh-cn">ODM分区</a>是设备制造商(Original Design Manufacturer)提供的一个专有分区。它包含了设备特有的驱动程序、配置文件和其他定制化的软件组件。</p><p>ODM 分区与 vendor 分区的作用类似，都是提供设备制造商特有的软件组件。不同的是，vendor 分区是由操作系统供应商(如谷歌、小米、OPPO等)维护，而 ODM 分区是由设备制造商维护。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">unzip ~/Downloads/lineage-*.zip odm.transfer.list odm.new.dat*</span><br><span class="line">brotli --decompress --output=odm.new.dat odm.new.dat.br</span><br><span class="line">python sdat2img/sdat2img.py odm.transfer.list odm.new.dat odm.img</span><br><span class="line">sudo <span class="built_in">rm</span> system/odm -r</span><br><span class="line">sudo <span class="built_in">mkdir</span> system/odm</span><br><span class="line">sudo mount odm.img system/odm/</span><br></pre></td></tr></table></figure><p>完成以上操作后，可以开始提取proprietary blobs了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/android/lineage/device/xiaomi/apollon</span><br><span class="line">./extract-files.sh ~/android/system_dump/</span><br></pre></td></tr></table></figure><p>提取后， 挂载的镜像都不需要了，可以进行清理以节省磁盘空间。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo umount ~/android/system_dump/system/system_ext</span><br><span class="line">sudo umount ~/android/system_dump/system/product</span><br><span class="line">sudo umount ~/android/system_dump/system/vendor</span><br><span class="line">sudo umount ~/android/system_dump/system/odm</span><br><span class="line">sudo umount ~/android/system_dump/system</span><br><span class="line"><span class="built_in">rm</span> -rf ~/android/system_dump</span><br></pre></td></tr></table></figure><h1 id="编译源码"><a href="#编译源码" class="headerlink" title="编译源码"></a>编译源码</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/android/lineage</span><br><span class="line">croot</span><br><span class="line">brunch apollon</span><br></pre></td></tr></table></figure><p>博主编译过程中出现的错误主要有如下：</p><ul><li>出现了如下错误，需要检查提取proprietary blobs步骤中，是否把OTA升级包中所有的镜像文件都提取了。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> FAILED: ninja: &#x27;vendor/xiaomi/sm8250-common/proprietary/odm/etc/media_profiles_V</span><br><span class="line">1_0.xml&#x27;, needed by &#x27;out/target/product/apollon/odm/etc/media_profiles_V1_0.xml&#x27;</span><br><span class="line">, missing and no known rule to make it</span><br></pre></td></tr></table></figure><ul><li>出现了如下错误，<code>repo sync</code>命令未下载完全，把报错中相应的目录删除后重新执行<code>repo sync</code>命令。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ninja: &#x27;external/chromium-webview/prebuilt/arm64/webview.apk&#x27;, needed by</span><br><span class="line"> &#x27;out/target/product/apollon/obj/APPS/webview_intermediates/package.apk&#x27;, missing and no known rule to make it</span><br></pre></td></tr></table></figure><ul><li>如果没有出现error错误，但是编译停止了，此时大概率是内存不足了，可以增加swap空间大小。</li></ul><h1 id="刷机"><a href="#刷机" class="headerlink" title="刷机"></a>刷机</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> <span class="variable">$OUT</span></span><br></pre></td></tr></table></figure><p>该目录下两个文件在后续刷机过程需要使用：</p><ol><li><code>recovery.img</code>, which is the LineageOS recovery image.</li><li><code>lineage-20.0-20240713-UNOFFICIAL-apollon.zip</code>, which is the LineageOS installer package.</li></ol><p>后续的刷机过程与官方提供的刷机包一致，可以参考<a href="https://wiki.lineageos.org/devices/apollon/install/variant3/#">官方文档</a>，简要概括一下就是先刷入recovery固件，再通过该recovery模式刷入LineageOS固件。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://wiki.lineageos.org/devices/apollon/build/variant3/">Build LineageOS for Xiaomi Redmi K30S Ultra</a></p><p><a href="https://wiki.lineageos.org/extracting_blobs_from_zips">Extracting proprietary blobs from LineageOS zip files</a></p><p><a href="https://blog.csdn.net/luoshengyang/article/details/29688041">从CM刷机过程和原理分析Android系统结构</a></p><p><a href="https://mirrors.tuna.tsinghua.edu.cn/help/git-repo/">Git Repo 镜像使用帮助</a></p><p><a href="https://mirrors.tuna.tsinghua.edu.cn/help/lineageOS/">lineageOS 源代码镜像使用帮助</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;LineageOS是基于原生安卓的开源第三方固件，本文将手动编译LineageOS固件并刷入小米10T（红米K30S）。&lt;/p&gt;
&lt;p&gt;本次编译的配置为Vmware虚拟机ubuntu20.04，内存32GB，swap空间10GB，磁盘空间350GB。需要提醒的是创建虚拟机时</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Linux内核中红黑树实现机制的探索</title>
    <link href="https://big7ng.github.io/2024/06/09/rbtree_linux/"/>
    <id>https://big7ng.github.io/2024/06/09/rbtree_linux/</id>
    <published>2024-06-08T17:57:08.101Z</published>
    <updated>2024-06-10T16:56:46.918Z</updated>
    
    <content type="html"><![CDATA[<p>Linux中有着大量的红黑树的应用：</p><ul><li><p>进程调度—<a href="https://elixir.bootlin.com/linux/v5.15.155/source/include/linux/sched.h#L527">CFS完全公平调度</a></p></li><li><p>虚拟内存管理<a href="https://elixir.bootlin.com/linux/v5.15.155/source/include/linux/mm_types.h#L402">mm_struct</a>, <a href="https://elixir.bootlin.com/linux/v5.15.155/source/include/linux/vmalloc.h#L77">vmap_area</a></p></li><li><p>文件系统</p><ul><li>ext4文件系统中，红黑树被用来管理文件的逻辑块到物理块的映射（<a href="https://elixir.bootlin.com/linux/v5.15.155/source/fs/ext4/extents_status.h#L60">extend</a>）、<a href="https://elixir.bootlin.com/linux/v5.15.155/source/fs/ext4/dir.c#L407">目录的索引</a>、管理空闲块的分配（<a href="https://elixir.bootlin.com/linux/v5.15.155/source/fs/ext4/mballoc.c#L811">mballoc</a>）</li><li>Btrfs 文件系统</li></ul></li><li><p>TCP网络堆栈<a href="https://elixir.bootlin.com/linux/v5.15.155/source/include/linux/skbuff.h#L761">sk_buff</a></p></li><li><p>高精度定时器<a href="https://elixir.bootlin.com/linux/v5.15.155/source/include/linux/hrtimer.h#L118">HR-Timer</a></p></li><li><p>多路复用<a href="https://elixir.bootlin.com/linux/v5.15.155/source/fs/eventpoll.c#L177">epoll</a></p></li></ul><p>因此为了更好地了解内核，有必要对Linux内核中红黑树的实现进行分析，本次分析的内核源码版本为5.15.155。</p><p>内核源码中与红黑树定义有关的文件包括：<a href="https://elixir.bootlin.com/linux/v5.15.155/source/include/linux/rbtree.h">&#x2F;include&#x2F;linux&#x2F;rbtree.h</a>、<a href="https://elixir.bootlin.com/linux/v5.15.155/source/include/linux/rbtree_augmented.h">&#x2F;include&#x2F;linux&#x2F;rbtree_augmented.h</a>、<a href="https://elixir.bootlin.com/linux/v5.15.155/source/include/linux/rbtree_types.h">&#x2F;inclue&#x2F;linux&#x2F;rbtree_types.h</a>、<a href="https://elixir.bootlin.com/linux/v5.15.155/source/lib/rbtree.c">&#x2F;lib&#x2F;rbtree.c</a>。本文将对这四个文件中的关键代码进行探索。</p><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><ul><li><p><code>rb_node</code>是内核红黑树中最基础的数据结构, 用于表示红黑树节点。</p><p>  该结构包含四个信息：父节点指针、颜色、左子节点指针、右子节点指针，但是结构体中只有三个变量。由于指针通常是对齐的（例如，4字节或8字节对齐），最低有效位可以安全地用作存储其他信息而不影响指针的正确性，因此<code>rbtree</code>结构体将颜色信息嵌入到<code>__rb_parent_color</code>成员变量的最低有效位中，因此该变量中包含了父节点指针和颜色信息。</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>  __rb_parent_color;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">rb_right</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">rb_left</span>;</span></span><br><span class="line">&#125; __attribute__((aligned(<span class="keyword">sizeof</span>(<span class="type">long</span>))));<span class="comment">//指定 rb_node 结构体的起始地址将按 `long` 类型的大小对齐。</span></span><br><span class="line"><span class="comment">/* The alignment might seem pointless, but allegedly CRIS needs it */</span></span><br></pre></td></tr></table></figure><p>  该结构体中没有<code>key</code>域，这是<code>linux</code>数据结构的一大特色，就是结构不包括数据，而是由数据和基本结构被包括在同一个<code>struct</code>中。如果我们需要创建一个结构体，并用红黑树进行组织，可以向如下代码这样组织：</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mytype</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> <span class="title">node</span>;</span></span><br><span class="line">  <span class="type">char</span> *keystring;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//linux的rbtree的功能是由多种接口组成,相比于我们c++的面向对象实现的红黑树或者其他数据结构，我们实现一个链表类都是将所有的功能完全的在一个类中实现，而对于linux(不过linux大部分源码都是c实现的，所以没有面向对象的思想)，则是写成很多的接口。至于写成接口的好处就是：当linux实现完链表的结构后，后面实现栈和队列的时候，可以不用赋值链表的源码或者在实现栈和队列时引用链表类，这里可以直接使用链表的接口。就可以大大缩减代码量和内存空间。</span></span><br></pre></td></tr></table></figure></li><li><p><code>rb_root</code>变量存储了根节点指针，用于表示一颗红黑树。</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">rb_node</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><code>struct rb_root_cached</code> 是一个用来表示红黑树（Red-Black Tree）的结构体，并且它增加了一个缓存（<code>rb_leftmost</code>）来存储树中最左边的节点。</p><p>  通常，找到红黑树中的最小节点需要从根节点开始，调用<code>rb_frist()</code>沿着左子树一路遍历到最左边的叶子节点。而有了 rb_leftmost 指针后，可以直接通过这个指针访问最小节点，避免了每次查找时的遍历操作。</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rb_root_cached</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">rb_root</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">rb_leftmost</span>;</span> <span class="comment">//指向红黑树中最左边（也就是最小）的节点</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><code>dummy_callbacks</code>是一个包含占位符回调函数的结构体，这些回调函数目前都是空实现（什么都不做）。这些占位符通常在需要红黑树的增强功能（augmented red-black tree）的场景中被实际的逻辑所替换，例如更新某些附加信息。当前的空实现可以视为一个默认的、不需要任何额外操作的基础实现。</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">dummy_propagate</span><span class="params">(<span class="keyword">struct</span> rb_node *node, <span class="keyword">struct</span> rb_node *stop)</span> &#123;&#125;</span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">dummy_copy</span><span class="params">(<span class="keyword">struct</span> rb_node *old, <span class="keyword">struct</span> rb_node *new)</span> &#123;&#125;</span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">dummy_rotate</span><span class="params">(<span class="keyword">struct</span> rb_node *old, <span class="keyword">struct</span> rb_node *new)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">rb_augment_callbacks</span> <span class="title">dummy_callbacks</span> =</span> &#123;</span><br><span class="line">    .propagate = dummy_propagate,</span><br><span class="line">    .copy = dummy_copy,</span><br><span class="line">    .rotate = dummy_rotate</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h1 id="辅助函数"><a href="#辅助函数" class="headerlink" title="辅助函数"></a>辅助函数</h1><p>辅助函数一般为宏定义，用于便捷地获取与设置红黑树节点的值。</p><ul><li><p><code>rb_parent</code>用于获取输入节点的父节点地址。由于父节点指针和颜色信息都存储在同一个字段中,所以需要通过位操作来分离出父节点指针。(r)-&gt;__rb_parent_color &amp; ~3 可以将最后两个位（存储颜色信息）清零,得到的就是父节点指针的值。</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> rb_parent(r)   ((struct rb_node *)((r)-&gt;__rb_parent_color &amp; ~3))</span></span><br></pre></td></tr></table></figure></li><li><p><code>rb_color</code>用于获取节点的颜色</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> rb_color(rb)       __rb_color((rb)-&gt;__rb_parent_color)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __rb_color(pc)     ((pc) &amp; 1)</span></span><br></pre></td></tr></table></figure></li><li><p><code>rb_is_red</code>用于判断节点是否为红色, rb_is_black同理</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#define rb_is_red(rb)      __rb_is_red((rb)-&gt;__rb_parent_color)</span><br><span class="line">#define __rb_is_red(pc)    (!__rb_color(pc))</span><br><span class="line">#define __rb_color(pc)     ((pc) &amp; 1)</span><br></pre></td></tr></table></figure></li><li><p><code>rb_red_parent</code>从 <code>__rb_parent_color</code> 字段中提取当前节点的父节点指针,并检查父节点是否为红色。</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> rb_node *<span class="title function_">rb_red_parent</span><span class="params">(<span class="keyword">struct</span> rb_node *red)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">struct</span> rb_node *)red-&gt;__rb_parent_color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>RB_EMPTY_ROOT</code>用于判断节点是否为空</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> RB_EMPTY_ROOT(root)  (READ_ONCE((root)-&gt;rb_node) == NULL)</span></span><br></pre></td></tr></table></figure><p>  <code>READ_ONCE</code> 是一个内核级别的宏,它主要用于确保在多线程&#x2F;多核环境下安全地读取一个变量的值。<br>  在多线程&#x2F;多核环境下,一个变量可能会被多个线程&#x2F;CPU同时访问和修改。如果不采取特殊措施,编译器可能会对变量的访问进行优化,导致读取到不正确的值。<br>  <code>READ_ONCE</code> 宏能够禁止编译器对变量的访问进行优化,确保每次读取都是从内存中直接获取变量的最新值,而不是使用寄存器中缓存的旧值。</p></li><li><p><code>rb_set_parent</code>用于设置parent节点, <code>rb_set_parent_color</code>用于设置parent节点与当前节点的颜色.</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">rb_set_parent</span><span class="params">(<span class="keyword">struct</span> rb_node *rb, <span class="keyword">struct</span> rb_node *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    rb-&gt;__rb_parent_color = rb_color(rb) | (<span class="type">unsigned</span> <span class="type">long</span>)p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">rb_set_parent_color</span><span class="params">(<span class="keyword">struct</span> rb_node *rb,</span></span><br><span class="line"><span class="params">                       <span class="keyword">struct</span> rb_node *p, <span class="type">int</span> color)</span></span><br><span class="line">&#123;</span><br><span class="line">    rb-&gt;__rb_parent_color = (<span class="type">unsigned</span> <span class="type">long</span>)p | color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>rb_link_node</code>用于将新节点插入树中，把parent设为node的父结点，并且让rb_link指向node。</p></li><li><pre><code class="c">static inline void rb_link_node(struct rb_node *node, struct rb_node *parent,                struct rb_node **rb_link)&#123;    node-&gt;__rb_parent_color = (unsigned long)parent;    node-&gt;rb_left = node-&gt;rb_right = NULL;    *rb_link = node;&#125;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* `rb_entry`用于返回包含红黑树节点的结构体。由于红黑树节点中并不包含key，因此需要`rb_entry`来返回包含key和rb_node的结构体。`container_of` 宏是 Linux 内核中常用的一个宏，用于从结构体中的一个成员指针推导出包含该成员的结构体指针。</span><br><span class="line"></span><br><span class="line">  ```c</span><br><span class="line">  #definerb_entry(ptr, type, member) container_of(ptr, type, member)</span><br></pre></td></tr></table></figure></code></pre></li></ul><h1 id="红黑树操作"><a href="#红黑树操作" class="headerlink" title="红黑树操作"></a>红黑树操作</h1><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><p>红黑树的遍历方式与其他二叉树的遍历方式大致相同。Linux内核中对于红黑树的遍历实现了两种顺序：后序遍历与中序遍历。</p><ul><li><p>后序遍历</p><ul><li><p><code>rb_first_postorder</code>返回后序遍历中的第一个节点</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> rb_node *<span class="title function_">rb_first_postorder</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> rb_root *root)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root-&gt;rb_node)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rb_left_deepest_node(root-&gt;rb_node);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(rb_first_postorder);</span><br></pre></td></tr></table></figure><ul><li><p><code>rb_next_postorder</code>返回后序遍历中输入节点的下一个节点</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> rb_node *<span class="title function_">rb_next_postorder</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> rb_node *node)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">parent</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (!node)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    parent = rb_parent(node);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If we&#x27;re sitting on node, we&#x27;ve already seen our children */</span></span><br><span class="line">    <span class="keyword">if</span> (parent &amp;&amp; node == parent-&gt;rb_left &amp;&amp; parent-&gt;rb_right) &#123;</span><br><span class="line">        <span class="comment">/* If we are the parent&#x27;s left node, go to the parent&#x27;s right</span></span><br><span class="line"><span class="comment">         * node then all the way down to the left */</span></span><br><span class="line">        <span class="keyword">return</span> rb_left_deepest_node(parent-&gt;rb_right);</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        <span class="comment">/* Otherwise we are the parent&#x27;s right node, and the parent</span></span><br><span class="line"><span class="comment">         * should be next */</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">struct</span> rb_node *)parent;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(rb_next_postorder);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p><code>rb_left_deepest_node</code>返回最深且位于最左端的节点, 即后序遍历中的第一个节点</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> rb_node *<span class="title function_">rb_left_deepest_node</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> rb_node *node)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;rb_left)</span><br><span class="line">            node = node-&gt;rb_left;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (node-&gt;rb_right)</span><br><span class="line">            node = node-&gt;rb_right;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">struct</span> rb_node *)node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>中序遍历</p><ul><li><p><code>rb_last</code>返回中序遍历中的最后一个节点</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> rb_node *<span class="title function_">rb_last</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> rb_root *root)</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span>*<span class="title">n</span>;</span></span><br><span class="line"></span><br><span class="line">    n = root-&gt;rb_node;</span><br><span class="line">    <span class="keyword">if</span> (!n)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (n-&gt;rb_right)</span><br><span class="line">        n = n-&gt;rb_right;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(rb_last);</span><br></pre></td></tr></table></figure></li><li><p><code>rb_first</code>返回中序遍历中的第一个节点</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> rb_node *<span class="title function_">rb_first</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> rb_root *root)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span>*<span class="title">n</span>;</span></span><br><span class="line"></span><br><span class="line">    n = root-&gt;rb_node;</span><br><span class="line">    <span class="keyword">if</span> (!n)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (n-&gt;rb_left)</span><br><span class="line">        n = n-&gt;rb_left;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(rb_first);</span><br></pre></td></tr></table></figure></li><li><p><code>rb_next</code>返回指定节点中序遍历中的下一个节点, 即后继节点</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> rb_node *<span class="title function_">rb_next</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> rb_node *node)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">parent</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (RB_EMPTY_NODE(node))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * If we have a right-hand child, go down and then left as far</span></span><br><span class="line"><span class="comment">     * as we can.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (node-&gt;rb_right) &#123;</span><br><span class="line">        node = node-&gt;rb_right;</span><br><span class="line">        <span class="keyword">while</span> (node-&gt;rb_left)</span><br><span class="line">            node = node-&gt;rb_left;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">struct</span> rb_node *)node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * No right-hand children. Everything down and left is smaller than us,</span></span><br><span class="line"><span class="comment">     * so any &#x27;next&#x27; node must be in the general direction of our parent.</span></span><br><span class="line"><span class="comment">     * Go up the tree; any time the ancestor is a right-hand child of its</span></span><br><span class="line"><span class="comment">     * parent, keep going up. First time it&#x27;s a left-hand child of its</span></span><br><span class="line"><span class="comment">     * parent, said parent is our &#x27;next&#x27; node.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">while</span> ((parent = rb_parent(node)) &amp;&amp; node == parent-&gt;rb_right)</span><br><span class="line">        node = parent;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> parent;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(rb_next);</span><br></pre></td></tr></table></figure></li><li><p><code>rb_prev</code>返回指定节点中序遍历中的上一个节点, 即前驱节点</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> rb_node *<span class="title function_">rb_prev</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> rb_node *node)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">parent</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (RB_EMPTY_NODE(node))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * If we have a left-hand child, go down and then right as far</span></span><br><span class="line"><span class="comment">     * as we can.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (node-&gt;rb_left) &#123;</span><br><span class="line">        node = node-&gt;rb_left;</span><br><span class="line">        <span class="keyword">while</span> (node-&gt;rb_right)</span><br><span class="line">            node = node-&gt;rb_right;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">struct</span> rb_node *)node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * No left-hand children. Go up till we find an ancestor which</span></span><br><span class="line"><span class="comment">     * is a right-hand child of its parent.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">while</span> ((parent = rb_parent(node)) &amp;&amp; node == parent-&gt;rb_left)</span><br><span class="line">        node = parent;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> parent;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(rb_prev);</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p>内核中遍历的具体实现方式有两种：</p><p>第一种是使用内核内部实现的查找函数, 由于内核红黑树的节点结构体中并不包含key，因此在实现查找操作时需要自定义<code>cmp</code>函数。内核中的查找函数如下：</p><ul><li><p><code>rb_next_match</code>用于判断下一个节点是否包含指定key, 若包含key则返回该节点指针, 否则返回空NULL</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __always_inline <span class="keyword">struct</span> rb_node *</span><br><span class="line"><span class="title function_">rb_next_match</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *key, <span class="keyword">struct</span> rb_node *node,</span></span><br><span class="line"><span class="params">          <span class="type">int</span> (*cmp)(<span class="type">const</span> <span class="type">void</span> *key, <span class="type">const</span> <span class="keyword">struct</span> rb_node *))</span></span><br><span class="line">&#123;</span><br><span class="line">    node = rb_next(node);</span><br><span class="line">    <span class="keyword">if</span> (node &amp;&amp; cmp(key, node))</span><br><span class="line">        node = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>rb_find_first</code>返回红黑树中第一个包含指定key的节点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * rb_find_first() - find the first @key in @tree</span></span><br><span class="line"><span class="comment"> * @key: key to match</span></span><br><span class="line"><span class="comment"> * @tree: tree to search</span></span><br><span class="line"><span class="comment"> * @cmp: operator defining node order</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns the leftmost node matching @key, or NULL.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> __always_inline <span class="keyword">struct</span> rb_node *</span><br><span class="line"><span class="title function_">rb_find_first</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *key, <span class="type">const</span> <span class="keyword">struct</span> rb_root *tree,</span></span><br><span class="line"><span class="params">          <span class="type">int</span> (*cmp)(<span class="type">const</span> <span class="type">void</span> *key, <span class="type">const</span> <span class="keyword">struct</span> rb_node *))</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">node</span> =</span> tree-&gt;rb_node;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">match</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (node) &#123;</span><br><span class="line">        <span class="type">int</span> c = cmp(key, node);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (c &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!c)</span><br><span class="line">                match = node;</span><br><span class="line">            node = node-&gt;rb_left;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            node = node-&gt;rb_right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> match;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>rb_for_each</code>通过<code>rb_find_first</code>与<code>rb_next_match</code>来遍历所有包含指定key的节点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> rb_for_each(node, key, tree, cmp) \</span></span><br><span class="line"><span class="meta">    for ((node) = rb_find_first((key), (tree), (cmp)); \</span></span><br><span class="line"><span class="meta">         (node); (node) = rb_next_match((key), (node), (cmp)))</span></span><br></pre></td></tr></table></figure></li></ul><p>如<a href="https://elixir.bootlin.com/linux/v5.15.155/source/kernel/sched/core.c#L199">&#x2F;kernel&#x2F;sched&#x2F;core.c</a>所示，其定义了<code>rb_sched_core_cmp</code>比较函数并作为函数指针传入了<code>rb_find_first</code>中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Find left-most (aka, highest priority) task matching @cookie.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> task_struct *<span class="title function_">sched_core_find</span><span class="params">(<span class="keyword">struct</span> rq *rq, <span class="type">unsigned</span> <span class="type">long</span> cookie)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">node</span>;</span></span><br><span class="line"></span><br><span class="line">node = rb_find_first((<span class="type">void</span> *)cookie, &amp;rq-&gt;core_tree, rb_sched_core_cmp);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The idle task always matches any cookie!</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (!node)</span><br><span class="line"><span class="keyword">return</span> idle_sched_class.pick_task(rq);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> __node_2_sc(node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">rb_sched_core_cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *key, <span class="type">const</span> <span class="keyword">struct</span> rb_node *node)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">p</span> =</span> __node_2_sc(node);</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> cookie = (<span class="type">unsigned</span> <span class="type">long</span>)key;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cookie &lt; p-&gt;core_cookie)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cookie &gt; p-&gt;core_cookie)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __node_2_sc(node) rb_entry((node), struct task_struct, core_node)</span></span><br></pre></td></tr></table></figure><p>第二种为不调用上述遍历函数，自己通过while循环实现遍历，如<a href="https://elixir.bootlin.com/linux/v5.15.155/source/mm/vmalloc.c#L824">&#x2F;mm&#x2F;vmalloc.c</a>所示。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">vmap_area</span> *__<span class="title">find_vmap_area</span>(<span class="title">unsigned</span> <span class="title">long</span> <span class="title">addr</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">n</span> =</span> vmap_area_root.rb_node;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (n) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vmap_area</span> *<span class="title">va</span>;</span></span><br><span class="line"></span><br><span class="line">va = rb_entry(n, <span class="keyword">struct</span> vmap_area, rb_node);</span><br><span class="line"><span class="keyword">if</span> (addr &lt; va-&gt;va_start)</span><br><span class="line">n = n-&gt;rb_left;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (addr &gt;= va-&gt;va_end)</span><br><span class="line">n = n-&gt;rb_right;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> va;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h3><ul><li><p><code>rb_replace_node</code> 是一个同步操作,它会直接修改红黑树的结构,并确保整个过程是原子性的。适用于单线程或者独占访问红黑树的情况,因为它可以快速完成节点替换。由于是同步操作,在高并发场景下可能会导致性能瓶颈。</p><p>  源码如下所示，victim为被替换的节点，new为需要替换的节点。首先找出victim的父节点，然后将victim节点的内容（颜色，父、儿子节点指针）复制到new中，将victim子节点的父节点指针指向new节点，最后调用<code>__rb_change_child</code>函数将parent的子节点指针指向的old替换为new。</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">rb_replace_node</span><span class="params">(<span class="keyword">struct</span> rb_node *victim, <span class="keyword">struct</span> rb_node *new,</span></span><br><span class="line"><span class="params">             <span class="keyword">struct</span> rb_root *root)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">parent</span> =</span> rb_parent(victim);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Copy the pointers/colour from the victim to the replacement */</span></span><br><span class="line">    *new = *victim;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set the surrounding nodes to point to the replacement */</span></span><br><span class="line">    <span class="keyword">if</span> (victim-&gt;rb_left)</span><br><span class="line">        rb_set_parent(victim-&gt;rb_left, new);</span><br><span class="line">    <span class="keyword">if</span> (victim-&gt;rb_right)</span><br><span class="line">        rb_set_parent(victim-&gt;rb_right, new);</span><br><span class="line">    __rb_change_child(victim, new, parent, root);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(rb_replace_node);</span><br></pre></td></tr></table></figure><p>  为了解决高并发场景下的性能瓶颈，linux内核提供了另一个替换函数：<code>rb_replace_node_rcu</code>。<code>rb_replace_node_rcu</code> 则是一种基于 RCU（Read-Copy-Update）机制的替换操作,它可以在不阻塞读取操作的情况下替换节点。</p></li><li><p><code>rb_replace_node_cached</code>是<code>rb_replace_node</code>的cached版本，其主要的功能是维护<code>rb_root_cached</code>结构体中的leftmost节点。其首先判断被替换的节点是否为leftmost节点，若是，则更新<code>rb_root_cached</code>结构体中的<code>rb_leftmost</code>变量，最后调用<code>rb_replace_node</code>，进行替换。</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">rb_replace_node_cached</span><span class="params">(<span class="keyword">struct</span> rb_node *victim,</span></span><br><span class="line"><span class="params">                      <span class="keyword">struct</span> rb_node *new,</span></span><br><span class="line"><span class="params">                      <span class="keyword">struct</span> rb_root_cached *root)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;rb_leftmost == victim)</span><br><span class="line">        root-&gt;rb_leftmost = new;</span><br><span class="line">    rb_replace_node(victim, new, &amp;root-&gt;rb_root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h3><p>红黑树中的旋转操作流程如下所示，代码中以兄弟节点为轴，向左旋转：</p><ol><li><p>以兄弟节点为轴；</p></li><li><p>调用两次<code>WRITE_ONCE</code>将父节点的右子节点替换为兄弟节点的左子节点，将兄弟节点的左子节点替换为父节点；</p></li><li><p>调用<code>rb_set_parent_color</code>将兄弟节点的左子节点的parent指针指向父节点，并染为黑色；</p></li><li><p>调用<code>__rb_rotate_set_parents</code>将兄弟节点的parent指针指向祖父节点并染成与父节点相同的颜色，将父节点的parent指针指向兄弟节点并染成红色，将祖父节点的子节点指针指向兄弟节点。</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*     P               S</span></span><br><span class="line"><span class="comment">*    / \             / \</span></span><br><span class="line"><span class="comment">*   N   s    --&gt;    p   Sr</span></span><br><span class="line"><span class="comment">*      / \         / \</span></span><br><span class="line"><span class="comment">*     Sl  Sr      N   Sl</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">tmp1 = sibling-&gt;rb_left;</span><br><span class="line">WRITE_ONCE(parent-&gt;rb_right, tmp1);</span><br><span class="line">WRITE_ONCE(sibling-&gt;rb_left, parent);</span><br><span class="line">rb_set_parent_color(tmp1, parent, RB_BLACK);</span><br><span class="line">__rb_rotate_set_parents(parent, sibling, root, RB_RED);</span><br></pre></td></tr></table></figure><p><code>__rb_rotate_set_parents</code>函数首先找到old节点的父节点parent，将old节点的父指针与颜色信息复制到new节点中，调用<code>rb_set_parent_color</code>将old节点的父指针指向new节点、颜色设置为<code>color</code>，最后调用<code>__rb_change_child</code>将parent的子节点指针指向的old替换为new。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span></span><br><span class="line">__rb_rotate_set_parents(<span class="keyword">struct</span> rb_node *old, <span class="keyword">struct</span> rb_node *new,</span><br><span class="line"><span class="keyword">struct</span> rb_root *root, <span class="type">int</span> color)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">parent</span> =</span> rb_parent(old);</span><br><span class="line">new-&gt;__rb_parent_color = old-&gt;__rb_parent_color;</span><br><span class="line">rb_set_parent_color(old, new, color);</span><br><span class="line">__rb_change_child(old, new, parent, root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><ul><li><p><code>rb_add</code>是在红黑树中插入节点的接口。首先调用while循环找到要插入的位置，调用<code>rb_link_node</code>将node节点插入红黑树中, 最后调用<code>rb_insert_color</code>对红黑树进行平衡。</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span></span><br><span class="line"><span class="title function_">rb_add</span><span class="params">(<span class="keyword">struct</span> rb_node *node, <span class="keyword">struct</span> rb_root *tree,</span></span><br><span class="line"><span class="params">       <span class="type">bool</span> (*less)(<span class="keyword">struct</span> rb_node *, <span class="type">const</span> <span class="keyword">struct</span> rb_node *))</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> **<span class="title">link</span> =</span> &amp;tree-&gt;rb_node;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">parent</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (*link) &#123;</span><br><span class="line">        parent = *link;</span><br><span class="line">        <span class="keyword">if</span> (less(node, parent))</span><br><span class="line">            link = &amp;parent-&gt;rb_left;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            link = &amp;parent-&gt;rb_right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    rb_link_node(node, parent, link);</span><br><span class="line">    rb_insert_color(node, tree);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <code>rb_insert_color</code>用于向插入节点添加颜色，其作为外部访问的接口, 调用内部的<code>__rb_inset</code>函数.</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">rb_insert_color</span><span class="params">(<span class="keyword">struct</span> rb_node *node, <span class="keyword">struct</span> rb_root *root)</span></span><br><span class="line">&#123;</span><br><span class="line">    __rb_insert(node, root, dummy_rotate);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(rb_insert_color);</span><br></pre></td></tr></table></figure></li><li><p><code>rb_add_cached</code>是rb_add的cached版本。首先调用while循环找到要插入的位置, 并判断插入节点是否为leftmost节点，调用<code>rb_link_node</code>将node节点插入红黑树中, 最后调用<code>rb_insert_color_cached</code>对红黑树进行平衡。</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __always_inline <span class="keyword">struct</span> rb_node *</span><br><span class="line"><span class="title function_">rb_add_cached</span><span class="params">(<span class="keyword">struct</span> rb_node *node, <span class="keyword">struct</span> rb_root_cached *tree,</span></span><br><span class="line"><span class="params">          <span class="type">bool</span> (*less)(<span class="keyword">struct</span> rb_node *, <span class="type">const</span> <span class="keyword">struct</span> rb_node *))</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> **<span class="title">link</span> =</span> &amp;tree-&gt;rb_root.rb_node;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">parent</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">bool</span> leftmost = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (*link) &#123;</span><br><span class="line">        parent = *link;</span><br><span class="line">        <span class="keyword">if</span> (less(node, parent)) &#123;</span><br><span class="line">            link = &amp;parent-&gt;rb_left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            link = &amp;parent-&gt;rb_right;</span><br><span class="line">            leftmost = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    rb_link_node(node, parent, link);</span><br><span class="line">    rb_insert_color_cached(node, tree, leftmost);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> leftmost ? node : <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <code>rb_insert_color_cached</code>是<code>rb_insert_color</code>的cached版本，其主要的功能是维护<code>rb_root_cached</code>结构体中的leftmost节点。其首先判断插入的节点是否为leftmost节点，若是，则更新<code>rb_root_cached</code>结构体中的<code>rb_leftmost</code>变量，最后调用<code>rb_insert_color</code>，进行插入。</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">rb_insert_color_cached</span><span class="params">(<span class="keyword">struct</span> rb_node *node,</span></span><br><span class="line"><span class="params">                      <span class="keyword">struct</span> rb_root_cached *root,</span></span><br><span class="line"><span class="params">                      <span class="type">bool</span> leftmost)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (leftmost)</span><br><span class="line">        root-&gt;rb_leftmost = node;</span><br><span class="line">    rb_insert_color(node, &amp;root-&gt;rb_root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><code>__rb_insert</code>是插入操作的主要函数，它的处理逻辑如下：</p><ul><li><p>若父节点为空, 则表明插入节点为根节点, 无需其他操作;</p></li><li><p>若父节点为黑色, 则无需其他操作直接插入;</p></li><li><p>若父节点为红色：</p><ul><li>父节点为祖父节点的左子节点<ul><li>插入节点为父节点的左子节点<ul><li>叔节点为红色，父叔变黑，祖父变红</li><li>叔节点为黑色，将子节点与父、祖父节点处于同意方向，父节点向叔节点方向进行旋转</li></ul></li><li>插入节点为父节点的右子节点<ul><li>叔节点为红色</li><li>叔节点为黑色</li></ul></li></ul></li><li>父节点为祖父节点的右子节点<ul><li>插入节点为父节点的右子节点<ul><li>叔节点为红色</li><li>叔节点为黑色</li></ul></li><li>插入节点为父节点的左子节点<ul><li>叔节点为红色</li><li>叔节点为黑色</li></ul></li></ul></li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span></span><br><span class="line">__rb_insert(<span class="keyword">struct</span> rb_node *node, <span class="keyword">struct</span> rb_root *root,</span><br><span class="line">    <span class="type">void</span> (*augment_rotate)(<span class="keyword">struct</span> rb_node *old, <span class="keyword">struct</span> rb_node *new))</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">parent</span> =</span> rb_red_parent(node), *gparent, *tmp;<span class="comment">//声明三个节点变量-parent,gparent,tmp</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"><span class="comment">//情况1：插入节点为根节点</span></span><br><span class="line"><span class="keyword">if</span> (unlikely(!parent)) &#123;</span><br><span class="line"></span><br><span class="line">rb_set_parent_color(node, <span class="literal">NULL</span>, RB_BLACK);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//情况2：插入节点的父节点为黑色</span></span><br><span class="line"><span class="keyword">if</span>(rb_is_black(parent))</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//情况3：插入节点的父节点为红色</span></span><br><span class="line">gparent = rb_red_parent(parent);</span><br><span class="line"></span><br><span class="line">tmp = gparent-&gt;rb_right;<span class="comment">//此时tmp为叔节点</span></span><br><span class="line"><span class="keyword">if</span> (parent != tmp) &#123;<span class="comment">//父节点为祖父节点的左子节点</span></span><br><span class="line"><span class="keyword">if</span> (tmp &amp;&amp; rb_is_red(tmp)) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Case 1 - 叔节点为红色</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *       G            g</span></span><br><span class="line"><span class="comment"> *      / \          / \</span></span><br><span class="line"><span class="comment"> *     p   u  --&gt;   P   U</span></span><br><span class="line"><span class="comment"> *    /            /</span></span><br><span class="line"><span class="comment"> *   n            n</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * However, since g&#x27;s parent might be red, and</span></span><br><span class="line"><span class="comment"> * 4) does not allow this, we need to recurse</span></span><br><span class="line"><span class="comment"> * at g.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">rb_set_parent_color(tmp, gparent, RB_BLACK);<span class="comment">//叔节点变为黑色</span></span><br><span class="line">rb_set_parent_color(parent, gparent, RB_BLACK);<span class="comment">//父节点变为黑色</span></span><br><span class="line">node = gparent;</span><br><span class="line">parent = rb_parent(node);</span><br><span class="line">rb_set_parent_color(node, parent, RB_RED);<span class="comment">//祖父节点变为红色</span></span><br><span class="line">                <span class="comment">//此时祖父节点为红色，其父节点可能也为红色，需要将node指向祖父节点继续循环处理</span></span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">            </span><br><span class="line">tmp = parent-&gt;rb_right;<span class="comment">//此时，tmp指向父节点的右子节点</span></span><br><span class="line"><span class="keyword">if</span> (node == tmp) &#123;<span class="comment">//判断插入节点是否为父节点的右子节点</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Case 2 - 叔节点为黑色，插入节点为父节点的右子节点</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      G             G</span></span><br><span class="line"><span class="comment"> *     / \           / \</span></span><br><span class="line"><span class="comment"> *    p   U  --&gt;    n   U</span></span><br><span class="line"><span class="comment"> *     \           /</span></span><br><span class="line"><span class="comment"> *      n         p</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 此时变成Case 3，进入Case 3的处理流程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">tmp = node-&gt;rb_left;<span class="comment">//此时，tmp指向子节点的左子节点</span></span><br><span class="line">                <span class="comment">//进行左旋操作</span></span><br><span class="line">WRITE_ONCE(parent-&gt;rb_right, tmp);</span><br><span class="line">WRITE_ONCE(node-&gt;rb_left, parent);</span><br><span class="line"><span class="keyword">if</span> (tmp)<span class="comment">//如果子节点的左子节点存在，则将其parent指针指向父节点，并变成黑色</span></span><br><span class="line">rb_set_parent_color(tmp, parent, RB_BLACK);</span><br><span class="line">rb_set_parent_color(parent, node, RB_RED);<span class="comment">//将父节点parent指针指向node，将parent染为红色</span></span><br><span class="line">augment_rotate(parent, node);<span class="comment">//调用rotate回调函数，增强型红黑树中才会使用</span></span><br><span class="line">parent = node;<span class="comment">//parent节点变为node</span></span><br><span class="line">tmp = node-&gt;rb_right;<span class="comment">//将tmp恢复为父节点的右子节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Case 3 - 叔节点为黑色，插入节点为父节点的左子节点</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *        G           P</span></span><br><span class="line"><span class="comment"> *       / \         / \</span></span><br><span class="line"><span class="comment"> *      p   U  --&gt;  n   g</span></span><br><span class="line"><span class="comment"> *     /                 \</span></span><br><span class="line"><span class="comment"> *    n                   U</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">           <span class="comment">//进行右旋操作</span></span><br><span class="line">WRITE_ONCE(gparent-&gt;rb_left, tmp);</span><br><span class="line">WRITE_ONCE(parent-&gt;rb_right, gparent);</span><br><span class="line"><span class="keyword">if</span> (tmp)<span class="comment">//如果父节点的右子节点存在，则将其父节点指针指向gparent，并变成黑色</span></span><br><span class="line">rb_set_parent_color(tmp, gparent, RB_BLACK);</span><br><span class="line">            <span class="comment">//将父节点的parent指针指向祖父节点的父节点，并染成祖父节点的颜色；将祖父节点的parent指针指向父节点，并染成红色</span></span><br><span class="line">__rb_rotate_set_parents(gparent, parent, root, RB_RED);</span><br><span class="line">augment_rotate(gparent, parent);<span class="comment">//调用rotate回调函数</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//父节点为祖父节点的右子节点的情况，与上述步骤类似，不重复描述</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><ul><li><p><code>rb_erase</code>调用<code>__rb_erase_augmented</code>将指定节点删除，并返回红黑树是否需要重新平衡。如果需要，则调用<code>____rb_erase_color</code>。在这里调用了增强版红黑树的接口<code>__rb_erase_augmented</code>，但由于传入的回调函数指针为dummy_rotate，因此体现不出增强性质。</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">rb_erase</span><span class="params">(<span class="keyword">struct</span> rb_node *node, <span class="keyword">struct</span> rb_root *root)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">rebalance</span>;</span></span><br><span class="line">    rebalance = __rb_erase_augmented(node, root, &amp;dummy_callbacks);</span><br><span class="line">    <span class="keyword">if</span> (rebalance)</span><br><span class="line">        ____rb_erase_color(rebalance, root, dummy_rotate);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(rb_erase);</span><br></pre></td></tr></table></figure></li><li><p><code>rb_erase_cached</code>为<code>rb_erase</code>的cached版本，其主要的功能是维护<code>rb_root_cached</code>结构体中的leftmost节点。其首先判断需要删除的节点是否为当前红黑树的leftmost节点，如果是，则调用<code>rb_next()</code>将leftmost节点更新为其后继节点，再调用<code>rb_erase</code>进行删除。</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> rb_node *</span><br><span class="line"><span class="title function_">rb_erase_cached</span><span class="params">(<span class="keyword">struct</span> rb_node *node, <span class="keyword">struct</span> rb_root_cached *root)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">leftmost</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (root-&gt;rb_leftmost == node)</span><br><span class="line">        leftmost = root-&gt;rb_leftmost = rb_next(node);</span><br><span class="line"></span><br><span class="line">    rb_erase(node, &amp;root-&gt;rb_root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><code>__rb_erase_color</code>调用<code>__rb_erase_color</code>函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Non-inline version for rb_erase_augmented() use */</span></span><br><span class="line"><span class="type">void</span> __rb_erase_color(<span class="keyword">struct</span> rb_node *parent, <span class="keyword">struct</span> rb_root *root,</span><br><span class="line"><span class="type">void</span> (*augment_rotate)(<span class="keyword">struct</span> rb_node *old, <span class="keyword">struct</span> rb_node *new))</span><br><span class="line">&#123;</span><br><span class="line">____rb_erase_color(parent, root, augment_rotate);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(__rb_erase_color);</span><br></pre></td></tr></table></figure><p><code>__rb_erase_color</code>是对删除后的节点进行染色的主要函数。其染色逻辑如下：</p><ul><li>兄弟节点为红：以父节点为轴，向左方向旋转，再进行染色；</li><li>兄弟节点为黑：<ul><li>兄弟节点的右子节点为黑：<ul><li>兄弟节点的左子节为黑：兄弟节点变红。若父节点为红，父节点变黑，完成染色；若父节点为黑，上移至祖父节点继续染色；</li><li>兄弟节点的左子节为红：以兄弟节点为轴，向右旋转，变为兄弟节点的右子节点为红的情况；</li></ul></li><li>兄弟节点的右子节点为红：兄弟节点变为父节点的颜色，父节点变黑，右子节点变黑，以父节点为轴，向左旋转。</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span></span><br><span class="line">____rb_erase_color(<span class="keyword">struct</span> rb_node *parent, <span class="keyword">struct</span> rb_root *root,</span><br><span class="line"><span class="type">void</span> (*augment_rotate)(<span class="keyword">struct</span> rb_node *old, <span class="keyword">struct</span> rb_node *new))</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">node</span> =</span> <span class="literal">NULL</span>, *sibling, *tmp1, *tmp2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Loop invariants:</span></span><br><span class="line"><span class="comment"> * - node is black (or NULL on first iteration)</span></span><br><span class="line"><span class="comment"> * - node is not the root (parent is not NULL)</span></span><br><span class="line"><span class="comment"> * - All leaf paths going through parent and node have a</span></span><br><span class="line"><span class="comment"> *   black node count that is 1 lower than other leaf paths.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">sibling = parent-&gt;rb_right;</span><br><span class="line"><span class="keyword">if</span> (node != sibling) &#123;<span class="comment">/* node为parent的左子节点 */</span></span><br><span class="line"><span class="keyword">if</span> (rb_is_red(sibling)) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Case 1 - 兄弟节点为红色，进行左旋</span></span><br><span class="line"><span class="comment"> * 小写字母代表红色，大写字母代表黑色</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     P               S</span></span><br><span class="line"><span class="comment"> *    / \             / \</span></span><br><span class="line"><span class="comment"> *   N   s    --&gt;    p   Sr</span></span><br><span class="line"><span class="comment"> *      / \         / \</span></span><br><span class="line"><span class="comment"> *     Sl  Sr      N   Sl</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">tmp1 = sibling-&gt;rb_left;</span><br><span class="line">WRITE_ONCE(parent-&gt;rb_right, tmp1);</span><br><span class="line">WRITE_ONCE(sibling-&gt;rb_left, parent);</span><br><span class="line">rb_set_parent_color(tmp1, parent, RB_BLACK);</span><br><span class="line">__rb_rotate_set_parents(parent, sibling, root,</span><br><span class="line">RB_RED);<span class="comment">//旋转后兄弟节点变为parent的颜色，parent变为红色，</span></span><br><span class="line">augment_rotate(parent, sibling);</span><br><span class="line">sibling = tmp1;<span class="comment">//旋转后变更兄弟节点，继续判断</span></span><br><span class="line">&#125;</span><br><span class="line">            <span class="comment">//兄弟节点为黑</span></span><br><span class="line">tmp1 = sibling-&gt;rb_right;</span><br><span class="line"><span class="keyword">if</span> (!tmp1 || rb_is_black(tmp1)) &#123;<span class="comment">//兄弟节点的右子节点为黑</span></span><br><span class="line">tmp2 = sibling-&gt;rb_left;</span><br><span class="line"><span class="keyword">if</span> (!tmp2 || rb_is_black(tmp2)) &#123;<span class="comment">//兄弟节点的左子节点为黑</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Case 2 - 兄弟节点为黑，子节点均为黑</span></span><br><span class="line"><span class="comment"> * 进行颜色翻转</span></span><br><span class="line"><span class="comment"> * (p)表示p可以为任意颜色</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *    (p)           (p)</span></span><br><span class="line"><span class="comment"> *    / \           / \</span></span><br><span class="line"><span class="comment"> *   N   S    --&gt;  N   s</span></span><br><span class="line"><span class="comment"> *      / \           / \</span></span><br><span class="line"><span class="comment"> *     Sl  Sr        Sl  Sr</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">rb_set_parent_color(sibling, parent, RB_RED); <span class="comment">//将兄弟节点变为红色</span></span><br><span class="line"><span class="keyword">if</span> (rb_is_red(parent))<span class="comment">//父节点为红，则将父节点变为黑色</span></span><br><span class="line">rb_set_black(parent);</span><br><span class="line"><span class="keyword">else</span> &#123;<span class="comment">//父节点为黑</span></span><br><span class="line">node = parent;</span><br><span class="line">parent = rb_parent(node);<span class="comment">//将父节点切换为祖父节点，继续进行判断</span></span><br><span class="line"><span class="keyword">if</span> (parent)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Case 3 - 兄弟节点为黑，左子节点为红，右子节点为黑</span></span><br><span class="line"><span class="comment"> * 以兄弟节点为轴右旋</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   (p)           (p)</span></span><br><span class="line"><span class="comment"> *   / \           / \</span></span><br><span class="line"><span class="comment"> *  N   S    --&gt;  N   sl</span></span><br><span class="line"><span class="comment"> *     / \             \</span></span><br><span class="line"><span class="comment"> *    sl  Sr            S</span></span><br><span class="line"><span class="comment"> *                       \</span></span><br><span class="line"><span class="comment"> *                        Sr</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">tmp1 = tmp2-&gt;rb_right;</span><br><span class="line">WRITE_ONCE(sibling-&gt;rb_left, tmp1);</span><br><span class="line">WRITE_ONCE(tmp2-&gt;rb_right, sibling);</span><br><span class="line">WRITE_ONCE(parent-&gt;rb_right, tmp2);</span><br><span class="line"><span class="keyword">if</span> (tmp1)</span><br><span class="line">rb_set_parent_color(tmp1, sibling,</span><br><span class="line">    RB_BLACK);</span><br><span class="line">augment_rotate(sibling, tmp2);</span><br><span class="line">tmp1 = sibling;</span><br><span class="line">sibling = tmp2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Case 4 - 兄弟节点为黑，右子节点为红，左子节点为任意颜色</span></span><br><span class="line"><span class="comment"> *以父节点为轴左旋 + 颜色翻转</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      (p)             (s)</span></span><br><span class="line"><span class="comment"> *      / \             / \</span></span><br><span class="line"><span class="comment"> *     N   S     --&gt;   P   Sr</span></span><br><span class="line"><span class="comment"> *        / \         / \</span></span><br><span class="line"><span class="comment"> *      (sl) sr      N  (sl)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">tmp2 = sibling-&gt;rb_left;</span><br><span class="line">WRITE_ONCE(parent-&gt;rb_right, tmp2);</span><br><span class="line">WRITE_ONCE(sibling-&gt;rb_left, parent);</span><br><span class="line">rb_set_parent_color(tmp1, sibling, RB_BLACK);</span><br><span class="line"><span class="keyword">if</span> (tmp2)</span><br><span class="line">rb_set_parent(tmp2, parent);</span><br><span class="line">__rb_rotate_set_parents(parent, sibling, root,</span><br><span class="line">RB_BLACK);</span><br><span class="line">augment_rotate(parent, sibling);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//父节点为祖父节点的右子节点的情况，与上述步骤类似，不重复描述</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="红黑树增强版"><a href="#红黑树增强版" class="headerlink" title="红黑树增强版"></a>红黑树增强版</h1><p>内核中的红黑树实现了增强的接口，称之为Augmented rbtrees。增强版红黑树在每个节点中存储了一些附加的数据，其中节点N的附加数据为以节点N为根节点的子树中所有节点内容的函数。想要使用增强版红黑树，在插入和删除结点时必须调用增强型接口并提供增强型回调函数。</p><ul><li><p>插入节点时，用户必须更新通往被插入节点的路径上的增强信息，然后像往常一样调用<code>rb_link_node()</code>。增强版插入接口是<code>rb_augment_inserted()</code>而不是平时的<code>rb_insert_color()</code>。如果 <code>rb_augment_inserted()</code>再平衡了红黑树，它将回调至一个用户提供的函数来更新受影响的子树上的增强信息。</p></li><li><p>删除节点时，用户必须调用<code>rb_erase_augmented()</code>而不是<code>rb_erase()</code>。 <code>rb_erase_augmented()</code>回调一个用户提供的函数来更新受影响的子树上的增强信息。</p></li></ul><p>在上述情况下，回调都是通过<code>rb_augment_callbacks</code>结构体提供的。增强版红黑树必须定义3个回调：</p><ul><li>一个传播回调propagate，它更新一个给定结点和它的祖先们的增强数据，直到一个给定的停止点 （如果是NULL，将更新一路更新到树根）。</li><li>一个复制回调copy，它将一颗给定子树的增强数据复制到一个新指定的子树树根。</li><li>一个树旋转回调rotate，它将一颗给定的子树的增强值复制到新指定的子树树根上，并重新计算 先前的子树树根的增强值。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rb_augment_callbacks</span> &#123;</span></span><br><span class="line">    <span class="type">void</span> (*propagate)(<span class="keyword">struct</span> rb_node *node, <span class="keyword">struct</span> rb_node *stop);</span><br><span class="line">    <span class="type">void</span> (*copy)(<span class="keyword">struct</span> rb_node *old, <span class="keyword">struct</span> rb_node *new);</span><br><span class="line">    <span class="type">void</span> (*rotate)(<span class="keyword">struct</span> rb_node *old, <span class="keyword">struct</span> rb_node *new);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="插入-1"><a href="#插入-1" class="headerlink" title="插入"></a>插入</h3><ul><li><p><code>rb_insert_augmented</code>调用<code>__rb_insert_augmented</code></p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">rb_insert_augmented</span><span class="params">(<span class="keyword">struct</span> rb_node *node, <span class="keyword">struct</span> rb_root *root,</span></span><br><span class="line"><span class="params">            <span class="type">const</span> <span class="keyword">struct</span> rb_augment_callbacks *augment)</span></span><br><span class="line">&#123;</span><br><span class="line">    __rb_insert_augmented(node, root, augment-&gt;rotate);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>rb_insert_augmented_cached</code>将插入节点替换为了rb_root_cached结构体中的rb_leftmost节点，即中序遍历中最小的点。</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">rb_insert_augmented_cached</span><span class="params">(<span class="keyword">struct</span> rb_node *node,</span></span><br><span class="line"><span class="params">               <span class="keyword">struct</span> rb_root_cached *root, <span class="type">bool</span> newleft,</span></span><br><span class="line"><span class="params">               <span class="type">const</span> <span class="keyword">struct</span> rb_augment_callbacks *augment)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (newleft)</span><br><span class="line">        root-&gt;rb_leftmost = node;</span><br><span class="line">    rb_insert_augmented(node, &amp;root-&gt;rb_root, augment);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><code>__rb_insert_augmented</code>调用了普通红黑树的插入操作<code>__rb_insert</code>，与普通红黑树插入操作不同的是，增强版插入用<code>augment_rotate</code>替代<code>dummy_rotate</code>作为回调函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __rb_insert_augmented(<span class="keyword">struct</span> rb_node *node, <span class="keyword">struct</span> rb_root *root,</span><br><span class="line"><span class="type">void</span> (*augment_rotate)(<span class="keyword">struct</span> rb_node *old, <span class="keyword">struct</span> rb_node *new))</span><br><span class="line">&#123;</span><br><span class="line">__rb_insert(node, root, augment_rotate);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h3><ul><li><p><code>rb_erase_augmented</code>首先调用<code>__rb_erase_augmented</code>函数删除节点，并返回是否需要重新平衡。若需要重新平衡，则调用<code>__rb_erase_color</code>函数。</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span></span><br><span class="line"><span class="title function_">rb_erase_augmented</span><span class="params">(<span class="keyword">struct</span> rb_node *node, <span class="keyword">struct</span> rb_root *root,</span></span><br><span class="line"><span class="params">           <span class="type">const</span> <span class="keyword">struct</span> rb_augment_callbacks *augment)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">rebalance</span> =</span> __rb_erase_augmented(node, root, augment);</span><br><span class="line">    <span class="keyword">if</span> (rebalance)</span><br><span class="line">        __rb_erase_color(rebalance, root, augment-&gt;rotate);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p><code>rb_erase_augmented_cached</code>是<code>rb_erase_augmented</code>的cached版本，使用<code>rb_root_cached</code>结构体来获取红黑树中key值最小的节点。</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span></span><br><span class="line"><span class="title function_">rb_erase_augmented_cached</span><span class="params">(<span class="keyword">struct</span> rb_node *node, <span class="keyword">struct</span> rb_root_cached *root,</span></span><br><span class="line"><span class="params">              <span class="type">const</span> <span class="keyword">struct</span> rb_augment_callbacks *augment)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;rb_leftmost == node)</span><br><span class="line">        root-&gt;rb_leftmost = rb_next(node);</span><br><span class="line">    rb_erase_augmented(node, &amp;root-&gt;rb_root, augment);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><code>__rb_erase_augmented</code>实现了指定节点的删除，其删除逻辑如下：</p><ul><li>若删除的节点没有子节点，直接删除，需要根据删除节点的颜色判断是否需要重新平衡红黑树；</li><li>若删除的节点只有一个子节点（其本身一定为黑，子节点一定为红），则直接用其子节点替代它本身，不需要重新平衡红黑树；</li><li>若删除的节点有两个子节点，则找出中序遍历顺序中它的后继节点并代替它本身，具体流程如下：<ul><li>若其右子节点没有左子节点，则直接用右子节点代替需要删除的节点；</li><li>若其右子节点有左子节点，则调用while循环找出右子树中的leftmost节点，用leftmost节点替换需要删除的节点。</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __always_inline <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *</span></span><br><span class="line"><span class="class">__<span class="title">rb_erase_augmented</span>(<span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">node</span>, <span class="keyword">struct</span> <span class="title">rb_root</span> *<span class="title">root</span>,</span></span><br><span class="line"><span class="class">     <span class="title">const</span> <span class="keyword">struct</span> <span class="title">rb_augment_callbacks</span> *<span class="title">augment</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">child</span> =</span> node-&gt;rb_right;<span class="comment">//删除节点的右子节点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">tmp</span> =</span> node-&gt;rb_left;<span class="comment">//删除节点的左子节点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">parent</span>, *<span class="title">rebalance</span>;</span><span class="comment">//parent为删除节点的父节点，rebalance为需要进行染色操作的节点</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> pc;<span class="comment">//parent_color</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!tmp) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * node只有一个右子节点或没有子节点</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果只有一个子节点，那子节点一定是红色的，他本身一定是黑色的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">pc = node-&gt;__rb_parent_color;</span><br><span class="line">parent = __rb_parent(pc);</span><br><span class="line">__rb_change_child(node, child, parent, root);</span><br><span class="line"><span class="keyword">if</span> (child) &#123;</span><br><span class="line">            <span class="comment">//存在右子节点，直接用右子节点替换其本身，不需要重新平衡</span></span><br><span class="line">child-&gt;__rb_parent_color = pc;</span><br><span class="line">rebalance = <span class="literal">NULL</span>;</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line">            <span class="comment">//没有子节点的情况。若删除节点为黑色，需要重新平衡；若为红色，不需要重新平衡</span></span><br><span class="line">rebalance = __rb_is_black(pc) ? parent : <span class="literal">NULL</span>;</span><br><span class="line">tmp = parent;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!child) &#123;</span><br><span class="line"><span class="comment">/* node只有一个左子节点 */</span></span><br><span class="line">tmp-&gt;__rb_parent_color = pc = node-&gt;__rb_parent_color;</span><br><span class="line">parent = __rb_parent(pc);</span><br><span class="line">__rb_change_child(node, tmp, parent, root);</span><br><span class="line">rebalance = <span class="literal">NULL</span>;</span><br><span class="line">tmp = parent;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* node有两个子节点， */</span></span><br><span class="line"><span class="keyword">struct</span> rb_node *successor = child, *child2;</span><br><span class="line"></span><br><span class="line">tmp = child-&gt;rb_left;</span><br><span class="line"><span class="keyword">if</span> (!tmp) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * node的后继节点为它的右子节点</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *    (n)          (s)</span></span><br><span class="line"><span class="comment"> *    / \          / \</span></span><br><span class="line"><span class="comment"> *  (x) (s)  -&gt;  (x) (c)</span></span><br><span class="line"><span class="comment"> *        \</span></span><br><span class="line"><span class="comment"> *        (c)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">parent = successor;</span><br><span class="line">child2 = successor-&gt;rb_right;</span><br><span class="line"></span><br><span class="line">augment-&gt;copy(node, successor);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * node的后继节点为右子树的leftmost节点</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *    (n)          (s)</span></span><br><span class="line"><span class="comment"> *    / \          / \</span></span><br><span class="line"><span class="comment"> *  (x) (y)  -&gt;  (x) (y)</span></span><br><span class="line"><span class="comment"> *      /            /</span></span><br><span class="line"><span class="comment"> *    (p)          (p)</span></span><br><span class="line"><span class="comment"> *    /            /</span></span><br><span class="line"><span class="comment"> *  (s)          (c)</span></span><br><span class="line"><span class="comment"> *    \</span></span><br><span class="line"><span class="comment"> *    (c)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">parent = successor;</span><br><span class="line">successor = tmp;</span><br><span class="line">tmp = tmp-&gt;rb_left;</span><br><span class="line">&#125; <span class="keyword">while</span> (tmp);<span class="comment">//找到右子树的leftmost节点</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//由于leftmost节点没有左子节点，因此直接用leftmost节点的右子节点替换它本身。</span></span><br><span class="line">child2 = successor-&gt;rb_right;</span><br><span class="line">WRITE_ONCE(parent-&gt;rb_left, child2);</span><br><span class="line">WRITE_ONCE(successor-&gt;rb_right, child);</span><br><span class="line">rb_set_parent(child, successor);</span><br><span class="line"></span><br><span class="line">augment-&gt;copy(node, successor);</span><br><span class="line">augment-&gt;propagate(parent, successor);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//用leftmost节点替换node节点</span></span><br><span class="line">tmp = node-&gt;rb_left;</span><br><span class="line">WRITE_ONCE(successor-&gt;rb_left, tmp);</span><br><span class="line">rb_set_parent(tmp, successor);</span><br><span class="line"></span><br><span class="line">pc = node-&gt;__rb_parent_color;</span><br><span class="line">tmp = __rb_parent(pc);</span><br><span class="line">__rb_change_child(node, successor, tmp, root);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (child2) &#123;</span><br><span class="line">            <span class="comment">//leftmost的右子节点存在，此时右子节点一定为红色，将右子节点染为黑色，不需要重新平衡红黑树</span></span><br><span class="line">rb_set_parent_color(child2, parent, RB_BLACK);</span><br><span class="line">rebalance = <span class="literal">NULL</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//leftmost的右子节点不存在，如果leftmost节点为黑色，需要重新平衡红黑树，如果为红色，则不需要。</span></span><br><span class="line">rebalance = rb_is_black(successor) ? parent : <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">successor-&gt;__rb_parent_color = pc;</span><br><span class="line">tmp = successor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//结束删除操作，调用propagate，函数返回。</span></span><br><span class="line">augment-&gt;propagate(tmp, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">return</span> rebalance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h3><p>一种增强型红黑树的使用案例为区间树（线段树），定义在<a href="/include/linux/interval_tree.h">&#x2F;include&#x2F;linux&#x2F;interval_tree.h</a>中。</p><p>区间树在内核中的使用场景有以下几个：</p><ul><li>mmu的管理—<a href="https://elixir.bootlin.com/linux/v5.15.155/source/include/linux/mmu_notifier.h#L258">mmu_interval_notifier</a></li><li>文件系统中的fuse与dax—<a href="https://elixir.bootlin.com/linux/v5.15.155/source/fs/fuse/dax.c#L44">fuse_dax_mapping</a></li></ul><p>经典的红黑树只有一个键，它不能直接用来存储像[lo:hi]这样的区间范围，也不能快速查找与新的[lo:hi]重叠的部分，或者查找是否有与新的[lo:hi]完全匹配的部分。</p><p>然而，内核通过增强型红黑树，以一种结构化的方式来存储这种区间范围，使得高效的查找和精确匹配成为可能。</p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h3 id="WRITE-ONCE"><a href="#WRITE-ONCE" class="headerlink" title="WRITE_ONCE"></a>WRITE_ONCE</h3><p><code>WRITE_ONCE</code> 是一个用于确保对变量进行一次性写操作的宏，是对volatile和内存屏障的封装。<code>WRITE_ONCE</code> 的用处是对变量赋值，它的目的是避免编译器优化对变量的写操作，从而确保写操作的有序性、原子性和可见性，特别是在多线程环境中。</p><p>编译器在优化代码的时候，会对一些操作进行重排序，或者删掉一些它认为无用的操作。这些优化在单线程的环境下不存在问题，但是对于操作系统而言，时刻都存在着并行的计算，这样的乱序处理很可能会造成问题。为了保证代码之间不乱序，我们可以使用<code>READ_ONCE()</code>和<code>WRITE_ONCE()</code>宏，告知编译器涉及到的操作之间不能乱序。</p><p><code>WRITE_ONCE</code>的宏定义位于&#x2F;tools&#x2F;include&#x2F;linux&#x2F;<a href="https://elixir.bootlin.com/linux/v5.15.155/source/tools/include/linux/compiler.h#L184">compiler.h</a>，其运行流程如下：</p><ol><li><p><code>(&#123; ... &#125;)</code>: 这是一个GNU扩展的语法块（statement expression），允许在块的最后返回一个值。这个语法在标准C中并不支持，但在GCC等编译器中是可以使用的。它是用于代替<code>do &#123; ... &#125; while (0)</code>表达式的。</p></li><li><p><code>union &#123; typeof(x) __val; char __c[1]; &#125; __u = &#123; .__val = (val) &#125;;</code>定义联合<code>__u</code>, 通过这种联合，可以在不改变底层数据的情况下，将 <code>__val</code> 解释成一个字符数组 <code>__c</code>。虽然数组长度为1，但它实际目的是指向联合的内存区域的起始位置，从而可以访问整个变量的字节。</p></li><li><p><code>__write_once_size</code>将 <code>__u.__c</code>（也就是 __val 按字节形式）写入到 x 的地址，并且写入的大小是 x 的大小。</p></li><li><p>最后，返回联合体中的 __val 成员的值，这样宏的返回值就是赋值后的 val。</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> WRITE_ONCE(x, val)\</span></span><br><span class="line"><span class="meta">(&#123;\</span></span><br><span class="line"><span class="meta">union &#123; typeof(x) __val; char __c[1]; &#125; __u =\</span></span><br><span class="line"><span class="meta">&#123; .__val = (val) &#125;; \</span></span><br><span class="line"><span class="meta">__write_once_size(&amp;(x), __u.__c, sizeof(x));\</span></span><br><span class="line"><span class="meta">__u.__val;\</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> __write_once_size(<span class="keyword">volatile</span> <span class="type">void</span> *p, <span class="type">void</span> *res, <span class="type">int</span> size)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">switch</span> (size) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>: *(<span class="keyword">volatile</span>  <span class="type">__u8_alias_t</span> *) p = *(<span class="type">__u8_alias_t</span>  *) res; <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>: *(<span class="keyword">volatile</span> <span class="type">__u16_alias_t</span> *) p = *(<span class="type">__u16_alias_t</span> *) res; <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>: *(<span class="keyword">volatile</span> <span class="type">__u32_alias_t</span> *) p = *(<span class="type">__u32_alias_t</span> *) res; <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">8</span>: *(<span class="keyword">volatile</span> <span class="type">__u64_alias_t</span> *) p = *(<span class="type">__u64_alias_t</span> *) res; <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">barrier();<span class="comment">//内存屏障函数 barrier()，防止编译器对内存操作进行重排序。</span></span><br><span class="line">__builtin_memcpy((<span class="type">void</span> *)p, (<span class="type">const</span> <span class="type">void</span> *)res, size);<span class="comment">//进行内存复制，将 res 指向的内容复制到 p 指向的地址</span></span><br><span class="line">barrier();<span class="comment">//再次调用内存屏障函数 barrier()，确保 memcpy 的操作不会被重排序。</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="RCU"><a href="#RCU" class="headerlink" title="RCU"></a>RCU</h3><p>上文替换操作中的<code>rb_replace_node()</code>函数是一个同步操作,它会直接修改红黑树的结构,并确保整个过程是原子性的。适用于单线程或者独占访问红黑树的情况,因为它可以快速完成节点替换。由于是同步操作,在高并发场景下可能会导致性能瓶颈。</p><p><code>rb_replace_node_rcu</code> 则是一种基于 RCU（Read-Copy-Update）机制的替换操作,它可以在不阻塞读取操作的情况下替换节点。适用于多线程并发访问红黑树的情况,它可以在不影响读取操作的情况下替换节点。由于引入了 RCU 机制,在高并发场景下性能会更好,但也增加了一定的复杂度。</p><p>RCU方法首先在新的位置插入新的节点,然后再将旧节点从树中删除。这样可以确保在删除旧节点之前,所有的读取操作都可以访问到正确的数据。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">rb_replace_node_rcu</span><span class="params">(<span class="keyword">struct</span> rb_node *victim, <span class="keyword">struct</span> rb_node *new,</span></span><br><span class="line"><span class="params"> <span class="keyword">struct</span> rb_root *root)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">parent</span> =</span> rb_parent(victim);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Copy the pointers/colour from the victim to the replacement */</span></span><br><span class="line">*new = *victim;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Set the surrounding nodes to point to the replacement */</span></span><br><span class="line"><span class="keyword">if</span> (victim-&gt;rb_left)</span><br><span class="line">rb_set_parent(victim-&gt;rb_left, new);</span><br><span class="line"><span class="keyword">if</span> (victim-&gt;rb_right)</span><br><span class="line">rb_set_parent(victim-&gt;rb_right, new);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Set the parent&#x27;s pointer to the new node last after an RCU barrier</span></span><br><span class="line"><span class="comment"> * so that the pointers onwards are seen to be set correctly when doing</span></span><br><span class="line"><span class="comment"> * an RCU walk over the tree.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">__rb_change_child_rcu(victim, new, parent, root);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(rb_replace_node_rcu);</span><br></pre></td></tr></table></figure><p><code>rb_replace_node()</code>和<code>rb_replace_node_rcu()</code>的差异在于<code>__rb_change_child()</code>和<code>__rb_change_child_rcu()</code>, 而<code>__rb_change_child()</code>与<code>__rb_change_child_rcu()</code>的差异在于<code>WRITE_ONCE</code>和<code>rcu_assign_pointer</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span></span><br><span class="line">__rb_change_child(<span class="keyword">struct</span> rb_node *old, <span class="keyword">struct</span> rb_node *new,</span><br><span class="line">  <span class="keyword">struct</span> rb_node *parent, <span class="keyword">struct</span> rb_root *root)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (parent) &#123;</span><br><span class="line"><span class="keyword">if</span> (parent-&gt;rb_left == old)</span><br><span class="line">WRITE_ONCE(parent-&gt;rb_left, new);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">WRITE_ONCE(parent-&gt;rb_right, new);</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line">WRITE_ONCE(root-&gt;rb_node, new);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span></span><br><span class="line">__rb_change_child_rcu(<span class="keyword">struct</span> rb_node *old, <span class="keyword">struct</span> rb_node *new,</span><br><span class="line">      <span class="keyword">struct</span> rb_node *parent, <span class="keyword">struct</span> rb_root *root)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (parent) &#123;</span><br><span class="line"><span class="keyword">if</span> (parent-&gt;rb_left == old)</span><br><span class="line">rcu_assign_pointer(parent-&gt;rb_left, new);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">rcu_assign_pointer(parent-&gt;rb_right, new);</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line">rcu_assign_pointer(root-&gt;rb_node, new);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>rcu_assign_pointer</code>的定义位于&#x2F;include&#x2F;linux&#x2F;<a href="https://elixir.bootlin.com/linux/v5.15.155/source/include/linux/rcupdate.h#L496">rcupdate.h</a>，用于将v复制到p指向的内存地址。</p><ol><li><code>do &#123; ... &#125; while (0)</code>: 使用 do … while (0) 结构包裹宏定义，以确保宏在使用时的语法一致性和安全性。</li><li><code>rcu_check_sparse(p, __rcu);</code>: 调用 rcu_check_sparse 函数（或宏），检查 p 是否是一个合法的 RCU 指针。这一步通常用于静态代码分析或编译期检查，以确保类型安全。</li><li><code>WRITE_ONCE((p), (typeof(p))(_r_a_p__v));</code>: 如果 v 是一个编译时常量且等于 NULL，则使用 WRITE_ONCE 宏将 _r_a_p__v 的值写入 p，确保写操作的原子性和可见性。</li><li><code>smp_store_release(&amp;p, RCU_INITIALIZER((typeof(p))_r_a_p__v));</code>: 使用 <code>smp_store_release</code> 函数（或内建函数）执行带有内存屏障的存储操作，将 <code>RCU_INITIALIZER((typeof(p))_r_a_p__v)</code> 的值写入 <code>p</code>。<ul><li><code>RCU_INITIALIZER((typeof(p))_r_a_p__v)</code>: 是一个宏或函数，用于初始化 RCU 指针，确保指针的正确性。</li><li><code>smp_store_release(&amp;p, ...)</code>: 确保存储操作在多处理器环境中是有序的，防止编译器和 CPU 重排序。</li></ul></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> rcu_assign_pointer(p, v)      \</span></span><br><span class="line"><span class="meta">do &#123;      \</span></span><br><span class="line"><span class="meta">uintptr_t _r_a_p__v = (uintptr_t)(v);      \</span></span><br><span class="line"><span class="meta">rcu_check_sparse(p, __rcu);      \</span></span><br><span class="line"><span class="meta">      \</span></span><br><span class="line"><span class="meta"><span class="keyword">if</span> (__builtin_constant_p(v) &amp;&amp; (_r_a_p__v) == (uintptr_t)NULL)      \</span></span><br><span class="line"><span class="meta">WRITE_ONCE((p), (typeof(p))(_r_a_p__v));      \</span></span><br><span class="line"><span class="meta"><span class="keyword">else</span>      \</span></span><br><span class="line"><span class="meta">smp_store_release(&amp;p, RCU_INITIALIZER((typeof(p))_r_a_p__v)); \</span></span><br><span class="line"><span class="meta">&#125; while (0)</span></span><br></pre></td></tr></table></figure><p>除<code>rb_replace_node()</code>外，<code>rb_link_node</code>函数也有RCU版本，rb_link_node直接对rb_link赋值node，而rb_link_node_rcu调用<code>rcu_assign_pointer</code>对rb_link进行赋值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">rb_link_node</span><span class="params">(<span class="keyword">struct</span> rb_node *node, <span class="keyword">struct</span> rb_node *parent,</span></span><br><span class="line"><span class="params"><span class="keyword">struct</span> rb_node **rb_link)</span></span><br><span class="line">&#123;</span><br><span class="line">node-&gt;__rb_parent_color = (<span class="type">unsigned</span> <span class="type">long</span>)parent;</span><br><span class="line">node-&gt;rb_left = node-&gt;rb_right = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">*rb_link = node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">rb_link_node_rcu</span><span class="params">(<span class="keyword">struct</span> rb_node *node, <span class="keyword">struct</span> rb_node *parent,</span></span><br><span class="line"><span class="params">    <span class="keyword">struct</span> rb_node **rb_link)</span></span><br><span class="line">&#123;</span><br><span class="line">node-&gt;__rb_parent_color = (<span class="type">unsigned</span> <span class="type">long</span>)parent;</span><br><span class="line">node-&gt;rb_left = node-&gt;rb_right = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">rcu_assign_pointer(*rb_link, node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="EXPORT-SYMBOL"><a href="#EXPORT-SYMBOL" class="headerlink" title="EXPORT_SYMBOL"></a>EXPORT_SYMBOL</h3><p><code>EXPORT_SYMBOL()</code>是宏定义，用于将内核符号导出到内核符号表中。<code>EXPORT_SYMBOL()</code> 定义的函数或者符号对全部内核代码公开，不用修改内核代码就可以在其它内核模块中直接调用，即使用 EXPORT_SYMBOL 可以将一个函数以符号的方式导出给其他模块使用。</p><p>其定义位于<a href="https://elixir.bootlin.com/linux/v5.15.155/source/include/linux/export.h">&#x2F;inclue&#x2F;linux&#x2F;export.h</a>中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> EXPORT_SYMBOL(sym)_EXPORT_SYMBOL(sym, <span class="string">&quot;&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _EXPORT_SYMBOL(sym, sec)__EXPORT_SYMBOL(sym, sec, <span class="string">&quot;&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ___EXPORT_SYMBOL(sym, sec, ns)\</span></span><br><span class="line"><span class="meta">extern typeof(sym) sym;\</span></span><br><span class="line"><span class="meta">extern const char __kstrtab_##sym[];\</span></span><br><span class="line"><span class="meta">extern const char __kstrtabns_##sym[];\</span></span><br><span class="line"><span class="meta">__CRC_SYMBOL(sym, sec);\</span></span><br><span class="line"><span class="meta">asm(<span class="string">&quot;.section \&quot;__ksymtab_strings\&quot;,\&quot;aMS\&quot;,%progbits,1\n&quot;</span>\</span></span><br><span class="line"><span class="meta">    <span class="string">&quot;__kstrtab_&quot;</span> #sym <span class="string">&quot;:\n&quot;</span>\</span></span><br><span class="line"><span class="meta">    <span class="string">&quot;.asciz \&quot;&quot;</span> #sym <span class="string">&quot;\&quot;\n&quot;</span>\</span></span><br><span class="line"><span class="meta">    <span class="string">&quot;__kstrtabns_&quot;</span> #sym <span class="string">&quot;:\n&quot;</span>\</span></span><br><span class="line"><span class="meta">    <span class="string">&quot;.asciz \&quot;&quot;</span> ns <span class="string">&quot;\&quot;\n&quot;</span>\</span></span><br><span class="line"><span class="meta">    <span class="string">&quot;.previous\n&quot;</span>);\</span></span><br><span class="line"><span class="meta">__KSYMTAB_ENTRY(sym, sec)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __KSYMTAB_ENTRY(sym, sec)\</span></span><br><span class="line"><span class="meta">static const struct kernel_symbol __ksymtab_##sym\</span></span><br><span class="line"><span class="meta">__attribute__((section(<span class="string">&quot;___ksymtab&quot;</span> sec <span class="string">&quot;+&quot;</span> #sym), used))\</span></span><br><span class="line"><span class="meta">__aligned(sizeof(void *))\</span></span><br><span class="line"><span class="meta">= &#123; (unsigned long)&amp;sym, __kstrtab_##sym, __kstrtabns_##sym &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kernel_symbol</span> &#123;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> value;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *namespace;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://github.com/torvalds/linux/blob/master/Documentation/core-api/rbtree.rst">Linux rbtree document</a></p><p><a href="https://www.kernel.org/doc/html/latest/translations/zh_CN/core-api/rbtree.html">Linux rbtree document（中文）</a></p><p><a href="https://linux.laoqinren.net/posts/rbtree-linux-kernel/">红黑树(二)——linux 内核的设计实现</a></p><p><a href="https://www.cnblogs.com/theseventhson/p/15848260.html">红黑树在内核的应用——timer定时器</a></p><p><a href="https://www.cnblogs.com/wicub/p/6031093.html">do{…}while(0)的意义和用法</a></p><p><a href="https://cloud.tencent.com/developer/article/1801450">WRITE_ONCE与volatile</a></p><p><a href="https://github.com/google/kernel-sanitizers/blob/master/other/READ_WRITE_ONCE.md">Why kernel code should use READ_ONCE and WRITE_ONCE for shared memory accesses</a></p><p><a href="https://oi-wiki.org/ds/seg/">OI-wiki线段树</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Linux中有着大量的红黑树的应用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;进程调度—&lt;a href=&quot;https://elixir.bootlin.com/linux/v5.15.155/source/include/linux/sched.h#L527&quot;&gt;CFS完全公平调度&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>uboot加载linux内核与设备树机制的探索</title>
    <link href="https://big7ng.github.io/2024/05/15/uboot_booti/"/>
    <id>https://big7ng.github.io/2024/05/15/uboot_booti/</id>
    <published>2024-05-14T16:03:15.311Z</published>
    <updated>2024-05-14T16:05:38.438Z</updated>
    
    <content type="html"><![CDATA[<p>在重新编译Linux内核与设备树后，需要使用uboot加载新的内核与设备树。<br>开发板启动后，进入uboot命令行，执行以下命令：</p><p>设置环境变量<code>bootargs</code>启动参数：</p><ul><li>console&#x3D;ttyAMA1,115200：指定了控制台输出设备为ttyAMA1，波特率为115200。这意味着内核将在ttyAMA1上输出调试信息和控制台输入。</li><li>earlycon&#x3D;pl011,0x2800d000：指定了早期控制台设备为pl011，基地址为0x2800d000。早期控制台用于在内核初始化期间提供调试信息。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setenv bootargs &#x27;console=ttyAMA1,115200 earlycon=pl011,0x2800d000 root=/dev/mmcblk0p1 rootwait rw&#x27;</span><br></pre></td></tr></table></figure><p>加载内核至指定内存地址<code>0x90100000</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ext4load mmc 0:1 0x90100000 boot/Image</span><br></pre></td></tr></table></figure><p>加载设备树至指定内存地址<code>0x90000000</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ext4load mmc 0:1 0x90000000 boot/phytiumpi_firefly.dtb</span><br></pre></td></tr></table></figure><p>开始引导Linux系统，其中的<code>-</code>表明不使用initial RAM disk来启动内核，booti命令的使用细节可以参考<a href="https://docs.u-boot.org/en/latest/usage/cmd/booti.html">uboot官方文档</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">booti 0x90100000 - 0x90000000</span><br></pre></td></tr></table></figure><p>若需要在每次开机时uboot自动执行以上命令，可以设置uboot中的<code>bootcmd</code>环境变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setenv bootcmd &#x27;ext4load mmc 0:1 0x90100000 boot/Image; ext4load mmc 0:1 0x90000000 boot/phytiumpi_firefly.dtb; booti 0x90100000 - 0x90000000&#x27;</span><br></pre></td></tr></table></figure><p>上述操作过程引发了很多疑惑：0x90100000、0x90000000和0x2800d000这个地址是怎么来的呢？pl011是什么东西？内核与设备树加载到了两块地址上，那内核是如何获取设备树信息的呢？</p><h1 id="uboot中使用的地址"><a href="#uboot中使用的地址" class="headerlink" title="uboot中使用的地址"></a>uboot中使用的地址</h1><h3 id="0x2800d000"><a href="#0x2800d000" class="headerlink" title="0x2800d000"></a>0x2800d000</h3><p>首先是0x2800d000这个地址，通过查阅phytiumpi开发板的设备树文件，在pe220x.dtsi这个文件中找到了相关的信息，0x2800d000是uart1的映射地址。 </p><p>为什么是这个地址？查阅飞腾派芯片手册，0x000_2800_0000 ~ 0x000_2FFF_FFFF这块地址空间分配给了低速设备。</p><p>其中0x000_2800_D000 ~ 0x000_2800_DFFF 的4KB地址空间分配给了UART1。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">uart1: uart@2800d000 &#123;</span><br><span class="line">compatible = &quot;arm,pl011&quot;,&quot;arm,primecell&quot;;</span><br><span class="line">reg = &lt;0x0 0x2800d000 0x0 0x1000&gt;;</span><br><span class="line">interrupts = &lt;GIC_SPI 84 IRQ_TYPE_LEVEL_HIGH&gt;;</span><br><span class="line">clocks = &lt;&amp;sysclk_100mhz &amp;sysclk_100mhz&gt;;</span><br><span class="line">clock-names = &quot;uartclk&quot;, &quot;apb_pclk&quot;;</span><br><span class="line">status = &quot;disabled&quot;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>不同的开发板有不同的设备树，因此这个地址是因设备的变化而变化的。</p><p>PL011指PrimeCell UART，是ARM公司设计的UART IP核，具体的文档可以在<a href="https://developer.arm.com/documentation/ddi0183/g/">ARM官网</a>查看。</p><h3 id="0x90100000与0x90000000"><a href="#0x90100000与0x90000000" class="headerlink" title="0x90100000与0x90000000"></a>0x90100000与0x90000000</h3><p>在飞腾派中，0x000_8000_0000 ~ 0x000_FFFF_FFFF地址空间分配为Memory 空间，0x90100000与0x90000000均位于其中。</p><p>根据booti命令的参数，0x90000000为设备树的加载地址，0x90100000为Linux内核的加载地址。编译后的dtb大小为24.5KB，未压缩的内核大小为23.5MB，地址0x90000000与0x90100000之间的空间约为1048KB，足够设备树文件加载。经过查阅uboot源码，这两个地址是在移植uboot时进行设置的。</p><p>由于没有飞腾派移植uboot的源码，这里先展示以下rk3588的案例，<code>u-boot/include/configs/rk3588_common.h</code>中有如下配置：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ENV_MEM_LAYOUT_SETTINGS\</span></span><br><span class="line"><span class="meta"><span class="string">&quot;scriptaddr=0x00c00000\0&quot;</span>\</span></span><br><span class="line"><span class="meta"><span class="string">&quot;script_offset_f=0xffe000\0&quot;</span>\</span></span><br><span class="line"><span class="meta"><span class="string">&quot;script_size_f=0x2000\0&quot;</span>\</span></span><br><span class="line"><span class="meta"><span class="string">&quot;pxefile_addr_r=0x00e00000\0&quot;</span>\</span></span><br><span class="line"><span class="meta"><span class="string">&quot;kernel_addr_r=0x02000000\0&quot;</span>\</span></span><br><span class="line"><span class="meta"><span class="string">&quot;kernel_comp_addr_r=0x0a000000\0&quot;</span>\</span></span><br><span class="line"><span class="meta"><span class="string">&quot;fdt_addr_r=0x12000000\0&quot;</span>\</span></span><br><span class="line"><span class="meta"><span class="string">&quot;fdtoverlay_addr_r=0x12100000\0&quot;</span>\</span></span><br><span class="line"><span class="meta"><span class="string">&quot;ramdisk_addr_r=0x12180000\0&quot;</span>\</span></span><br><span class="line"><span class="meta"><span class="string">&quot;kernel_comp_size=0x8000000\0&quot;</span></span></span><br></pre></td></tr></table></figure><p>可以看从中看出，内核加载地址为0x02000000，设备树加载地址为0x12000000。因此这部分地址也是根据不同的芯片而改变的。</p><h3 id="booti-bootz与bootm"><a href="#booti-bootz与bootm" class="headerlink" title="booti,bootz与bootm"></a>booti,bootz与bootm</h3><p>uboot能启动的内核格式：Image, zImage, uImage, fdt方式。</p><p>uboot提供了三种命令来启动内核：<a href="https://docs.u-boot.org/en/latest/usage/cmd/booti.html">booti</a>, <a href="https://docs.u-boot.org/en/latest/usage/cmd/bootz.html">bootz</a>, <a href="https://docs.u-boot.org/en/latest/usage/cmd/bootm.html">bootm</a>三个命令，分别用于对应Image, zImage, ulmage&#x2F;FIT三种内核格式:</p><ul><li>Image: 内核的原始烧录镜像文件, 也可以对他进行压缩, 根据不同的压缩算法有不同的文件名, gzip算法为Image.gz.</li><li>zImage: 压缩后的内核烧录镜像文件, 采用的是自压缩算法(不需要额外的解压器).</li><li>uImage:  这是uboot提供的一种内核Wrapper, 包含了内核烧录镜像与其他信息。由于uImage存在很大限制与安全隐患, 已不被官方支持, 现称其为legacy image format。</li><li><a href="https://docs.u-boot.org/en/latest/usage/fit/index.html">FIT</a>: Flat Image Tree (FIT)是最新的uImage文件, 为了更好的支持单个固件的通用性，类似于kernel device tree机制，uboot也需要对这种uImage固件进行支持。FIT uImage中加入多个dtb文件，和ramdisak文件，当然如果需要的话，同样可以支持多个kernel文件。这样的目的就是能够使同一个uImage就能够在uboot中选择特定的kernel&#x2F;dtb和ramdisk进行启动了，达成一个uImage可以通用多个板型的目的。</li></ul><h1 id="Boot流程分析"><a href="#Boot流程分析" class="headerlink" title="Boot流程分析"></a>Boot流程分析</h1><h3 id="uboot是如何引导Boot-image的？"><a href="#uboot是如何引导Boot-image的？" class="headerlink" title="uboot是如何引导Boot image的？"></a>uboot是如何引导Boot image的？</h3><p>接下来将对uboot源码进行分析，最新以及历史的uboot源码可以在Bootlin的Elixir Cross Referencer中<a href="https://elixir.bootlin.com/u-boot/latest/source">查看</a>。</p><p>Boot流程主要用了两个结构体：bootm_info与bootm_headers，定义均位于<a href="https://elixir.bootlin.com/u-boot/latest/source">&#x2F;</a><a href="https://elixir.bootlin.com/u-boot/latest/source/include">include</a>&#x2F;<a href="https://elixir.bootlin.com/u-boot/latest/source/include/bootm.h">bootm.h</a>文件中。</p><p>bootm_info结构体用于存储Boot系统所需的信息：镜像地址、ramdisk地址、fdt设备树地址等。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bootm_info</span> &#123;</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *addr_img;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *conf_ramdisk;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *conf_fdt;</span><br><span class="line"><span class="type">bool</span> boot_progress;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bootm_headers</span> *<span class="title">images</span>;</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *cmd_name;</span><br><span class="line"><span class="type">int</span> argc;</span><br><span class="line"><span class="type">char</span> *<span class="type">const</span> *argv;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>bootm_headers记录了image镜像的具体信息。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Legacy and FIT format headers used by do_bootm() and do_bootm_&lt;os&gt;() routines.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bootm_headers</span> &#123;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Legacy os image header, if it is a multi component image</span></span><br><span class="line"><span class="comment"> * then boot_get_ramdisk() and get_fdt() will attempt to get</span></span><br><span class="line"><span class="comment"> * data from second and third component accordingly.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">legacy_img_hdr</span>*<span class="title">legacy_hdr_os</span>;</span><span class="comment">/* image header pointer */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">legacy_img_hdr</span><span class="title">legacy_hdr_os_copy</span>;</span><span class="comment">/* header copy */</span></span><br><span class="line">ulonglegacy_hdr_valid;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The fit_ members are only used with FIT, but it involves a lot of</span></span><br><span class="line"><span class="comment"> * #ifdefs to avoid compiling that code. Since FIT is the standard</span></span><br><span class="line"><span class="comment"> * format, even for SPL, this extra data size seems worth it.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>*fit_uname_cfg;<span class="comment">/* configuration node unit name */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>*fit_hdr_os;<span class="comment">/* os FIT image header */</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>*fit_uname_os;<span class="comment">/* os subimage node unit name */</span></span><br><span class="line"><span class="type">int</span>fit_noffset_os;<span class="comment">/* os subimage node offset */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>*fit_hdr_rd;<span class="comment">/* init ramdisk FIT image header */</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>*fit_uname_rd;<span class="comment">/* init ramdisk subimage node unit name */</span></span><br><span class="line"><span class="type">int</span>fit_noffset_rd;<span class="comment">/* init ramdisk subimage node offset */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>*fit_hdr_fdt;<span class="comment">/* FDT blob FIT image header */</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>*fit_uname_fdt;<span class="comment">/* FDT blob subimage node unit name */</span></span><br><span class="line"><span class="type">int</span>fit_noffset_fdt;<span class="comment">/* FDT blob subimage node offset */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>*fit_hdr_setup;<span class="comment">/* x86 setup FIT image header */</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>*fit_uname_setup; <span class="comment">/* x86 setup subimage node name */</span></span><br><span class="line"><span class="type">int</span>fit_noffset_setup;<span class="comment">/* x86 setup subimage node offset */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> USE_HOSTCC</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">image_info</span><span class="title">os</span>;</span><span class="comment">/* os image info */</span></span><br><span class="line">ulongep;<span class="comment">/* entry point of OS */</span></span><br><span class="line"></span><br><span class="line">ulongrd_start, rd_end;<span class="comment">/* ramdisk start/end */</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span>*ft_addr;<span class="comment">/* flat dev tree address */</span></span><br><span class="line">ulongft_len;<span class="comment">/* length of flat device tree */</span></span><br><span class="line"></span><br><span class="line">ulonginitrd_start;</span><br><span class="line">ulonginitrd_end;</span><br><span class="line">ulongcmdline_start;</span><br><span class="line">ulongcmdline_end;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bd_info</span>*<span class="title">kbd</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span>verify;<span class="comment">/* env_get(&quot;verify&quot;)[0] != &#x27;n&#x27; */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BOOTM_STATE_START0x00000001</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BOOTM_STATE_FINDOS0x00000002</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BOOTM_STATE_FINDOTHER0x00000004</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BOOTM_STATE_LOADOS0x00000008</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BOOTM_STATE_RAMDISK0x00000010</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BOOTM_STATE_FDT0x00000020</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BOOTM_STATE_OS_CMDLINE0x00000040</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BOOTM_STATE_OS_BD_T0x00000080</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BOOTM_STATE_OS_PREP0x00000100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BOOTM_STATE_OS_FAKE_GO0x00000200<span class="comment">/* &#x27;Almost&#x27; run the OS */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BOOTM_STATE_OS_GO0x00000400</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BOOTM_STATE_PRE_LOAD0x00000800</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BOOTM_STATE_MEASURE0x00001000</span></span><br><span class="line"><span class="type">int</span>state;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_LMB) &amp;&amp; !defined(USE_HOSTCC)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">lmb</span><span class="title">lmb</span>;</span><span class="comment">/* for memory mgmt */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>本文使用了<code>booti</code>命令来启动内核，命令源码<a href="https://github.com/u-boot/u-boot/blob/master/cmd/booti.c">uboot&#x2F;cmd&#x2F;booti.c</a>文件中。当在uboot命令行中输入<code>booti</code>时，调用了<code>do_booti</code>函数。</p><p>do_booti主要进行了如下操作：</p><ol><li>初始化bootm_info结构体, 其中调用了<code>bootm_init</code>函数;</li><li>调用<code>booti_start</code>函数加载image镜像至内存中；</li><li>关闭中断, 调用<code>bootm_run_states</code>函数启动Linux系统, <code>bootm_run_states</code>函数根据不同的state参数进行不同的操作。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">do_booti</span><span class="params">(<span class="keyword">struct</span> cmd_tbl *cmdtp, <span class="type">int</span> flag, <span class="type">int</span> argc, <span class="type">char</span> *<span class="type">const</span> argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bootm_info</span> <span class="title">bmi</span>;</span></span><br><span class="line"><span class="type">int</span> states;</span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Consume &#x27;booti&#x27; */</span></span><br><span class="line">argc--; argv++;</span><br><span class="line"></span><br><span class="line">bootm_init(&amp;bmi);<span class="comment">//初始化bmi结构体，设置为空</span></span><br><span class="line"><span class="keyword">if</span> (argc)</span><br><span class="line">bmi.addr_img = argv[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">if</span> (argc &gt; <span class="number">1</span>)</span><br><span class="line">bmi.conf_ramdisk = argv[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span> (argc &gt; <span class="number">2</span>)</span><br><span class="line">bmi.conf_fdt = argv[<span class="number">2</span>];</span><br><span class="line">bmi.boot_progress = <span class="literal">true</span>;</span><br><span class="line">bmi.cmd_name = <span class="string">&quot;booti&quot;</span>;</span><br><span class="line"><span class="comment">/* do not set up argc and argv[] since nothing uses them */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (booti_start(&amp;bmi))<span class="comment">//booti_start运行成功，返回0</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * We are doing the BOOTM_STATE_LOADOS state ourselves, so must</span></span><br><span class="line"><span class="comment"> * disable interrupts ourselves</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">bootm_disable_interrupts();</span><br><span class="line"></span><br><span class="line">images.os.os = IH_OS_LINUX;<span class="comment">//启动镜像类型</span></span><br><span class="line"><span class="keyword">if</span> (IS_ENABLED(CONFIG_RISCV_SMODE))</span><br><span class="line">images.os.arch = IH_ARCH_RISCV;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (IS_ENABLED(CONFIG_ARM64))</span><br><span class="line">images.os.arch = IH_ARCH_ARM64;<span class="comment">//选择启动镜像架构</span></span><br><span class="line"></span><br><span class="line">states = BOOTM_STATE_MEASURE | BOOTM_STATE_OS_PREP |</span><br><span class="line">BOOTM_STATE_OS_FAKE_GO | BOOTM_STATE_OS_GO;</span><br><span class="line"><span class="keyword">if</span> (IS_ENABLED(CONFIG_SYS_BOOT_RAMDISK_HIGH))</span><br><span class="line">states |= BOOTM_STATE_RAMDISK;</span><br><span class="line"></span><br><span class="line">ret = bootm_run_states(&amp;bmi, states);<span class="comment">//启动Linux系统</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>booti_start函数进行了如下操作:</p><ol><li><p>调用<code>bootm_run_states</code>函数, state参数设置为<code>BOOTM_STATE_START</code>, 执行<code>bootm_start</code>函数,初始化bootm_header结构体;</p></li><li><p>调用<code>image_decomp_type</code>检测image镜像是否被压缩, 若被压缩则进行解压;</p></li><li><p>调用<code>booti_setup</code>函数检测image镜像是否正确，返回Linux aarch64 Image的起始地址和大小;</p></li><li><p>调用<code>bootm_find_images</code>函数检测image镜像是否加载正确.</p></li></ol><p>综上, booti_start函数作用为配置并加载image镜像。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">booti_start</span><span class="params">(<span class="keyword">struct</span> bootm_info *bmi)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bootm_headers</span> *<span class="title">images</span> =</span> bmi-&gt;images;</span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line">ulong ld;</span><br><span class="line">ulong relocated_addr;</span><br><span class="line">ulong image_size;</span><br><span class="line"><span class="type">uint8_t</span> *temp;</span><br><span class="line">ulong dest;</span><br><span class="line">ulong dest_end;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> comp_len;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> decomp_len;</span><br><span class="line"><span class="type">int</span> ctype;</span><br><span class="line"></span><br><span class="line">ret = bootm_run_states(bmi, BOOTM_STATE_START);<span class="comment">//初始化</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Setup Linux kernel Image entry point */</span></span><br><span class="line"><span class="keyword">if</span> (!bmi-&gt;addr_img) &#123;</span><br><span class="line">ld = image_load_addr;</span><br><span class="line">debug(<span class="string">&quot;*  kernel: default image load address = 0x%08lx\n&quot;</span>,</span><br><span class="line">image_load_addr);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">ld = hextoul(bmi-&gt;addr_img, <span class="literal">NULL</span>);</span><br><span class="line">debug(<span class="string">&quot;*  kernel: cmdline image address = 0x%08lx\n&quot;</span>, ld);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">temp = map_sysmem(ld, <span class="number">0</span>);</span><br><span class="line">ctype = image_decomp_type(temp, <span class="number">2</span>); <span class="comment">//返回镜像的压缩类型，0表示未压缩</span></span><br><span class="line"><span class="keyword">if</span> (ctype &gt; <span class="number">0</span>) &#123;</span><br><span class="line">dest = env_get_ulong(<span class="string">&quot;kernel_comp_addr_r&quot;</span>, <span class="number">16</span>, <span class="number">0</span>);</span><br><span class="line">comp_len = env_get_ulong(<span class="string">&quot;kernel_comp_size&quot;</span>, <span class="number">16</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (!dest || !comp_len) &#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;kernel_comp_addr_r or kernel_comp_size is not provided!\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (dest &lt; gd-&gt;ram_base || dest &gt; gd-&gt;ram_top) &#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;kernel_comp_addr_r is outside of DRAM range!\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">debug(<span class="string">&quot;kernel image compression type %d size = 0x%08lx address = 0x%08lx\n&quot;</span>,</span><br><span class="line">ctype, comp_len, (ulong)dest);</span><br><span class="line">decomp_len = comp_len * <span class="number">10</span>;</span><br><span class="line">ret = image_decomp(ctype, <span class="number">0</span>, ld, IH_TYPE_KERNEL,</span><br><span class="line"> (<span class="type">void</span> *)dest, (<span class="type">void</span> *)ld, comp_len,</span><br><span class="line"> decomp_len, &amp;dest_end);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line"><span class="comment">/* dest_end contains the uncompressed Image size */</span></span><br><span class="line">memmove((<span class="type">void</span> *) ld, (<span class="type">void</span> *)dest, dest_end);</span><br><span class="line">&#125;</span><br><span class="line">unmap_sysmem((<span class="type">void</span> *)ld);</span><br><span class="line"></span><br><span class="line">ret = booti_setup(ld, &amp;relocated_addr, &amp;image_size, <span class="literal">false</span>);<span class="comment">//检测image地址和大小是否正确，0表示正确</span></span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Handle BOOTM_STATE_LOADOS */</span></span><br><span class="line"><span class="keyword">if</span> (relocated_addr != ld) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Moving Image from 0x%lx to 0x%lx, end=%lx\n&quot;</span>, ld,</span><br><span class="line">       relocated_addr, relocated_addr + image_size);</span><br><span class="line">memmove((<span class="type">void</span> *)relocated_addr, (<span class="type">void</span> *)ld, image_size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">images-&gt;ep = relocated_addr;</span><br><span class="line">images-&gt;os.start = relocated_addr;</span><br><span class="line">images-&gt;os.end = relocated_addr + image_size;</span><br><span class="line"></span><br><span class="line">lmb_reserve(&amp;images-&gt;lmb, images-&gt;ep, le32_to_cpu(image_size));</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Handle the BOOTM_STATE_FINDOTHER state ourselves as we do not</span></span><br><span class="line"><span class="comment"> * have a header that provide this informaiton.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (bootm_find_images(image_load_addr, bmi-&gt;conf_ramdisk, bmi-&gt;conf_fdt,</span><br><span class="line">      relocated_addr, image_size))<span class="comment">//加载image、ramdisk、fdt，如果加载成功，返回0</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>do_booti</code>最后一步调用<code>bootm_run_states</code>时states参数设置为BOOTM_STATE_MEASURE | BOOTM_STATE_OS_PREP |BOOTM_STATE_OS_FAKE_GO | BOOTM_STATE_OS_GO, <code>bootm_run_states</code>进行了如下操作:</p><ol><li>调用<code>bootm_measure</code>函数, 对image镜像进行测量（进行哈希处理并存储到安全内存（例如TPM PCR）的过程），用于安全认证；</li><li>调用<code>boot_fn = bootm_os_get_boot_func(images-&gt;os.os)</code>， 获取启动特定操作系统的函数指针（这里是Linux），结构体参数 images-&gt;os.os 就是系统类型，根据这个系统类型来选择对应的启动函数，在 do_booti 中设置了 images.os.os&#x3D; IH_OS_LINUX。函数返回值就是找到的系统启动函数，这里找到的 Linux 系统启动函数为 do_bootm_linux。因此 boot_fn&#x3D;<code>do_bootm_linux</code>，后面执行 boot_fn 函数的地方实际上是执行的 do_bootm_linux 函数；</li><li>调用boot_fn(BOOTM_STATE_OS_PREP, bmi)，进行启动image前的一些初始化工作，boot_prep_linux 主要用于处理环境变量 bootargs，bootargs 保存着传递给 Linux kernel 的参数；</li><li>boot_selected_os(BOOTM_STATE_OS_FAKE_GO, bmi, boot_fn)，<a href="https://patchwork.ozlabs.org/project/uboot/patch/1370974493-21822-17-git-send-email-sjg@chromium.org/">fake go</a>用于完成执行跳转到OS image前的初始化，这个步骤用于保证能够追踪trace uboot系统记录直至最后一刻；</li><li>最后一步，调用boot_selected_os(BOOTM_STATE_OS_GO, bmi, boot_fn)函数，启动操作系统。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">bootm_run_states</span><span class="params">(<span class="keyword">struct</span> bootm_info *bmi, <span class="type">int</span> states)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bootm_headers</span> *<span class="title">images</span> =</span> bmi-&gt;images;</span><br><span class="line">boot_os_fn *boot_fn;</span><br><span class="line">ulong iflag = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> ret = <span class="number">0</span>, need_boot_fn;</span><br><span class="line"></span><br><span class="line">images-&gt;state |= states;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Work through the states and see how far we get. We stop on</span></span><br><span class="line"><span class="comment"> * any error.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (states &amp; BOOTM_STATE_START)</span><br><span class="line">ret = bootm_start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!ret &amp;&amp; (states &amp; BOOTM_STATE_PRE_LOAD))</span><br><span class="line">ret = bootm_pre_load(bmi-&gt;addr_img);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!ret &amp;&amp; (states &amp; BOOTM_STATE_FINDOS))</span><br><span class="line">ret = bootm_find_os(bmi-&gt;cmd_name, bmi-&gt;addr_img);<span class="comment">//Find the OS to boot，返回0表示正确</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!ret &amp;&amp; (states &amp; BOOTM_STATE_FINDOTHER)) &#123;</span><br><span class="line">ulong img_addr;</span><br><span class="line"></span><br><span class="line">img_addr = bmi-&gt;addr_img ? hextoul(bmi-&gt;addr_img, <span class="literal">NULL</span>)</span><br><span class="line">: image_load_addr;</span><br><span class="line">ret = bootm_find_other(img_addr, bmi-&gt;conf_ramdisk,</span><br><span class="line">       bmi-&gt;conf_fdt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (IS_ENABLED(CONFIG_MEASURED_BOOT) &amp;&amp; !ret &amp;&amp;</span><br><span class="line">    (states &amp; BOOTM_STATE_MEASURE))</span><br><span class="line">bootm_measure(images);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Load the OS */</span></span><br><span class="line"><span class="keyword">if</span> (!ret &amp;&amp; (states &amp; BOOTM_STATE_LOADOS)) &#123;</span><br><span class="line">iflag = bootm_disable_interrupts();</span><br><span class="line">        <span class="comment">//加载image镜像，由于之前已经加载过了，因此没有设置BOOTM_STATE_LOADOS，不会执行到这一步</span></span><br><span class="line">ret = bootm_load_os(images, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (ret &amp;&amp; ret != BOOTM_ERR_OVERLAP)</span><br><span class="line"><span class="keyword">goto</span> err;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ret == BOOTM_ERR_OVERLAP)</span><br><span class="line">ret = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Relocate the ramdisk */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SYS_BOOT_RAMDISK_HIGH</span></span><br><span class="line"><span class="keyword">if</span> (!ret &amp;&amp; (states &amp; BOOTM_STATE_RAMDISK)) &#123;</span><br><span class="line">ulong rd_len = images-&gt;rd_end - images-&gt;rd_start;</span><br><span class="line"><span class="comment">//加载ramdisk，由于之前已经加载过了，因此没有设置BOOTM_STATE_RAMDISK，不会执行到这一步</span></span><br><span class="line">ret = boot_ramdisk_high(&amp;images-&gt;lmb, images-&gt;rd_start,</span><br><span class="line">rd_len, &amp;images-&gt;initrd_start, &amp;images-&gt;initrd_end);</span><br><span class="line"><span class="keyword">if</span> (!ret) &#123;</span><br><span class="line">env_set_hex(<span class="string">&quot;initrd_start&quot;</span>, images-&gt;initrd_start);</span><br><span class="line">env_set_hex(<span class="string">&quot;initrd_end&quot;</span>, images-&gt;initrd_end);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> CONFIG_IS_ENABLED(OF_LIBFDT) &amp;&amp; defined(CONFIG_LMB)</span></span><br><span class="line"><span class="keyword">if</span> (!ret &amp;&amp; (states &amp; BOOTM_STATE_FDT)) &#123;</span><br><span class="line"><span class="comment">//加载设备树，由于之前已经加载过了，因此没有设置BOOTM_STATE_FDT，不会执行到这一步</span></span><br><span class="line">        boot_fdt_add_mem_rsv_regions(&amp;images-&gt;lmb, images-&gt;ft_addr);</span><br><span class="line">ret = boot_relocate_fdt(&amp;images-&gt;lmb, &amp;images-&gt;ft_addr,</span><br><span class="line">&amp;images-&gt;ft_len);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* From now on, we need the OS boot function */</span></span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">boot_fn = bootm_os_get_boot_func(images-&gt;os.os);</span><br><span class="line">need_boot_fn = states &amp; (BOOTM_STATE_OS_CMDLINE |</span><br><span class="line">BOOTM_STATE_OS_BD_T | BOOTM_STATE_OS_PREP |</span><br><span class="line">BOOTM_STATE_OS_FAKE_GO | BOOTM_STATE_OS_GO);</span><br><span class="line"><span class="keyword">if</span> (boot_fn == <span class="literal">NULL</span> &amp;&amp; need_boot_fn) &#123;</span><br><span class="line"><span class="keyword">if</span> (iflag)</span><br><span class="line">enable_interrupts();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ERROR: booting os &#x27;%s&#x27; (%d) is not supported\n&quot;</span>,</span><br><span class="line">       genimg_get_os_name(images-&gt;os.os), images-&gt;os.os);</span><br><span class="line">bootstage_error(BOOTSTAGE_ID_CHECK_BOOT_OS);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Call various other states that are not generally used */</span></span><br><span class="line"><span class="keyword">if</span> (!ret &amp;&amp; (states &amp; BOOTM_STATE_OS_CMDLINE))</span><br><span class="line">ret = boot_fn(BOOTM_STATE_OS_CMDLINE, bmi);</span><br><span class="line"><span class="keyword">if</span> (!ret &amp;&amp; (states &amp; BOOTM_STATE_OS_BD_T))</span><br><span class="line">ret = boot_fn(BOOTM_STATE_OS_BD_T, bmi);</span><br><span class="line"><span class="keyword">if</span> (!ret &amp;&amp; (states &amp; BOOTM_STATE_OS_PREP)) &#123;</span><br><span class="line"><span class="type">int</span> flags = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/* For Linux OS do all substitutions at console processing */</span></span><br><span class="line"><span class="keyword">if</span> (images-&gt;os.os == IH_OS_LINUX)</span><br><span class="line">flags = BOOTM_CL_ALL;</span><br><span class="line">ret = bootm_process_cmdline_env(flags);</span><br><span class="line"><span class="keyword">if</span> (ret) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Cmdline setup failed (err=%d)\n&quot;</span>, ret);</span><br><span class="line">ret = CMD_RET_FAILURE;</span><br><span class="line"><span class="keyword">goto</span> err;</span><br><span class="line">&#125;</span><br><span class="line">ret = boot_fn(BOOTM_STATE_OS_PREP, bmi);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_TRACE</span></span><br><span class="line"><span class="comment">/* Pretend to run the OS, then run a user command */</span></span><br><span class="line"><span class="keyword">if</span> (!ret &amp;&amp; (states &amp; BOOTM_STATE_OS_FAKE_GO)) &#123;</span><br><span class="line"><span class="type">char</span> *cmd_list = env_get(<span class="string">&quot;fakegocmd&quot;</span>);</span><br><span class="line"></span><br><span class="line">ret = boot_selected_os(BOOTM_STATE_OS_FAKE_GO, bmi, boot_fn);</span><br><span class="line"><span class="keyword">if</span> (!ret &amp;&amp; cmd_list)</span><br><span class="line">ret = run_command_list(cmd_list, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Check for unsupported subcommand. */</span></span><br><span class="line"><span class="keyword">if</span> (ret) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;subcommand failed (err=%d)\n&quot;</span>, ret);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Now run the OS! We hope this doesn&#x27;t return */</span></span><br><span class="line"><span class="keyword">if</span> (!ret &amp;&amp; (states &amp; BOOTM_STATE_OS_GO))<span class="comment">//启动系统</span></span><br><span class="line">ret = boot_selected_os(BOOTM_STATE_OS_GO, bmi, boot_fn);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Deal with any fallout */</span></span><br><span class="line">err:</span><br><span class="line"><span class="keyword">if</span> (iflag)</span><br><span class="line">enable_interrupts();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ret == BOOTM_ERR_UNIMPLEMENTED) &#123;</span><br><span class="line">bootstage_error(BOOTSTAGE_ID_DECOMP_UNIMPL);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret == BOOTM_ERR_RESET) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Resetting the board...\n&quot;</span>);</span><br><span class="line">reset_cpu();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>do_bootm_linux即boot_fn。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">do_bootm_linux</span><span class="params">(<span class="type">int</span> flag, <span class="keyword">struct</span> bootm_info *bmi)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bootm_headers</span> *<span class="title">images</span> =</span> bmi-&gt;images;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* No need for those on ARM */</span></span><br><span class="line"><span class="keyword">if</span> (flag &amp; BOOTM_STATE_OS_BD_T || flag &amp; BOOTM_STATE_OS_CMDLINE)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (flag &amp; BOOTM_STATE_OS_PREP) &#123;</span><br><span class="line">boot_prep_linux(images);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (flag &amp; (BOOTM_STATE_OS_GO | BOOTM_STATE_OS_FAKE_GO)) &#123;</span><br><span class="line">boot_jump_linux(images, flag);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">boot_prep_linux(images);</span><br><span class="line">boot_jump_linux(images, flag);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>boot_selected_os是对boot_fn的封装。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">boot_selected_os</span><span class="params">(<span class="type">int</span> state, <span class="keyword">struct</span> bootm_info *bmi, boot_os_fn *boot_fn)</span></span><br><span class="line">&#123;</span><br><span class="line">arch_preboot_os();</span><br><span class="line">board_preboot_os();</span><br><span class="line"></span><br><span class="line">boot_fn(state, bmi);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Stand-alone may return when &#x27;autostart&#x27; is &#x27;no&#x27; */</span></span><br><span class="line"><span class="keyword">if</span> (bmi-&gt;images-&gt;os.type == IH_TYPE_STANDALONE ||</span><br><span class="line">    IS_ENABLED(CONFIG_SANDBOX) ||</span><br><span class="line">    state == BOOTM_STATE_OS_FAKE_GO) <span class="comment">/* We expect to return */</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">bootstage_error(BOOTSTAGE_ID_BOOT_OS_RETURNED);</span><br><span class="line">debug(<span class="string">&quot;\n## Control returned to monitor - resetting...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> BOOTM_ERR_RESET;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>boot_jump_linux</code>是启动Linux系统的函数, boot_jump_linux根据不同的芯片架构有不同的实现, 下面所展示的代码为ARM架构的<code>boot_jump_linux</code>函数, 位于arch&#x2F;arm&#x2F;lib&#x2F;bootm.c文件中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">boot_jump_linux</span><span class="params">(<span class="keyword">struct</span> bootm_headers *images, <span class="type">int</span> flag)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_ARM64</span></span><br><span class="line"><span class="type">void</span> (*kernel_entry)(<span class="type">void</span> *fdt_addr, <span class="type">void</span> *res0, <span class="type">void</span> *res1,</span><br><span class="line"><span class="type">void</span> *res2);</span><br><span class="line"><span class="type">int</span> fake = (flag &amp; BOOTM_STATE_OS_FAKE_GO);</span><br><span class="line"></span><br><span class="line">kernel_entry = (<span class="type">void</span> (*)(<span class="type">void</span> *fdt_addr, <span class="type">void</span> *res0, <span class="type">void</span> *res1,</span><br><span class="line"><span class="type">void</span> *res2))images-&gt;ep;</span><br><span class="line"></span><br><span class="line">debug(<span class="string">&quot;## Transferring control to Linux (at address %lx)...\n&quot;</span>,</span><br><span class="line">(ulong) kernel_entry);</span><br><span class="line">bootstage_mark(BOOTSTAGE_ID_RUN_OS);</span><br><span class="line"></span><br><span class="line">announce_and_cleanup(fake);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!fake) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_ARMV8_PSCI</span></span><br><span class="line">armv8_setup_psci();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">do_nonsec_virt_switch();</span><br><span class="line"></span><br><span class="line">update_os_arch_secondary_cores(images-&gt;os.arch);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_ARMV8_SWITCH_TO_EL1</span></span><br><span class="line">armv8_switch_to_el2((u64)images-&gt;ft_addr, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">    (u64)switch_to_el1, ES_TO_AARCH64);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="keyword">if</span> ((IH_ARCH_DEFAULT == IH_ARCH_ARM64) &amp;&amp;</span><br><span class="line">    (images-&gt;os.arch == IH_ARCH_ARM))</span><br><span class="line">armv8_switch_to_el2(<span class="number">0</span>, (u64)gd-&gt;bd-&gt;bi_arch_number,</span><br><span class="line">    (u64)images-&gt;ft_addr, <span class="number">0</span>,</span><br><span class="line">    (u64)images-&gt;ep,</span><br><span class="line">    ES_TO_AARCH32);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">armv8_switch_to_el2((u64)images-&gt;ft_addr, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">    images-&gt;ep,</span><br><span class="line">    ES_TO_AARCH64);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ARM64架构的内核的入口是标号head,直接跳转到stext。在stext中会读取引导程序传递的四个参数，并且保存在boot_args中。并且设置处理器一场级别，创建页表映射，并调用函数cpu_setup ，为开启处理器的内存管理单元做准备，初始化处理器。调用函数primary_switch为主处理器开启内存管理单元，搭建c语言执行环境，进入c语言部分的入口函数start_kernel。</p><p>下图为bootz命令的调用流程图，bootz命令与booti类似，可以进行参考。</p><img src="\img\uboot-boot.png" alt="uboot-boot" style="zoom:67%;" /><h3 id="uboot与Linux内核"><a href="#uboot与Linux内核" class="headerlink" title="uboot与Linux内核"></a>uboot与Linux内核</h3><h3 id="设备树"><a href="#设备树" class="headerlink" title="设备树"></a>设备树</h3><p>设备树的作用就是描述一个硬件平台的硬件资源。这个“设备树”可以被 bootloader(uboot) 传递到内核，内核可以从设备树中获取硬件信息。以下为和设备树有关的文件：</p><ul><li><p>dts是一种 ASII 文本格式的设备树描述，一般一个.dts 文件对应一个硬件平台。</p></li><li><p>dtsi内容和dts相似，是指由芯片厂商提供，是同一芯片平台“共用”的设备树文件。</p></li><li><p>dtb是设备树源码编译生成的文件，类似于uboot源码编译后的bin文件。</p></li></ul><p>芯片厂商提供的dtsi几乎包含了芯片中所有设备及外设接口，在使用时，我们只需要在我们板卡的dts设备树源文件中 <code>#include</code>dtsi就可以导入指定芯片所有的设备，然后我们再根据板卡上的外设来修改dts文件即可。</p><h3 id="Bootargs是如何传递给内核的？"><a href="#Bootargs是如何传递给内核的？" class="headerlink" title="Bootargs是如何传递给内核的？"></a>Bootargs是如何传递给内核的？</h3><p>uboot与内核的数据交换由<code>boot_prep_linux</code>进行, <code>boot_prep_linux</code>函数实现了启动image前的一些初始化工作，boot_prep_linux 主要用于处理环境变量 bootargs，bootargs 保存着传递给 Linux kernel 的参数；</p><p>uboot与内核之间传递数据的方式有两种: FDT与TAGS. </p><p>TAGS传参方式类似于在uboot与Linux中定义一个相同的结构体, uboot先对结构体赋值, 在uboot启动Linux内核时将该结构体的内存地址传递给Linux内核; 而FDT方式是将参数信息加入设备树中, 随设备树一同传递给Linux内核.</p><p><code>boot_prep_linux</code>函数首先判断uboot与内核的传递方式, 若开启了FDT方式, 则跳转至FDT相关函数; 若未开启FDT而开启了TAGS方式, 则跳转至TAGS相关函数; 若两者均为开启, 则报错.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">boot_prep_linux</span><span class="params">(<span class="keyword">struct</span> bootm_headers *images)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> *commandline = env_get(<span class="string">&quot;bootargs&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (CONFIG_IS_ENABLED(OF_LIBFDT) &amp;&amp; IS_ENABLED(CONFIG_LMB) &amp;&amp; images-&gt;ft_len) &#123;</span><br><span class="line">debug(<span class="string">&quot;using: FDT\n&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (image_setup_linux(images)) &#123;</span><br><span class="line">panic(<span class="string">&quot;FDT creation failed!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (BOOTM_ENABLE_TAGS) &#123;</span><br><span class="line">debug(<span class="string">&quot;using: ATAGS\n&quot;</span>);</span><br><span class="line">setup_start_tag(gd-&gt;bd);</span><br><span class="line"><span class="keyword">if</span> (BOOTM_ENABLE_SERIAL_TAG)</span><br><span class="line">setup_serial_tag(&amp;params);</span><br><span class="line"><span class="keyword">if</span> (BOOTM_ENABLE_CMDLINE_TAG)</span><br><span class="line">setup_commandline_tag(gd-&gt;bd, commandline);</span><br><span class="line"><span class="keyword">if</span> (BOOTM_ENABLE_REVISION_TAG)</span><br><span class="line">setup_revision_tag(&amp;params);</span><br><span class="line"><span class="keyword">if</span> (BOOTM_ENABLE_MEMORY_TAGS)</span><br><span class="line">setup_memory_tags(gd-&gt;bd);</span><br><span class="line"><span class="keyword">if</span> (BOOTM_ENABLE_INITRD_TAG) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * In boot_ramdisk_high(), it may relocate ramdisk to</span></span><br><span class="line"><span class="comment"> * a specified location. And set images-&gt;initrd_start &amp;</span></span><br><span class="line"><span class="comment"> * images-&gt;initrd_end to relocated ramdisk&#x27;s start/end</span></span><br><span class="line"><span class="comment"> * addresses. So use them instead of images-&gt;rd_start &amp;</span></span><br><span class="line"><span class="comment"> * images-&gt;rd_end when possible.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (images-&gt;initrd_start &amp;&amp; images-&gt;initrd_end) &#123;</span><br><span class="line">setup_initrd_tag(gd-&gt;bd, images-&gt;initrd_start,</span><br><span class="line"> images-&gt;initrd_end);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (images-&gt;rd_start &amp;&amp; images-&gt;rd_end) &#123;</span><br><span class="line">setup_initrd_tag(gd-&gt;bd, images-&gt;rd_start,</span><br><span class="line"> images-&gt;rd_end);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">setup_board_tags(&amp;params);</span><br><span class="line">setup_end_tag(gd-&gt;bd);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">panic(<span class="string">&quot;FDT and ATAGS support not compiled in\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">board_prep_linux(images);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>若使用FDT方式进行传参, 则会进入<code>image_setup_linux</code>函数, 该函数用于配置ramdisk, fdt. <code>image_setup_linux</code>的步骤如下:</p><ul><li><p>获取image镜像的LMB (logical memory blocks). lmb为uboot下的一种内存管理机制，用于管理镜像的内存。lmb所记录的内存信息最终会传递给kernel。在&#x2F;include&#x2F;lmb.h和&#x2F;lib&#x2F;lmb.c中有对lmb的接口和定义的具体描述。</p></li><li><p>调用<code>boot_fdt_add_mem_rsv_regions</code>为设备树预留内存地址空间, 这里的地址为<code>do_booti</code>函数中从命令参数中获取的fdt地址;</p></li><li><p>调用<code>boot_get_cmdline</code>初始化内核命令行;</p></li><li><p>调用<code>boot_relocate_fdt</code>将fdt搬移至指定内存地址;</p></li><li><p>调用<code>image_setup_libfdt</code>函数, 为设备树增加参数;</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Set up the FDT to use for booting a kernel</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This performs ramdisk setup, sets up the FDT if required, and adds</span></span><br><span class="line"><span class="comment"> * paramters to the FDT if libfdt is available.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param imagesImages information</span></span><br><span class="line"><span class="comment"> * Return: 0 if ok, &lt;0 on failure</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">image_setup_linux</span><span class="params">(<span class="keyword">struct</span> bootm_headers *images)</span></span><br><span class="line">&#123;</span><br><span class="line">ulong of_size = images-&gt;ft_len;</span><br><span class="line"><span class="type">char</span> **of_flat_tree = &amp;images-&gt;ft_addr;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">lmb</span> *<span class="title">lmb</span> =</span> images_lmb(images);</span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* This function cannot be called without lmb support */</span></span><br><span class="line"><span class="keyword">if</span> (!IS_ENABLED(CONFIG_LMB))</span><br><span class="line"><span class="keyword">return</span> -EFAULT;</span><br><span class="line"><span class="keyword">if</span> (CONFIG_IS_ENABLED(OF_LIBFDT))</span><br><span class="line">boot_fdt_add_mem_rsv_regions(lmb, *of_flat_tree);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (IS_ENABLED(CONFIG_SYS_BOOT_GET_CMDLINE)) &#123;</span><br><span class="line">ret = boot_get_cmdline(lmb, &amp;images-&gt;cmdline_start,</span><br><span class="line">       &amp;images-&gt;cmdline_end);</span><br><span class="line"><span class="keyword">if</span> (ret) &#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;ERROR with allocation of cmdline\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (CONFIG_IS_ENABLED(OF_LIBFDT)) &#123;</span><br><span class="line">ret = boot_relocate_fdt(lmb, of_flat_tree, &amp;of_size);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (CONFIG_IS_ENABLED(OF_LIBFDT) &amp;&amp; of_size) &#123;</span><br><span class="line">ret = image_setup_libfdt(images, *of_flat_tree, lmb);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>image_setup_libfdt</code>用于在FDT中增加要传给linux内核的参数.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">image_setup_libfdt</span><span class="params">(<span class="keyword">struct</span> bootm_headers *images, <span class="type">void</span> *blob,</span></span><br><span class="line"><span class="params">       <span class="keyword">struct</span> lmb *lmb)</span></span><br><span class="line">&#123;</span><br><span class="line">ulong *initrd_start = &amp;images-&gt;initrd_start;</span><br><span class="line">ulong *initrd_end = &amp;images-&gt;initrd_end;</span><br><span class="line"><span class="type">int</span> ret, fdt_ret, of_size;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (IS_ENABLED(CONFIG_OF_ENV_SETUP)) &#123;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *fdt_fixup;</span><br><span class="line"></span><br><span class="line">fdt_fixup = env_get(<span class="string">&quot;fdt_fixup&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (fdt_fixup) &#123;</span><br><span class="line">set_working_fdt_addr(map_to_sysmem(blob));</span><br><span class="line">ret = run_command_list(fdt_fixup, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;WARNING: fdt_fixup command returned %d\n&quot;</span>,</span><br><span class="line">       ret);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ret = -EPERM;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (fdt_root(blob) &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ERROR: root node setup failed\n&quot;</span>);</span><br><span class="line"><span class="keyword">goto</span> err;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//传递bootargs参数</span></span><br><span class="line"><span class="keyword">if</span> (fdt_chosen(blob) &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ERROR: /chosen node create failed\n&quot;</span>);</span><br><span class="line"><span class="keyword">goto</span> err;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (arch_fixup_fdt(blob) &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ERROR: arch-specific fdt fixup failed\n&quot;</span>);</span><br><span class="line"><span class="keyword">goto</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fdt_ret = optee_copy_fdt_nodes(blob);</span><br><span class="line"><span class="keyword">if</span> (fdt_ret) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ERROR: transfer of optee nodes to new fdt failed: %s\n&quot;</span>,</span><br><span class="line">       fdt_strerror(fdt_ret));</span><br><span class="line"><span class="keyword">goto</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Store name of configuration node as u-boot,bootconf in /chosen node */</span></span><br><span class="line"><span class="keyword">if</span> (images-&gt;fit_uname_cfg)</span><br><span class="line">fdt_find_and_setprop(blob, <span class="string">&quot;/chosen&quot;</span>, <span class="string">&quot;u-boot,bootconf&quot;</span>,</span><br><span class="line">images-&gt;fit_uname_cfg,</span><br><span class="line"><span class="built_in">strlen</span>(images-&gt;fit_uname_cfg) + <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Update ethernet nodes */</span></span><br><span class="line">fdt_fixup_ethernet(blob);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> IS_ENABLED(CONFIG_CMD_PSTORE)</span></span><br><span class="line"><span class="comment">/* Append PStore configuration */</span></span><br><span class="line">fdt_fixup_pstore(blob);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="keyword">if</span> (IS_ENABLED(CONFIG_OF_BOARD_SETUP)) &#123;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *skip_board_fixup;</span><br><span class="line"></span><br><span class="line">skip_board_fixup = env_get(<span class="string">&quot;skip_board_fixup&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (skip_board_fixup &amp;&amp; ((<span class="type">int</span>)simple_strtol(skip_board_fixup, <span class="literal">NULL</span>, <span class="number">10</span>) == <span class="number">1</span>)) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;skip board fdt fixup\n&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fdt_ret = ft_board_setup(blob, gd-&gt;bd);</span><br><span class="line"><span class="keyword">if</span> (fdt_ret) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ERROR: board-specific fdt fixup failed: %s\n&quot;</span>,</span><br><span class="line">       fdt_strerror(fdt_ret));</span><br><span class="line"><span class="keyword">goto</span> err;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (IS_ENABLED(CONFIG_OF_SYSTEM_SETUP)) &#123;</span><br><span class="line">fdt_ret = ft_system_setup(blob, gd-&gt;bd);</span><br><span class="line"><span class="keyword">if</span> (fdt_ret) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ERROR: system-specific fdt fixup failed: %s\n&quot;</span>,</span><br><span class="line">       fdt_strerror(fdt_ret));</span><br><span class="line"><span class="keyword">goto</span> err;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (fdt_initrd(blob, *initrd_start, *initrd_end))</span><br><span class="line"><span class="keyword">goto</span> err;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!ft_verify_fdt(blob))</span><br><span class="line"><span class="keyword">goto</span> err;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* after here we are using a livetree */</span></span><br><span class="line"><span class="keyword">if</span> (!of_live_active() &amp;&amp; CONFIG_IS_ENABLED(EVENT)) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">event_ft_fixup</span> <span class="title">fixup</span>;</span></span><br><span class="line"></span><br><span class="line">fixup.tree = oftree_from_fdt(blob);</span><br><span class="line">fixup.images = images;</span><br><span class="line"><span class="keyword">if</span> (oftree_valid(fixup.tree)) &#123;</span><br><span class="line">ret = event_notify(EVT_FT_FIXUP, &amp;fixup, <span class="keyword">sizeof</span>(fixup));</span><br><span class="line"><span class="keyword">if</span> (ret) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ERROR: fdt fixup event failed: %d\n&quot;</span>,</span><br><span class="line">       ret);</span><br><span class="line"><span class="keyword">goto</span> err;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Delete the old LMB reservation */</span></span><br><span class="line"><span class="keyword">if</span> (lmb)</span><br><span class="line">lmb_free(lmb, map_to_sysmem(blob), fdt_totalsize(blob));</span><br><span class="line"></span><br><span class="line">ret = fdt_shrink_to_minimum(blob, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> err;</span><br><span class="line">of_size = ret;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Create a new LMB reservation */</span></span><br><span class="line"><span class="keyword">if</span> (lmb)</span><br><span class="line">lmb_reserve(lmb, map_to_sysmem(blob), of_size);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_ARCH_KEYSTONE)</span></span><br><span class="line"><span class="keyword">if</span> (IS_ENABLED(CONFIG_OF_BOARD_SETUP))</span><br><span class="line">ft_board_setup_ex(blob, gd-&gt;bd);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">err:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot; - must RESET the board to recover.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从uboot环境变量bootargs获取需要传递的参数，uboot引导内核时会根据bootargs环境变量值，修改内存设备树里面的bootargs参数。通过&#x2F;boot&#x2F;fdt_support.c中的fdt_chosen函数实现:</p><ul><li><code>str = board_fdt_chosen_bootargs();</code>获取bootargs参数;</li><li>调用<code>fdt_setprop(fdt, nodeoffset, &quot;bootargs&quot;, str,strlen(str) + 1);</code>将bootargs参数插入设备树中.</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * board_fdt_chosen_bootargs - boards may override this function to use</span></span><br><span class="line"><span class="comment"> *                             alternative kernel command line arguments</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">__weak <span class="type">char</span> *<span class="title function_">board_fdt_chosen_bootargs</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> env_get(<span class="string">&quot;bootargs&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fdt_chosen</span><span class="params">(<span class="type">void</span> *fdt)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">abuf</span> <span class="title">buf</span> =</span> &#123;&#125;;</span><br><span class="line"><span class="type">int</span>   nodeoffset;</span><br><span class="line"><span class="type">int</span>   err;</span><br><span class="line"><span class="type">char</span>  *str;<span class="comment">/* used to set string properties */</span></span><br><span class="line"></span><br><span class="line">err = fdt_check_header(fdt);</span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;fdt_chosen: %s\n&quot;</span>, fdt_strerror(err));</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* find or create &quot;/chosen&quot; node. */</span></span><br><span class="line">nodeoffset = fdt_find_or_add_subnode(fdt, <span class="number">0</span>, <span class="string">&quot;chosen&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (nodeoffset &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> nodeoffset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (IS_ENABLED(CONFIG_BOARD_RNG_SEED) &amp;&amp; !board_rng_seed(&amp;buf)) &#123;</span><br><span class="line">err = fdt_setprop(fdt, nodeoffset, <span class="string">&quot;rng-seed&quot;</span>,</span><br><span class="line">  abuf_data(&amp;buf), abuf_size(&amp;buf));</span><br><span class="line">abuf_uninit(&amp;buf);</span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;WARNING: could not set rng-seed %s.\n&quot;</span>,</span><br><span class="line">       fdt_strerror(err));</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">str = board_fdt_chosen_bootargs();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (str) &#123;</span><br><span class="line">err = fdt_setprop(fdt, nodeoffset, <span class="string">&quot;bootargs&quot;</span>, str,</span><br><span class="line">  <span class="built_in">strlen</span>(str) + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;WARNING: could not set bootargs %s.\n&quot;</span>,</span><br><span class="line">       fdt_strerror(err));</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* add u-boot version */</span></span><br><span class="line">err = fdt_setprop(fdt, nodeoffset, <span class="string">&quot;u-boot,version&quot;</span>, PLAIN_VERSION,</span><br><span class="line">  <span class="built_in">strlen</span>(PLAIN_VERSION) + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;WARNING: could not set u-boot,version %s.\n&quot;</span>,</span><br><span class="line">       fdt_strerror(err));</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> fdt_fixup_stdout(fdt, nodeoffset);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="uboot是如何将设备树文件传递给Linux的？"><a href="#uboot是如何将设备树文件传递给Linux的？" class="headerlink" title="uboot是如何将设备树文件传递给Linux的？"></a>uboot是如何将设备树文件传递给Linux的？</h3><p>在boot_jump_linux函数中, 启动64位linux内核时调用了<code>armv8_switch_to_el2((u64)images-&gt;ft_addr, 0, 0, 0,images-&gt;ep, ES_TO_AARCH64);</code>, 该函数用汇编实现, 用于启动Linux内核并将设备树地址传递给内核, 该函数的声明如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * armv8_switch_to_el2() - switch from EL3 to EL2 for ARMv8</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @args:        For loading 64-bit OS, fdt address.</span></span><br><span class="line"><span class="comment"> *               For loading 32-bit OS, zero.</span></span><br><span class="line"><span class="comment"> * @mach_nr:     For loading 64-bit OS, zero.</span></span><br><span class="line"><span class="comment"> *               For loading 32-bit OS, machine nr</span></span><br><span class="line"><span class="comment"> * @fdt_addr:    For loading 64-bit OS, zero.</span></span><br><span class="line"><span class="comment"> *               For loading 32-bit OS, fdt address.</span></span><br><span class="line"><span class="comment"> * @arg4: Input argument.</span></span><br><span class="line"><span class="comment"> * @entry_point: kernel entry point</span></span><br><span class="line"><span class="comment"> * @es_flag:     execution state flag, ES_TO_AARCH64 or ES_TO_AARCH32</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> __noreturn <span class="title function_">armv8_switch_to_el2</span><span class="params">(u64 args, u64 mach_nr, u64 fdt_addr,</span></span><br><span class="line"><span class="params">    u64 arg4, u64 entry_point, u64 es_flag)</span>;</span><br></pre></td></tr></table></figure><p>参考资料</p><p><a href="https://mp.weixin.qq.com/s?__biz=MzAxODI5ODMwOA==&mid=2666570161&idx=1&sn=251126f93335302a65ab66d88cf87708&chksm=81152ef30b028a6e8527dc93b16e73ca9a97f59fc198a82e689d1d4fa474612c23eca8f843ef&xtrack=1&scene=90&subscene=93&sessionid=1714135101&flutter_pos=27&clicktime=1714135116&enterid=1714135116&finder_biz_enter_id=4&ranksessionid=1714135101&ascene=56&fasttmpl_type=0&fasttmpl_fullversion=7177687-zh_CN-zip&fasttmpl_flag=0&realreporttime=1714135116334&devicetype=android-34&version=28002f51&nettype=cmnet&abtest_cookie=AAACAA==&lang=zh_CN&session_us=gh_9f1efcd6f4ab&countrycode=CN&exportkey=n_ChQIAhIQdeO1u/PmkezQCnG1xsTSRRLrAQIE97dBBAEAAAAAAINnE0bBh9wAAAAOpnltbLcz9gKNyK89dVj0LhawdNnVxRK1O3+ANpSGNzdnRMf4hjlq1rLPcT/egIzj6R4U39Ra7p4XnmmHCDD5f4qX7Vw05ITphh9FUXRkncSb6AiqT4fG9Rv6L35SCSZv0pWV0MP7yrv0iPLQtf22Su2URsYhT7Dr4rTcFjYrHFKeY32J7m9y/U8kUUnkgvffv4FJNU4dTFek1yIOVvks9wDrTFlE1qvt4ithYTI2uPIjZy1yezKqFvNhYx2/GQakoTkKYCG6vHkAYA6ubAPiHuBvn68=&pass_ticket=qpRLHEhkIYqSEKBo2Fr+QEQUC8kATZLFiO/pop0tPtqhUfNsTFQ/Rc6TluWrmRlYhS+rt1phI/1Tu2rmaZZueg==&wx_header=3">完全理解ARM启动流程：Uboot-Kernel</a></p><p><a href="https://krinkinmu.github.io/2020/11/29/PL011.html">ARMs PL011 UART</a></p><p><a href="https://krinkinmu.github.io/2023/08/21/how-u-boot-loads-linux-kernel.html">How U-boot loads Linux kernel</a></p><p><a href="http://www.wowotech.net/device_model/why-dt.html">Device Tree</a></p><p><a href="http://www.wowotech.net/u-boot/fit_image_overview.html">FIT IMAGE</a></p><p><a href="https://www.cnblogs.com/dongxb/p/16717565.html">Secure Boot</a></p><p><a href="https://www.cnblogs.com/jzcn/p/16966628.html">Uboot启动流程</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在重新编译Linux内核与设备树后，需要使用uboot加载新的内核与设备树。&lt;br&gt;开发板启动后，进入uboot命令行，执行以下命令：&lt;/p&gt;
&lt;p&gt;设置环境变量&lt;code&gt;bootargs&lt;/code&gt;启动参数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;console&amp;#x3D;tty</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>嵌入式系统启动流程解析</title>
    <link href="https://big7ng.github.io/2024/05/02/Linux_boot/"/>
    <id>https://big7ng.github.io/2024/05/02/Linux_boot/</id>
    <published>2024-05-02T09:36:36.462Z</published>
    <updated>2024-05-14T16:06:30.708Z</updated>
    
    <content type="html"><![CDATA[<h1 id="嵌入式Linux通用启动流程"><a href="#嵌入式Linux通用启动流程" class="headerlink" title="嵌入式Linux通用启动流程"></a>嵌入式Linux通用启动流程</h1><p>在进一步探索uboot、Linux内核、设备树三者之间的关系前，本文先介绍一下嵌入式系统上电至Linux系统启动的整体流程是怎样的，几乎所有的嵌入式系统都遵循这套通用的启动流程，具体板子可能会有部分修改，但是逻辑是一样的。</p><p>这里先给出几个术语：</p><ul><li>BROM：是Boot Rom的简称，是在cpu中固化的一段程序，一旦cpu制造完成，里面的内容便无法进行修改，cpu上电后就指向BROM中的代码，容量较少，一般用于初始化cpu以及引导下一阶段bootloader。</li><li>SRAM：CPU中的SRAM，简单来说，就是CPU中的Cache。</li><li>PL&#x2F;pre-loader：又叫Secondary program loader（SPL），用于初始化DDR内存、引导uboot。</li><li>LK: <a href="https://github.com/littlekernel/lk">Little Kernel</a>是一个开源的嵌入式操作系统内核，目标是提供一个简单而可靠的启动和初始化环境，以及基本的操作系统功能，如任务管理、内存管理和设备驱动程序。它通常用于嵌入式设备的引导过程，作为启动加载程序（bootloader）的一部分，与uboot功能类似。一旦系统启动完成，它可以被更复杂的操作系统（如Android）替代或与之配合使用。</li><li>Bootloader：位于系统启动过程中的最前端，负责初始化硬件设备、加载操作系统内核并启动操作系统。上述的LK&#x2F;Uboot均属于bootloader。</li></ul><p>下面是一个嵌入式Linux系统的启动总体流程：</p><ol><li>执行Boot ROM中的Boot code，初始化cpu，引导SPL&#x2F;pre-loder（将SPL&#x2F;pre-loder从外部存储加载至SRAM中）；</li><li>PC指针跳转至SPL处，执行SPL程序，初始化DDR内存，引导Bootloader（将Bootloader从外部存储加载至DDR中）；</li><li>PC指针跳转至Bootloader处，初始化部分外围设备，加载基础驱动，引导Linux系统（将Linux Kernel、Ramdisk从外部存储加载至DDR中）；</li><li>PC指针跳转至Linux kernel入口处，对硬件的控制权由bootloader转移至Linux kernel，Linux kernel运行后，挂载根文件系统，启动一系列系统服务（图形化界面、网络、音频等等）。</li></ol><img src="\img\boot_flow.png" alt="boot_flow" style="zoom:50%;" /><p>总体来说，在嵌入式系统的启动流程中，总是用一段较小的程序来引导一段更大的程序。有一个很好的比喻，将系统的启动流程比作古代桥梁的搭建，先用弓箭在两岸间搭建一根细绳，用这根细绳在两岸间连起粗绳，再用这根租绳连接更粗的绳子，直至在两岸间连接起一根铁链，这时一座桥的根基就搭建好了。</p><h1 id="VisionFive2开发板启动流程"><a href="#VisionFive2开发板启动流程" class="headerlink" title="VisionFive2开发板启动流程"></a>VisionFive2开发板启动流程</h1><p>在介绍了嵌入式Linux系统的通用流程后，本章将介绍一个具体的例子：搭载RISC-V架构jh7110的<a href="https://doc-en.rvspace.org/VisionFive2/Boot_UG/Shared/c_legal_notice.html">Visionfive2</a>开发板启动流程，如下图所示。</p><img src="\img\jh7110_Boot_Flow.svg" alt="boot_flow"  /><h3 id="BootRom"><a href="#BootRom" class="headerlink" title="BootRom"></a>BootRom</h3><p>在板子上电后，执行BootROM程序，BootROM会根据AON_RGPIO[1,0] (0x1702002c)的值选择启动模式：1. 从Quad SPI NOR flash memory启动；2. 从UART启动。</p><p>UART模式用于恢复模式，需要在上电的时候进行一系列操作（按住某个按钮或者给某给引脚置高电平）。一般情况下，不进行任何操作会默认从QSPI-NOR中启动， 将QSPI中的SPL加载至SRAM中并执行。</p><h3 id="SPL"><a href="#SPL" class="headerlink" title="SPL"></a>SPL</h3><p>Visionfive将固件（SPL、OpenSBI、U-Boot）存储到了QSPI-NOR存储器中，内存布局如下：</p><table><thead><tr><th align="left">偏移</th><th>长度</th><th>用途</th></tr></thead><tbody><tr><td align="left">0x0</td><td>0x80000</td><td>SPL</td></tr><tr><td align="left">0xF0000</td><td>0x10000</td><td>U-Boot环境变量</td></tr><tr><td align="left">0x100000</td><td>0x400000</td><td>U-Boot+OpenSBI</td></tr><tr><td align="left">0x600000</td><td>0x1000000</td><td>保留</td></tr></tbody></table><p>SPL是基于uboot的启动程序，用于初始化DDR内存，并将OpenSBI和U-Boot加载至内存中，执行OpenSBI程序。</p><h3 id="OpenSBI与UBoot"><a href="#OpenSBI与UBoot" class="headerlink" title="OpenSBI与UBoot"></a>OpenSBI与UBoot</h3><p>RISC-V架构的启动流程中多了一个OpenSBI环节，OpenSBI（Open Source Supervisor Binary Interface）实现了RISC-V SBI规范，它提供了一组机器模式下的SBI调用，用于操作处理器或与外部设备进行通信。其也作为固件的一部分，</p><p>在Visionfive中，OpenSBI的作用有：1. 为Linux提供基础的系统调用；2. 将处理器的M模式转换为S模式；3. 跳转到0x4020_0000地址执行uboot程序。</p><p>Uboot提供了简单的命令行功能、基础的文件系统与常见的外围设备驱动 （例如GMAC, UART, QSPI, SDIO, etc.)。Uboot主要用于通过各种方式引导Linux内核、设备树与根文件系统，包括ETH (Network), UART, QSPI, SDIO 与 NVMe (SSD)方式。</p><p>下图为Visionfive2在启动过程中，内存地址的映射。</p><img src="\img\Boot_Process.svg" alt="Boot_Process" /><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>OpenSBI是RISCV体系架构中特有的一个启动流程，虽然Visionfive2开发板的启动流程中多个一个OpenSBI，但整体流程还是遵循bootrom-&gt;spl-&gt;uboot-&gt;Linux kernel这个通用流程。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;嵌入式Linux通用启动流程&quot;&gt;&lt;a href=&quot;#嵌入式Linux通用启动流程&quot; class=&quot;headerlink&quot; title=&quot;嵌入式Linux通用启动流程&quot;&gt;&lt;/a&gt;嵌入式Linux通用启动流程&lt;/h1&gt;&lt;p&gt;在进一步探索uboot、Linux内核、设备</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Linux内核模块自动加载机制的探索</title>
    <link href="https://big7ng.github.io/2024/04/13/modules/"/>
    <id>https://big7ng.github.io/2024/04/13/modules/</id>
    <published>2024-04-13T07:44:26.930Z</published>
    <updated>2024-04-14T17:31:45.488Z</updated>
    
    <content type="html"><![CDATA[<p>在编译内核的时候，如果将某一功能编译成内核模块，那需要我们手动输入<code>insmod</code>或者<code>modprobe</code>命令进行加载吗？</p><p>经过实践发现，内核会在插入设备的时候自动加载相应的驱动模块，这是怎么实现的？本文接下来将进行一系列探索。</p><h1 id="从dmesg开始"><a href="#从dmesg开始" class="headerlink" title="从dmesg开始"></a>从dmesg开始</h1><p>USB声卡插入插槽，如果把SND_USB_AUDIO编译进内核，即<code>CONFIG_SND_USB_AUDIO=y</code>时，dmesg出现如下输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[574786.075305] usb 3-1: new full-speed USB device number 3 using ohci-platform</span><br><span class="line">[574786.301945] usb 3-1: New USB device found, idVendor=4459, idProduct=3233, bcdDevice= 1.00</span><br><span class="line">[574786.302014] usb 3-1: New USB device strings: Mfr=1, Product=2, SerialNumber=3</span><br><span class="line">[574786.302031] usb 3-1: Product: Yundea M1066</span><br><span class="line">[574786.302045] usb 3-1: Manufacturer: Yundea Technology</span><br><span class="line">[574786.302059] usb 3-1: SerialNumber: 433036323231382E</span><br><span class="line">[574786.306246] usb-storage 3-1:1.0: USB Mass Storage device detected</span><br><span class="line">[574786.310691] scsi host3: usb-storage 3-1:1.0</span><br><span class="line">[574787.341957] scsi 3:0:0:0: Direct-Access     BR25     UDISK            1.00 PQ: 0 ANSI: 2</span><br><span class="line">[574787.369983] sd 3:0:0:0: [sdc] Attached SCSI removable disk</span><br></pre></td></tr></table></figure><p>如果把SND_USB_AUDIO编译成模块，即<code>CONFIG_SND_USB_AUDIO=m</code>时，dmesg出现如下输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[ 1768.962881] usb 3-2: new full-speed USB device number 5 using xhci_hcd</span><br><span class="line">[ 1769.311093] usb 3-2: New USB device found, idVendor=4459, idProduct=3233, bcdDevice= 1.00</span><br><span class="line">[ 1769.311095] usb 3-2: New USB device strings: Mfr=1, Product=2, SerialNumber=3</span><br><span class="line">[ 1769.311096] usb 3-2: Product: Yundea M1066</span><br><span class="line">[ 1769.311097] usb 3-2: Manufacturer: Yundea Technology</span><br><span class="line">[ 1769.311098] usb 3-2: SerialNumber: 433036323231382E</span><br><span class="line">[ 1769.327878] mc: Linux media interface: v0.10</span><br><span class="line">[ 1769.328662] usb-storage 3-2:1.0: USB Mass Storage device detected</span><br><span class="line">[ 1769.329237] scsi host33: usb-storage 3-2:1.0</span><br><span class="line">[ 1769.329370] usbcore: registered new interface driver usb-storage</span><br><span class="line">[ 1769.331443] usbcore: registered new interface driver uas</span><br><span class="line">[ 1769.443024] usbcore: registered new interface driver snd-usb-audio</span><br><span class="line">[ 1770.339466] scsi 33:0:0:0: Direct-Access     BR25     UDISK            1.00 PQ: 0 ANSI: 2</span><br><span class="line">[ 1770.339900] sd 33:0:0:0: Attached scsi generic sg2 type 0</span><br><span class="line">[ 1770.409154] sd 33:0:0:0: [sdb] Attached SCSI removable disk</span><br></pre></td></tr></table></figure><p>我们接下来分析一下驱动编译为内核模块时USB插入后内核的响应：</p><ol><li>在USB端口3-2检测到一个新的全速USB设备,并使用xHCI（eXtensible Host Controller Interface）USB主机控制器；</li><li>获取该USB设备的信息，包括供应商ID(4459)、产品ID(3233)、设备版本号(1.00)；</li><li><code>Mfr=1</code>表示制造商信息在USB设备字符串索引1中，<code>Product=2</code>表示产品信息在USB设备字符串索引2中，<code>SerialNumber=3</code>表示序列号信息在USB设备字符串索引3中；</li><li>获取产品名称、制造商、序列号；</li><li>表示Linux媒体接口(Media Controller)已启用；</li><li>表示检测到USB设备是一个USB大容量存储设备；</li><li>为USB大容量存储设备创建了一个新的SCSI主机设备；</li><li>内核注册了新的USB驱动程序：usb-storage、uas、snd-usb-audio；</li><li>提供了SCSI设备的信息,显示它是一个Direct-Access可直接访问的存储设备,型号为”BR25 UDISK”,固件版本为1.00；<code>33:0:0:0</code>是该SCSI设备的唯一标识符，<code>PQ: 1</code>表示”Peripheral Qualifier”(外围设备限定符)为0，意味着设备可以正常使用，<code>ANSI: 2</code>表示设备遵循的ANSI SCSI标准版本为2；</li><li>SCSI设备已作为一个通用SCSI设备附加；</li><li>SCSI设备已被附加为一个可移动磁盘,设备名为”sdb”。</li></ol><p>经过对比可以看到，把驱动编译成模块，在usb插入后会自动加载相应的模块，这里有三条加载驱动信息是因为该内核配置了<code>CONFIG_USB_STORAGE</code>、<code>CONFIG_USB_UAS=m</code>，即usb存储驱动与<a href="https://linux-sunxi.org/USB/UAS">USB Attached SCSI</a>驱动。</p><p>为什么会有“usbcore: registered new interface driver snd-usb-audio”这一系列输出，是谁输出的？</p><h1 id="usbcore是谁输出的？"><a href="#usbcore是谁输出的？" class="headerlink" title="usbcore是谁输出的？"></a>usbcore是谁输出的？</h1><p>观察dmesg中关于自动加载驱动的输出，通过查找内核源码可以将其定位为<code>usb_register_driver</code>函数。</p><p><code>usb_register_driver</code>声明，位于<code>/include/linux/usb.h</code>中，在该头文件中，<code>usb_register</code>、<code>module_usb_driver</code>、<code>module_usb_stor_driver</code>函数对其进行了封装。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * use these in module_init()/module_exit()</span></span><br><span class="line"><span class="comment"> * and don&#x27;t forget MODULE_DEVICE_TABLE(usb, ...)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">usb_register_driver</span><span class="params">(<span class="keyword">struct</span> usb_driver *, <span class="keyword">struct</span> module *,</span></span><br><span class="line"><span class="params">       <span class="type">const</span> <span class="type">char</span> *)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* use a define to avoid include chaining to get THIS_MODULE &amp; friends */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> usb_register(driver) \</span></span><br><span class="line"><span class="meta">usb_register_driver(driver, THIS_MODULE, KBUILD_MODNAME)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * module_usb_driver() - Helper macro for registering a USB driver</span></span><br><span class="line"><span class="comment"> * @__usb_driver: usb_driver struct</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Helper macro for USB drivers which do not do anything special in module</span></span><br><span class="line"><span class="comment"> * init/exit. This eliminates a lot of boilerplate. Each module may only</span></span><br><span class="line"><span class="comment"> * use this macro once, and calling it replaces module_init() and module_exit()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> module_usb_driver(__usb_driver) \</span></span><br><span class="line"><span class="meta">module_driver(__usb_driver, usb_register, \</span></span><br><span class="line"><span class="meta">       usb_deregister)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> module_usb_stor_driver(__driver, __sht, __name) \</span></span><br><span class="line"><span class="meta">static int __init __driver##_init(void) \</span></span><br><span class="line"><span class="meta">&#123; \</span></span><br><span class="line"><span class="meta">usb_stor_host_template_init(&amp;(__sht), __name, THIS_MODULE); \</span></span><br><span class="line"><span class="meta">return usb_register(&amp;(__driver)); \</span></span><br><span class="line"><span class="meta">&#125; \</span></span><br><span class="line"><span class="meta">module_init(__driver##_init); \</span></span><br><span class="line"><span class="meta">static void __exit __driver##_exit(void) \</span></span><br><span class="line"><span class="meta">&#123; \</span></span><br><span class="line"><span class="meta">usb_deregister(&amp;(__driver)); \</span></span><br><span class="line"><span class="meta">&#125; \</span></span><br><span class="line"><span class="meta">module_exit(__driver##_exit)</span></span><br></pre></td></tr></table></figure><p><code>usb_register_driver</code>定义，位于<code>/drivers/usb/core/driver.c</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * usb_register_driver - register a USB interface driver</span></span><br><span class="line"><span class="comment"> * @new_driver: USB operations for the interface driver</span></span><br><span class="line"><span class="comment"> * @owner: module owner of this driver.</span></span><br><span class="line"><span class="comment"> * @mod_name: module name string</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Registers a USB interface driver with the USB core.  The list of</span></span><br><span class="line"><span class="comment"> * unattached interfaces will be rescanned whenever a new driver is</span></span><br><span class="line"><span class="comment"> * added, allowing the new driver to attach to any recognized interfaces.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Return: A negative error code on failure and 0 on success.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">NOTE:</span> if you want your driver to use the USB major number, you must call</span></span><br><span class="line"><span class="comment"> * usb_register_dev() to enable that functionality.  This function no longer</span></span><br><span class="line"><span class="comment"> * takes care of that.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">usb_register_driver</span><span class="params">(<span class="keyword">struct</span> usb_driver *new_driver, <span class="keyword">struct</span> module *owner,</span></span><br><span class="line"><span class="params"><span class="type">const</span> <span class="type">char</span> *mod_name)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> retval = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (usb_disabled())</span><br><span class="line"><span class="keyword">return</span> -ENODEV;</span><br><span class="line"></span><br><span class="line">new_driver-&gt;driver.name = new_driver-&gt;name;</span><br><span class="line">new_driver-&gt;driver.bus = &amp;usb_bus_type;</span><br><span class="line">new_driver-&gt;driver.probe = usb_probe_interface;</span><br><span class="line">new_driver-&gt;driver.remove = usb_unbind_interface;</span><br><span class="line">new_driver-&gt;driver.owner = owner;</span><br><span class="line">new_driver-&gt;driver.mod_name = mod_name;</span><br><span class="line">new_driver-&gt;driver.dev_groups = new_driver-&gt;dev_groups;</span><br><span class="line">spin_lock_init(&amp;new_driver-&gt;dynids.lock);</span><br><span class="line">INIT_LIST_HEAD(&amp;new_driver-&gt;dynids.<span class="built_in">list</span>);</span><br><span class="line"></span><br><span class="line">retval = driver_register(&amp;new_driver-&gt;driver);</span><br><span class="line"><span class="keyword">if</span> (retval)</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">retval = usb_create_newid_files(new_driver);</span><br><span class="line"><span class="keyword">if</span> (retval)</span><br><span class="line"><span class="keyword">goto</span> out_newid;</span><br><span class="line"></span><br><span class="line">pr_info(<span class="string">&quot;%s: registered new interface driver %s\n&quot;</span>,</span><br><span class="line">usbcore_name, new_driver-&gt;name);<span class="meta">#dmesg中的usbcore输出</span></span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line"><span class="keyword">return</span> retval;</span><br><span class="line"></span><br><span class="line">out_newid:</span><br><span class="line">driver_unregister(&amp;new_driver-&gt;driver);</span><br><span class="line"></span><br><span class="line">pr_err(<span class="string">&quot;%s: error %d registering interface driver %s\n&quot;</span>,</span><br><span class="line">usbcore_name, retval, new_driver-&gt;name);</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(usb_register_driver);</span><br></pre></td></tr></table></figure><p>通过函数的定义发现，是<code>usb_register_driver</code>内核函数在dmesg中打印了usbcore的信息。</p><p>uas驱动中，<code>root/driver/usb/storage/uas.c</code>文件调用了<code>uas_init</code>，uas_init调用了<code>usb_register</code>函数；</p><p>usb-storage驱动中，<code>/root/driver/usb/storage/usb.c</code>文件调用了<code>module_usb_stor_driver</code>函数；</p><p>snd-usb-audio驱动中，<code>/root/sound/usb/card.c</code>文件调用了<code>module_usb_driver</code>函数。</p><p>因此，在安装这些usb驱动的时候，会自动向dmesg输出内容，那么，是谁安装了这些驱动呢？</p><h1 id="udev"><a href="#udev" class="headerlink" title="udev"></a>udev</h1><p>udev 负责监听 Linux 内核发出的改变设备状态的事件，例如一个 USB 设备被插入或拔出。</p><p>使用 systemd 的机器上，udev 操作由 <code>systemd-udevd</code> 守护进程管理，可以通过常规的 systemd 方式使用 <code>systemctl status </code>命令 检查 udev 守护进程的状态：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl status systemd-udevd</span><br><span class="line">systemctl status udev</span><br></pre></td></tr></table></figure><p>udev 通过序列号、制造商、以及提供商 ID 和产品 ID 号来识别设备。</p><h3 id="udevadm"><a href="#udevadm" class="headerlink" title="udevadm"></a>udevadm</h3><p>udevadm(udev administrator), 是一个 udev 管理工具，可用于查询 udev 数据库中的设备信息，也可以从 sysfs 文件系统中查询到设备的属性以辅助创建 udev 规则。</p><p>使用 <code>udevadm monitor</code> 命令你可以实时利用 udev，并且可以看到当你插入不同设备时发生了什么。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo udevadm monitor</span><br></pre></td></tr></table></figure><p>该监视函数输出接收到的事件：</p><ul><li>KERNEL：内核发送 uevent 事件, udev 守护进程侦听来自内核的 uevent，以此添加或者删除 &#x2F;dev下的设备文件</li><li>UDEV：在规则处理之后发出 udev 事件</li></ul><p>以下内容是插入USB声卡后udevadm monitor的输出（节选）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">KERNEL[22751.610627] add      /devices/pci0000:00/0000:00:15.0/0000:03:00.0/usb3/3-2 (usb)</span><br><span class="line">KERNEL[22751.616782] add      /devices/pci0000:00/0000:00:15.0/0000:03:00.0/usb3/3-2/3-2:1.0 (usb)</span><br><span class="line">KERNEL[22751.618458] add      /devices/pci0000:00/0000:00:15.0/0000:03:00.0/usb3/3-2/3-2:1.0/host33 (scsi)</span><br><span class="line">KERNEL[22751.618484] add      /devices/pci0000:00/0000:00:15.0/0000:03:00.0/usb3/3-2/3-2:1.0/host33/scsi_host/host33 (scsi_host)</span><br><span class="line">KERNEL[22751.620373] add      /devices/pci0000:00/0000:00:15.0/0000:03:00.0/usb3/3-2/3-2:1.1 (usb)</span><br><span class="line">KERNEL[22751.729567] add      /devices/pci0000:00/0000:00:15.0/0000:03:00.0/usb3/3-2/3-2:1.1/sound/card1 (sound)</span><br><span class="line">KERNEL[22751.730062] add      /devices/pci0000:00/0000:00:15.0/0000:03:00.0/usb3/3-2/3-2:1.1/sound/card1/pcmC1D0p (sound)</span><br><span class="line">KERNEL[22751.730387] add      /devices/pci0000:00/0000:00:15.0/0000:03:00.0/usb3/3-2/3-2:1.1/sound/card1/pcmC1D0c (sound)</span><br><span class="line">KERNEL[22751.730624] add      /devices/pci0000:00/0000:00:15.0/0000:03:00.0/usb3/3-2/3-2:1.1/sound/card1/controlC1 (sound)</span><br><span class="line">UDEV  [22751.739014] add      /devices/pci0000:00/0000:00:15.0/0000:03:00.0/usb3/3-2/3-2:1.1/sound/card1 (sound)</span><br><span class="line">UDEV  [22751.739301] add      /devices/pci0000:00/0000:00:15.0/0000:03:00.0/usb3/3-2/3-2:1.0/host33 (scsi)</span><br><span class="line">UDEV  [22751.740201] add      /devices/pci0000:00/0000:00:15.0/0000:03:00.0/usb3/3-2/3-2:1.0/host33/scsi_host/host33 (scsi_host)</span><br><span class="line">UDEV  [22751.740729] add      /devices/pci0000:00/0000:00:15.0/0000:03:00.0/usb3/3-2/3-2:1.1/sound/card1/pcmC1D0p (sound)</span><br><span class="line">KERNEL[22751.740740] change   /devices/pci0000:00/0000:00:15.0/0000:03:00.0/usb3/3-2/3-2:1.1/sound/card1 (sound)</span><br><span class="line">UDEV  [22751.740748] add      /devices/pci0000:00/0000:00:15.0/0000:03:00.0/usb3/3-2/3-2:1.1/sound/card1/pcmC1D0c (sound)</span><br><span class="line">UDEV  [22751.759173] add      /devices/pci0000:00/0000:00:15.0/0000:03:00.0/usb3/3-2/3-2:1.1/sound/card1/controlC1 (sound)</span><br><span class="line">UDEV  [22751.762417] change   /devices/pci0000:00/0000:00:15.0/0000:03:00.0/usb3/3-2/3-2:1.1/sound/card1 (sound)</span><br></pre></td></tr></table></figure><p> <code>udevadm info</code> 命令去查询 udev 数据库中的指定设备信息。<code>-q</code>, <code>--query=TYPE</code> ：从数据库中查询指定类型的设备，需要使用 <code>--path</code> 和 <code>--name</code> 选项指定设备。合法的 TYPE 类型包括：设备名（name），链接（symlink），路径（path），属性（property）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">udevadm info -q path -n /dev/sdc1</span><br></pre></td></tr></table></figure><h3 id="udev规则"><a href="#udev规则" class="headerlink" title="udev规则"></a>udev规则</h3><p>udev 的工作方式是试图将它收到的每个系统事件与 <code>/lib/udev/rules.d/</code> 和 <code>/etc/udev/rules.d/</code> 目录下找到的规则集进行匹配。</p><p>udev 规则是定义在一个以 <code>.rules</code> 为扩展名的文件中。那些文件主要放在两个位置：<code>/usr/lib/udev/rules.d</code>，这个目录用于存放系统安装的规则；<code>/etc/udev/rules.d/</code> 这个目录是保留给自定义规则的。如果两个目录下均有相同的文件，则以<code>/etc/udev/rules.d/</code> 中的文件为准。</p><p>规则文件包括匹配键和分配键，可用的匹配键包括 <code>action</code>、<code>name</code> 和 <code>subsystem</code>。这意味着如果探测到一个属于某个子系统的、带有特定名称的设备，就会给设备指定一个预设的配置，例如执行一段脚本。</p><p><code>ACTION</code> 键：通过使用它，当在一个设备上发生了特定的事件，我们将指定我们要应用的规则的具体内容。有效的值有 <code>add</code>、<code>remove </code>以及 <code>change</code>。然后，我们使用 <code>ATTRS</code> 关键字去指定一个属性去匹配。</p><p>&#x2F;lib&#x2F;udev&#x2F;rules.d&#x2F;80-drivers.rules中有<strong>自动加载驱动</strong>的规则如下，有了这一行，udev就可以根据插入设备的modalias自动加载相应的驱动模块了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ACTION!=&quot;add&quot;, GOTO=&quot;drivers_end&quot;</span><br><span class="line"></span><br><span class="line">ENV&#123;MODALIAS&#125;==&quot;?*&quot;, RUN&#123;builtin&#125;+=&quot;kmod load $env&#123;MODALIAS&#125;&quot;</span><br></pre></td></tr></table></figure><p>我们也看可以自己更改udev规则，更改后需要重新加载udev规则</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">udevadm control --reload</span><br></pre></td></tr></table></figure><h3 id="hwdb"><a href="#hwdb" class="headerlink" title="hwdb"></a>hwdb</h3><p>硬件数据库(HWDB)是一个由”<a href="https://wiki.archlinux.org/title/Modalias">modalias</a>“风格的键(key)与”udev属性”风格的值(value)组成的 key-value 文本数据库。 主要用于 udev 为匹配到的硬件设备添加关联属性， 但也可以用于直接查询。</p><p>每个硬件数据库文件(hwdb)都包含一系列由”matche”与关联的”key-value”组成的记录。</p><p>&#x2F;lib&#x2F;udev&#x2F;hwdb.d&#x2F;20-usb-classes.hwdb文件中有如下一行:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">usb:v*p*d*dc01*</span><br><span class="line"> ID_USB_CLASS_FROM_DATABASE=Audio</span><br></pre></td></tr></table></figure><p>参考资料</p><p><a href="https://zhuanlan.zhihu.com/p/51984452">https://zhuanlan.zhihu.com/p/51984452</a></p><p><a href="https://zhuanlan.zhihu.com/p/33932734">https://zhuanlan.zhihu.com/p/33932734</a></p><p><a href="https://www.jinbuguo.com/systemd/hwdb.html">https://www.jinbuguo.com/systemd/hwdb.html</a></p><p><a href="https://www.jinbuguo.com/systemd/systemd-hwdb.html">https://www.jinbuguo.com/systemd/systemd-hwdb.html</a></p><p><a href="https://documentation.suse.com/zh-cn/sles/12-SP5/html/SLES-all/cha-udev.html">https://documentation.suse.com/zh-cn/sles/12-SP5/html/SLES-all/cha-udev.html</a></p><p><a href="https://stackoverflow.com/questions/62835556/usb-why-usb-devices-the-modules-automatically-loaded">https://stackoverflow.com/questions/62835556/usb-why-usb-devices-the-modules-automatically-loaded</a></p><p><a href="https://stackoverflow.com/questions/73811317/how-to-find-the-udev-rule-which-causes-the-loading-of-the-kernel-module-88xxau-k">https://stackoverflow.com/questions/73811317/how-to-find-the-udev-rule-which-causes-the-loading-of-the-kernel-module-88xxau-k</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在编译内核的时候，如果将某一功能编译成内核模块，那需要我们手动输入&lt;code&gt;insmod&lt;/code&gt;或者&lt;code&gt;modprobe&lt;/code&gt;命令进行加载吗？&lt;/p&gt;
&lt;p&gt;经过实践发现，内核会在插入设备的时候自动加载相应的驱动模块，这是怎么实现的？本文接下来将进行</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Linux中音频框架的学习与使用</title>
    <link href="https://big7ng.github.io/2024/04/08/vocie/"/>
    <id>https://big7ng.github.io/2024/04/08/vocie/</id>
    <published>2024-04-08T13:50:17.894Z</published>
    <updated>2024-04-17T09:39:42.492Z</updated>
    
    <content type="html"><![CDATA[<p>本文将介绍如何在Linux中查看声卡信息，ALSA、pulseaudio框架以及与音频相关的工具。</p><h1 id="硬件信息"><a href="#硬件信息" class="headerlink" title="硬件信息"></a>硬件信息</h1><p>查看声卡硬件信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/asound/cards#列出主机上的声卡</span><br><span class="line">lspci | grep -i audio#查看pci总线上的声音芯片集的名称和类型</span><br><span class="line">lsusb | grep -i audio#查看usb总线上的声音芯片集的名称和类型</span><br><span class="line">lsusb -t#可以以树形的方式更方便地查看usb设备</span><br><span class="line">ls /sys/class/sound/#查看当前系统中的所有音频设备</span><br></pre></td></tr></table></figure><p>查看驱动信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsmod | grep snd</span><br></pre></td></tr></table></figure><h1 id="PulseAudio"><a href="#PulseAudio" class="headerlink" title="PulseAudio"></a>PulseAudio</h1><p>PulseAudio 是一个音频服务器，它充当了你的应用程序和硬件设备之间的中间件。在一个系统中，它作为一个后台进程运行，接受来自一个或多个源的音频输入，然后将它们重定向到一个或多个接收点，例如声卡、蓝牙、远程网络上的 PulseAudio 服务器或其他进程。</p><p>pulseaudio控制命令如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pulseaudio --check</span><br><span class="line">pulseaudio -D</span><br></pre></td></tr></table></figure><p>pulseaudio程序主要有两个配置文件：</p><ol><li><code>/etc/pluse/default.pa</code>: 默认启动脚本</li><li><code>/etc/pluse/daemon.conf</code>: 配置文件</li></ol><p>pulseaudio自带的命令行管理工具pacmd，使用方法如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pacmd <span class="built_in">stat</span><span class="comment">#查看pulseaudio状态</span></span><br><span class="line">pacmd list-sources<span class="comment">#列出所有输入设备</span></span><br><span class="line">pacmd list-sink<span class="comment">#列出所有输出设备</span></span><br><span class="line">pacmd set-default-sinkNAME|<span class="comment">#N#设置默认输出设备</span></span><br><span class="line">pacmd set-default-sourceNAME|<span class="comment">#N#设置默认输入设备</span></span><br><span class="line">pacmd <span class="built_in">set</span>-(sink|<span class="built_in">source</span>)-volume NAME|<span class="comment">#N VOLUME#设置设备的音量</span></span><br></pre></td></tr></table></figure><p>如果使用的是桌面系统，可以使用图形化管理工具<strong>PulseAudio Volume Control(pavucontrol)</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install pavucontrol</span><br></pre></td></tr></table></figure><h3 id="jack"><a href="#jack" class="headerlink" title="jack"></a>jack</h3><p>JACK Audio Connection Kit (or JACK)是一个低延迟的实时音频服务器,主要用于音频编辑和音乐制作等专业应用，例如Ardour 、Audacity。它提供了更精细的音频控制和路由。<br>PulseAudio 是一个通用的音频服务器,主要面向普通桌面用户。它提供了更简单的音频管理功能,如音量控制、设备切换等。</p><p>jack和pulseaudio的区别如官网所述：</p><blockquote><ul><li>PulseAudio is focused on desktop and mobile audio needs. It doesn’t try to address low latency usage, but does provide seamless device switching, network routing, global per-application volume control and lots more great stuff.</li><li>JACK is focused on the needs of pro-audio and music creation users. It offers the lowest possible latency, complete routing flexibility between applications and audio hardware, and all audio is always sample synchronized - apps don’t run ahead or behind of others. It doesn’t provide the smooth desktop experience that PulseAudio is aiming at.</li></ul></blockquote><h1 id="ALSA"><a href="#ALSA" class="headerlink" title="ALSA"></a>ALSA</h1><p>ALSA（Advanced Linux Sound Architecture），它在Linux操作系统上提供了音频和MIDI（Musical Instrument Digital Interface，音乐设备数字化接口）的支持。在2.6系列内核中，ALSA已经成为默认的声音子系统，用来替换2.4系列内核中的OSS（Open Sound System，开放声音系统）。有点类似与Linux中V4L2的视频架构。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install alsa-base alsa-utils alsa-oss alsa-tools</span><br></pre></td></tr></table></figure><p>配置音频</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alsamixer#ncurses配置界面</span><br><span class="line">amixer#命令行配置界面</span><br></pre></td></tr></table></figure><p>检查声卡设备</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">aplay -L//检测播放设备</span><br><span class="line">aplay -l//检测播放声卡</span><br><span class="line">arecord -L//检测录音设备</span><br><span class="line">arecord -l//检测录音声卡</span><br></pre></td></tr></table></figure><p>录制音频，-D指定录音设备，-d指定录制时间，-r指定采样率，-c指定录音采样数。通过<code>aplay -L</code>命令，播放设备为”plughw:CARD&#x3D;M1066,DEV&#x3D;0”。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arecord -D plughw:CARD=M1066,DEV=0 -d 5 -r 16000 -c 1 ./test.wav</span><br></pre></td></tr></table></figure><p>播放音频文件，由于wav文件中包含录制数据，因此只需指定播放设备</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aplay -D plughw:CARD=M1066,DEV=0 ./test.wav</span><br></pre></td></tr></table></figure><h3 id="ALSA与PulseAudio的关系"><a href="#ALSA与PulseAudio的关系" class="headerlink" title="ALSA与PulseAudio的关系"></a>ALSA与PulseAudio的关系</h3><p>ALSA(高级Linux声音体系)是为声卡提供驱动的Linux内核组件,以替代原先的OSS(开放声音系统).这两个是系统发出声音最低层的软件系统,可以视为(或者就是)驱动。</p><p>而PulseAudio是声音服务器，简单说，软件要发声就先发消息给声音服务器，然后声音服务器经过处理(主要是混音),然后发给驱动控制声音设备发出声音。</p><p>alsa是一套框架，应用层直接可以调用alsa lib发声音，但是混音上应该有些不足，操作可能比较复杂。pulseaudio，在alsa lib上又封装了一层，增加了很多pulseaudio自己定义的插件，这样大大扩展alsa lib的功能，同时混音方面也加强了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">没有pulseaudio：app--&gt;alsa lib ---&gt;alsa driver---&gt;发声音</span><br><span class="line">有pulseaudio：app---&gt;pulseaudio---&gt;alsa lib---&gt;alsa driver---&gt;发声音</span><br></pre></td></tr></table></figure><img src="\img\pulseaudio1.png" alt="pulseaudio1" style="zoom:50%;" /><img src="\img\pulseaudio2.png" alt="pulseaudio2" style="zoom: 67%;" /><h1 id="sox"><a href="#sox" class="headerlink" title="sox"></a>sox</h1><p><a href="http://sox.sourceforge.net/Main/HomePage">SoX</a>（即 Sound eXchange）可以将各种格式的音频文件转换为需要的其他格式，还可以对输入的音频文件应用各种效果，也支持在大多数平台上<strong>播放</strong>和<strong>录制</strong>音频文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install sox</span><br></pre></td></tr></table></figure><p>获取音频文件的元数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">soxi test.wav</span><br><span class="line">sox --i test.wav</span><br></pre></td></tr></table></figure><p>录制与播放, sox的使用类似于ffmpeg，都是从左至右指定输入、filter、输出。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rec test.wav#录制音频文件</span><br><span class="line">sox -d test.wav#同上</span><br><span class="line">play test.wav#播放音频文件</span><br><span class="line">sox test.wav -d #同上</span><br></pre></td></tr></table></figure><p>格式转换, sox可以根据参数文件的后缀推断出相应的格式, 并在复制音频数据的过程中自动进行转码。</p><p>SoX 可以处理 <strong>self-describing</strong> 和 <strong>raw</strong> 格式的音频文件。 <strong>self-describing</strong> 格式（如 WAV、FLAC、MP3）的文件包含一个用于描述信号和编码属性的<strong>文件头</strong>，而 <strong>raw</strong> 或 <strong>headless</strong> 格式的音频则不包含这些信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sox test.wav test.mp3</span><br></pre></td></tr></table></figure><p>查看sox提供的音频效果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sox --help-effect all#查看所有效果</span><br><span class="line">sox --help-effect delay#查看具体的效果</span><br></pre></td></tr></table></figure><p>参考资料</p><ul><li>alsa</li></ul><p><a href="https://www.cnblogs.com/gmpy/articles/16778302.html">https://www.cnblogs.com/gmpy/articles/16778302.html</a></p><p><a href="https://wiki.archlinux.org/title/Advanced_Linux_Sound_Architecture">https://wiki.archlinux.org/title/Advanced_Linux_Sound_Architecture</a></p><p><a href="https://www.alsa-project.org/wiki/Main_Page">https://www.alsa-project.org/wiki/Main_Page</a></p><ul><li>pulseaudio</li></ul><p><a href="https://wiki.archlinux.org/title/PulseAudio">https://wiki.archlinux.org/title/PulseAudio</a></p><p><a href="https://unix.stackexchange.com/questions/249342/why-do-you-need-pulseaudio">https://unix.stackexchange.com/questions/249342/why-do-you-need-pulseaudio</a></p><p><a href="https://www.freedesktop.org/wiki/Software/PulseAudio/">https://www.freedesktop.org/wiki/Software/PulseAudio/</a></p><p><a href="https://forum.ubuntu.org.cn/viewtopic.php?t=163776">https://forum.ubuntu.org.cn/viewtopic.php?t=163776</a></p><p><a href="https://tieba.baidu.com/p/3790145023">https://tieba.baidu.com/p/3790145023</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文将介绍如何在Linux中查看声卡信息，ALSA、pulseaudio框架以及与音频相关的工具。&lt;/p&gt;
&lt;h1 id=&quot;硬件信息&quot;&gt;&lt;a href=&quot;#硬件信息&quot; class=&quot;headerlink&quot; title=&quot;硬件信息&quot;&gt;&lt;/a&gt;硬件信息&lt;/h1&gt;&lt;p&gt;查看声卡硬</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>使用virtualenv创建python虚拟环境</title>
    <link href="https://big7ng.github.io/2024/04/07/virtualenv/"/>
    <id>https://big7ng.github.io/2024/04/07/virtualenv/</id>
    <published>2024-04-07T15:23:59.922Z</published>
    <updated>2024-04-08T04:56:35.104Z</updated>
    
    <content type="html"><![CDATA[<p>在Windows的Python开发中经常使用anaconda来配置虚拟环境，但是在Linux中使用conda经常会出现环境变量报错等一系列问题，因此本文将总结以下在Linux中使用vitualenv来配置虚拟环境。</p><h1 id="venv"><a href="#venv" class="headerlink" title="venv"></a>venv</h1><p>venv是python在版本3.3后自带的功能</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /path/to/proj</span><br><span class="line">python3 -m venv proj_name#创建虚拟环境</span><br><span class="line">source ./bin/activate#激活虚拟环境</span><br></pre></td></tr></table></figure><p>激活虚拟环境后，命令行最前面会像conda一样显示环境名，在虚拟环境中，pip安装的包与其他环境是隔离的，可以安装随意的版本而不影响其它环境</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deactivate #退出环境</span><br></pre></td></tr></table></figure><p>venv只能创建虚拟环境，不能指定python版本比较麻烦，并且不能查看环境列表。</p><h1 id="virtualenv"><a href="#virtualenv" class="headerlink" title="virtualenv"></a>virtualenv</h1><p>virtualenv是venv的加强版，可以指定python版本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install virtualenv</span><br><span class="line">pip3 install virtualenv</span><br></pre></td></tr></table></figure><p>使用virtualenv</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd /path/to/proj</span><br><span class="line">virtualenv env_name -p python3.8 #指定python版本创建环境</span><br><span class="line">source ./bin/activate#激活环境</span><br><span class="line">deactivate#退出环境</span><br></pre></td></tr></table></figure><p>但是virtualenv也不能查看当前系统安装的环境列表。</p><h1 id="virtualenvwrapper"><a href="#virtualenvwrapper" class="headerlink" title="virtualenvwrapper"></a>virtualenvwrapper</h1><p><a href="https://virtualenvwrapper.readthedocs.io/en/latest/">virtualenvwrapper</a>相当于是virtualenv的管理工具，可以查看环境列表</p><p>安装virtualenvwrapper</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip3 install virtualenvwrapper</span><br><span class="line">mkdir $HOME/.virtualenvs</span><br></pre></td></tr></table></figure><p>配置virtualenvwrapper</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> WORKON_HOME=<span class="variable">$HOME</span>/.virtualenvs</span><br><span class="line"><span class="built_in">export</span> VIRTUALENVWRAPPER_PYTHON=/usr/bin/python3</span><br><span class="line"><span class="built_in">export</span> VIRTUALENVWRAPPER_VIRTUALENV=~/.local/bin/virtualenv</span><br><span class="line"><span class="built_in">source</span> ~/.local/bin/virtualenvwrapper.sh</span><br></pre></td></tr></table></figure><p>重启终端或者执行以下命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure><p>virtualenvwrapper相关命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mkvirtualenv env_name -p python3.8#创建指定python版本虚拟环境</span><br><span class="line">workon env_name#切换虚拟环境</span><br><span class="line">deactivate#退出虚拟环境</span><br><span class="line">rmvitualenv env_name#删除虚拟环境</span><br><span class="line">lsvirtualenv#列出虚拟环境</span><br><span class="line">lssitepackages#列出当前环境安装的包</span><br></pre></td></tr></table></figure><h1 id="Pipenv"><a href="#Pipenv" class="headerlink" title="Pipenv"></a>Pipenv</h1><p><a href="https://github.com/pypa/pipenv">pipenv</a>和vituralenvwrapper类似</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install pipenv</span><br></pre></td></tr></table></figure><p>使用方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pipenv --python 3.x.x #指定python版本创建虚拟环境</span><br><span class="line">pipenv --version</span><br><span class="line">pipenv --venv#查看当前虚拟环境信息</span><br><span class="line">pipenv graph#查看虚拟环境中包的依赖关系</span><br><span class="line">pipenv run命令#在虚拟环境中运行命令</span><br><span class="line">pipenv shell#切换到虚拟环境shell</span><br><span class="line">pipenv install#在虚拟环境中安装包</span><br><span class="line">exit#退出虚拟环境</span><br></pre></td></tr></table></figure><p>删除虚拟环境</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pipenv --rm</span><br></pre></td></tr></table></figure><h1 id="Python版本"><a href="#Python版本" class="headerlink" title="Python版本"></a>Python版本</h1><p>在ubuntu中，apt安装的python版本可能不符合要求，因此需要安装其他版本的python，这里有几种方法</p><h3 id="源码编译"><a href="#源码编译" class="headerlink" title="源码编译"></a>源码编译</h3><p>下载python源码进行编译，适合比较古老或软件适配不好的系统</p><h3 id="添加PPA源"><a href="#添加PPA源" class="headerlink" title="添加PPA源"></a>添加PPA源</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository ppa:deadsnakes/ppa</span><br><span class="line">sudo apt update</span><br><span class="line">sudo apt install python3.x</span><br></pre></td></tr></table></figure><p>安装完成后，要运行python3.x，使用<code>python3.x</code>命令</p><p>但是这种方法适合较新的系统，ppa:deadsnakes 仓库停止维护旧版本 Ubuntu ，删除了针对 Ubuntu bionic 18.04 的所有 Python 预编译包，目前仅支持focal和jammy。</p><h3 id="Pyenv"><a href="#Pyenv" class="headerlink" title="Pyenv"></a>Pyenv</h3><p><a href="https://github.com/pyenv/pyenv">pyenv</a>是一个python版本管理工具，可以很方便地切换python版本，pyenv的原理也是从下载python源码进行编译。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在Windows的Python开发中经常使用anaconda来配置虚拟环境，但是在Linux中使用conda经常会出现环境变量报错等一系列问题，因此本文将总结以下在Linux中使用vitualenv来配置虚拟环境。&lt;/p&gt;
&lt;h1 id=&quot;venv&quot;&gt;&lt;a href=&quot;#v</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Nginx安装nginx-http-flv-module模块开启HTTP-FLV直播</title>
    <link href="https://big7ng.github.io/2024/03/30/nginx_flv/"/>
    <id>https://big7ng.github.io/2024/03/30/nginx_flv/</id>
    <published>2024-03-30T06:53:33.608Z</published>
    <updated>2024-04-02T09:51:15.803Z</updated>
    
    <content type="html"><![CDATA[<p>使用ffmpeg推流的rtmp协议视频无法在浏览器中播放，因此本文使用Nginx作为一个服务器，将rtmp协议的媒体流转换为http+flv格式</p><h1 id="安装Nginx与nginx-http-flv-module"><a href="#安装Nginx与nginx-http-flv-module" class="headerlink" title="安装Nginx与nginx-http-flv-module"></a>安装Nginx与nginx-http-flv-module</h1><p>下载nginx-http-flv-module源码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/winshining/nginx-http-flv-module.git</span><br></pre></td></tr></table></figure><p>下载nginx源码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://nginx.org/download/nginx-1.24.0.tar.gz</span><br><span class="line">tar xzf nginx-1.24.0.tar.gz</span><br></pre></td></tr></table></figure><p>也可以在<a href="https://nginx.org/en/download.html">Nginx官网</a>查看需要的版本。</p><p>安装pcre、zlib、openssl</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install libpcre3 libpcre3-dev zlib1g-dev openssl libssl-dev</span><br></pre></td></tr></table></figure><p>开始编译，需要把<code>/path/to/nginx-http-flv-module</code>替换为nginx-http-flv-module源码的下载目录，我这里是&#x2F;home&#x2F;sun&#x2F;nginx-http-flv-module</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> nginx-1.24.0/</span><br><span class="line">./configure --add-module=/path/to/nginx-http-flv-module</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><h1 id="Nginx配置"><a href="#Nginx配置" class="headerlink" title="Nginx配置"></a>Nginx配置</h1><p>打开<code>/usr/local/nginx/conf</code>目录，修改<code>nginx.conf</code>配置文件。</p><p>我这里把http服务器设置为8080，rtmp服务器设为1935，这里需要注意的是，如果要访问<code>http://localhost:8080/stat</code>来查看Nginx服务器运行情况，需要把nginx-http-flv-module源码目录下的<code>stat.xsl</code>文件拷贝至<code>/var/www/rtmp/</code>文件夹。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">worker_processes  1;#worker进程的数量</span><br><span class="line">error_log  logs/error.log  error;</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;#每个worker进程可以接收多少个网络连接</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    include       mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen       8080;</span><br><span class="line">        server_name  localhost;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">            root   docs/html;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        error_page   500 502 503 504  /50x.html;</span><br><span class="line">        location = /50x.html &#123;</span><br><span class="line">            root   html;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">       location /live &#123;</span><br><span class="line">            flv_live on; #open flv live streaming (subscribe)</span><br><span class="line">            chunked_transfer_encoding on; #open &#x27;Transfer-Encoding: chunked&#x27; response</span><br><span class="line">        #不增加以下这两行配置的话，无法使用浏览器获取视频流</span><br><span class="line">        add_header &#x27;Access-Control-Allow-Origin&#x27; &#x27;*&#x27;; #add additional HTTP header</span><br><span class="line">            add_header &#x27;Access-Control-Allow-Credentials&#x27; &#x27;true&#x27;; #add additional HTTP header</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        location /stat &#123;</span><br><span class="line">            #configuration of streaming &amp; recording statistics</span><br><span class="line"></span><br><span class="line">            rtmp_stat all;</span><br><span class="line">            rtmp_stat_stylesheet stat.xsl;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        location /stat.xsl &#123;</span><br><span class="line">            root /var/www/rtmp; #specify in where stat.xsl located</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        location /control &#123;</span><br><span class="line">            rtmp_control all; #configuration of control module of rtmp</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rtmp_auto_push on;</span><br><span class="line">rtmp_auto_push_reconnect 1s;</span><br><span class="line">rtmp_socket_dir /tmp;</span><br><span class="line"></span><br><span class="line">rtmp &#123;</span><br><span class="line">    out_queue   4096;</span><br><span class="line">    out_cork    16;</span><br><span class="line">    max_streams 128;</span><br><span class="line">    timeout             15s;</span><br><span class="line">    drop_idle_publisher 15s;</span><br><span class="line"> </span><br><span class="line"> log_interval 5s; #log 模块在 access.log 中记录日志的间隔时间，对调试非常有用</span><br><span class="line">    log_size     1m; #log 模块用来记录日志的缓冲区大小</span><br><span class="line">    </span><br><span class="line">    server &#123;</span><br><span class="line">        listen 1935;</span><br><span class="line">        server_name localhost;</span><br><span class="line"></span><br><span class="line">        application myapp &#123;</span><br><span class="line">            live on;</span><br><span class="line">            gop_cache off; #open GOP cache for low latency</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>推流地址为<code>rtmp://example.com[:port]/appname/streamname</code>，根据以上配置，本机的地址为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rtmp://127.0.0.1:1935/myapp/mystream</span><br></pre></td></tr></table></figure><p>拉流地址为<code>http://example.com[:port]/dir?[port=xxx&amp;]app=appname&amp;stream=streamname</code>，根据以上配置，本机的地址为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1:8080/live?port=1935&amp;app=myapp&amp;stream=mystream</span><br></pre></td></tr></table></figure><h1 id="推流至Nginx服务器"><a href="#推流至Nginx服务器" class="headerlink" title="推流至Nginx服务器"></a>推流至Nginx服务器</h1><p>nginx的使用命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo /usr/local/nginx/sbin/nginx -t <span class="comment">#检查配置文件是否正确</span></span><br><span class="line">sudo /usr/local/nginx/sbin/nginx<span class="comment">#启动nginx服务器</span></span><br><span class="line">sudo /usr/local/nginx/sbin/nginx -s stop<span class="comment">#关闭nginx服务器</span></span><br><span class="line">sudo /usr/local/nginx/sbin/nginx -s reload<span class="comment">#重启nginx服务器</span></span><br></pre></td></tr></table></figure><p>使用ffmpeg读取摄像头的内容并编码成h264格式并使用rtmp协议推流至nginx服务器中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/bin/ffmpeg -input_format mjpeg  -video_size 640x480 -f v4l2  -i /dev/video0 -c:v libx264 -tune zerolatency -preset ultrafast -g 1 -f flv rtmp://127.0.0.1:1935/myapp/mystream</span><br></pre></td></tr></table></figure><p><code>-g 1</code>表示关键帧间隔为1, <code>-tune zerolatency</code>表示编码器的参数配置为低延迟做优化，<code>-preset ultrafast</code>表示降低输出画质以降低cpu利用率、提高编码速度。</p><p>这里也可以使用OBS来进行推流，需要注意，此时推流地址为<code>rtmp://127.0.0.1:1935/myapp</code>，推流码为<code>mystream</code>。</p><p>使用ffplay查看http+flv格式的直播</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~/bin/ffplay <span class="string">&quot;http://127.0.0.1:8080/live?port=1935&amp;app=myapp&amp;stream=mystream&quot;</span></span><br><span class="line">~/bin/ffplay <span class="string">&quot;http://192.168.164.33:8080/live?port=1935&amp;app=myapp&amp;stream=mystream&quot;</span></span><br></pre></td></tr></table></figure><p>经过测试，这样会有2~3秒的延迟，在ffplay命令中添加<code>-fflags nobuffer</code>选项可以实现1秒左右的延迟</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~/bin/ffplay <span class="string">&quot;http://127.0.0.1:8080/live?port=1935&amp;app=myapp&amp;stream=mystream&quot;</span> -fflags nobuffer</span><br><span class="line">~/bin/ffplay <span class="string">&quot;http://192.168.164.33:8080/live?port=1935&amp;app=myapp&amp;stream=mystream&quot;</span> -fflags nobuffer</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;使用ffmpeg推流的rtmp协议视频无法在浏览器中播放，因此本文使用Nginx作为一个服务器，将rtmp协议的媒体流转换为http+flv格式&lt;/p&gt;
&lt;h1 id=&quot;安装Nginx与nginx-http-flv-module&quot;&gt;&lt;a href=&quot;#安装Nginx与ngi</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>使用C++ fastdeploy库部署yolov5lite模型</title>
    <link href="https://big7ng.github.io/2024/03/24/fastdeploy/"/>
    <id>https://big7ng.github.io/2024/03/24/fastdeploy/</id>
    <published>2024-03-23T16:35:54.365Z</published>
    <updated>2024-03-23T16:39:15.144Z</updated>
    
    <content type="html"><![CDATA[<p>使用python的fastdeploy库部署yolov5lite模型非常简单，只需要pip命令安装即可，但其运行速度慢，不适合在生产环境中使用，因此本文使用C++ fastdeploy库部署yolov5lite模型。</p><h1 id="运行官方demo"><a href="#运行官方demo" class="headerlink" title="运行官方demo"></a>运行官方demo</h1><p>clone官方源码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/PaddlePaddle/FastDeploy.git</span><br></pre></td></tr></table></figure><p>进入yolov5lite example目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ./FastDeploy/examples/vison/detection/yolov5lite</span><br></pre></td></tr></table></figure><p>下载预编译Fastdeploy库，需要在根据自己的硬件平台下载相应版本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir build</span><br><span class="line">cd build</span><br><span class="line">wget https://bj.bcebos.com/fastdeploy/release/cpp/fastdeploy-linux-aarch64-1.0.0.tgz</span><br><span class="line">tar xvf fastdeploy-linux-aarch64-1.0.0.tgz</span><br></pre></td></tr></table></figure><p>编译demo程序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cmake .. -DFASTDEPLOY_INSTALL_DIR=$&#123;PWD&#125;/fastdeploy-linux-aarch64-1.0.0.tgz</span><br><span class="line">make -j</span><br></pre></td></tr></table></figure><p>下载官方提供的模型与文件（也可以自己准备）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://bj.bcebos.com/paddlehub/fastdeploy/v5Lite-g-sim-640.onnx</span><br><span class="line">wget https://gitee.com/paddlepaddle/PaddleDetection/raw/release/2.4/demo/000000014439.jpg</span><br></pre></td></tr></table></figure><p>运行程序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./infer_demo v5Lite-g-sim-640.onnx 000000014439.jpg 0</span><br></pre></td></tr></table></figure><p>如果运行程序后出现了这个错误：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./infer_demo: error while loading shared libraries: libonnxruntime.so.1.12.0: cannot open shared object file: No such file or directory</span><br></pre></td></tr></table></figure><p>通过执行如下命令，将FastDeploy的库路径添加到环境变量之后，重新执行二进制程序。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source /home/user/FastDeploy/build/compiled_fastdeploy_sdk/fastdeploy_init.sh</span><br></pre></td></tr></table></figure><h1 id="编译Fastdeploy"><a href="#编译Fastdeploy" class="headerlink" title="编译Fastdeploy"></a>编译Fastdeploy</h1><p>官方提供的Fastdeploy库自带的opencv库<strong>无法支持Video的读取</strong>，以及<strong>imshow等可视化界面功能</strong>。若要使用这些功能，则需要自行编译，编译时通过<code>-DOPENCV_DIRECTORY</code>来指定环境中的OpenCV。</p><p>使用包管理器下载Opencv库，opencv库的地址一般在&#x2F;usr&#x2F;lib&#x2F;aarch64-linux-gnu&#x2F;cmake&#x2F;opencv4下，需要根据自己的硬件平台切换。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install libopencv-dev</span><br></pre></td></tr></table></figure><p>开始编译，本文只需要实现视觉功能，更多编译参数参考<a href="https://github.com/PaddlePaddle/FastDeploy/blob/develop/docs/cn/build_and_install/cpu.md">官方文档</a>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cmake .. -DENABLE_ORT_BACKEND=ON \</span><br><span class="line">         -DCMAKE_INSTALL_PREFIX=$&#123;PWD&#125;/compiled_fastdeploy_sdk \</span><br><span class="line">         -DENABLE_VISION=ON \</span><br><span class="line">         -DOPENCV_DIRECTORY=/usr/lib/aarch64-linux-gnu/cmake/opencv4 </span><br><span class="line">make -j1</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>根据编译出的sdk位置编译demo程序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cmake .. -DFASTDEPLOY_INSTALL_DIR=/home/user/FastDeploy/build/compiled_fastdeploy_sdk/</span><br><span class="line">make -j</span><br></pre></td></tr></table></figure><h1 id="踩坑点"><a href="#踩坑点" class="headerlink" title="踩坑点"></a>踩坑点</h1><p>官方提供的demo程序只支持以640结尾的模型，即只支持640输入，因为model类的默认size为640，若要改用320模型，需要在代码模型对象中进行修改：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">auto model = fastdeploy::vision::detection::YOLOv5Lite(model_file);</span><br><span class="line">model.size = &#123;320, 320&#125;; #添加这一行</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;使用python的fastdeploy库部署yolov5lite模型非常简单，只需要pip命令安装即可，但其运行速度慢，不适合在生产环境中使用，因此本文使用C++ fastdeploy库部署yolov5lite模型。&lt;/p&gt;
&lt;h1 id=&quot;运行官方demo&quot;&gt;&lt;a hre</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>源码编译ffmpeg</title>
    <link href="https://big7ng.github.io/2024/03/21/ffmpeg/"/>
    <id>https://big7ng.github.io/2024/03/21/ffmpeg/</id>
    <published>2024-03-21T05:54:46.313Z</published>
    <updated>2024-03-30T09:39:01.978Z</updated>
    
    <content type="html"><![CDATA[<p>使用ffmpeg把非原始格式的内容输入videoloopback设备时发生如下错误</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">V4L2 output device supports only a single raw video stream</span><br></pre></td></tr></table></figure><p>查看<a href="https://github.com/umlaeute/v4l2loopback/issues/130">github issue</a>发现原因为debian包管理器自带的ffmpeg版本太低，不支持把非原始格式的内容输入videoloopback设备，需要重新编译高版本ffmpeg，具体可以参考官方<a href="https://trac.ffmpeg.org/wiki/CompilationGuide/Ubuntu">ubuntu编译文档</a>。</p><h1 id="下载源码"><a href="#下载源码" class="headerlink" title="下载源码"></a>下载源码</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p ~/ffmpeg_sources ~/bin</span><br><span class="line">cd ~/ffmpeg_sources</span><br><span class="line">wget https://ffmpeg.org/releases/ffmpeg-5.1.4.tar.gz</span><br><span class="line">tar xzvf ffmpeg-5.1.4.tar.gz</span><br><span class="line">cd ffmpeg-5.1.4/</span><br></pre></td></tr></table></figure><h1 id="安装第三方库"><a href="#安装第三方库" class="headerlink" title="安装第三方库"></a>安装第三方库</h1><p>ffmpeg在编译时可以选择是否包含某些额外功能，这些额外功能需要安装特定的第三方库</p><h3 id="nasm"><a href="#nasm" class="headerlink" title="nasm"></a>nasm</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install nasm</span><br></pre></td></tr></table></figure><p>需要版本大于2.13，包管理器下载的版本为2.15</p><h3 id="libx264"><a href="#libx264" class="headerlink" title="libx264"></a>libx264</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libx264-dev</span><br></pre></td></tr></table></figure><p>需要版本大于118，包管理器下载的版本为160</p><p>在编译时需要开启 <code>--enable-gpl --enable-libx264</code>选项</p><h3 id="libvpx"><a href="#libvpx" class="headerlink" title="libvpx"></a>libvpx</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libvpx-dev</span><br></pre></td></tr></table></figure><p>需要版本大于1.4.0 ，包管理器下载的版本为1.9.0</p><p>在编译时需要开启<code>--enable-libvpx</code>选项</p><h3 id="libfdk-aac"><a href="#libfdk-aac" class="headerlink" title="libfdk-aac"></a>libfdk-aac</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libfdk-aac-dev</span><br></pre></td></tr></table></figure><p>无版本要求</p><p>编译时需开启 <code>--enable-libfdk-aac --enable-nonfree</code>选项</p><h3 id="libdav1d"><a href="#libdav1d" class="headerlink" title="libdav1d"></a>libdav1d</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libdav1d-dev</span><br></pre></td></tr></table></figure><p>无版本要求</p><p>编译时需开启<code>--enable-libdav1d</code>选项</p><h1 id="编译ffmpeg"><a href="#编译ffmpeg" class="headerlink" title="编译ffmpeg"></a>编译ffmpeg</h1><p>安装依赖项</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">sudo apt -y install \</span><br><span class="line">  autoconf \</span><br><span class="line">  automake \</span><br><span class="line">  build-essential \</span><br><span class="line">  cmake \</span><br><span class="line">  git-core \</span><br><span class="line">  libass-dev \</span><br><span class="line">  libfreetype6-dev \</span><br><span class="line">  libgnutls28-dev \</span><br><span class="line">  libmp3lame-dev \</span><br><span class="line">  libsdl2-dev \</span><br><span class="line">  libtool \</span><br><span class="line">  libva-dev \</span><br><span class="line">  libvdpau-dev \</span><br><span class="line">  libvorbis-dev \</span><br><span class="line">  libxcb1-dev \</span><br><span class="line">  libxcb-shm0-dev \</span><br><span class="line">  libxcb-xfixes0-dev \</span><br><span class="line">  meson \</span><br><span class="line">  ninja-build \</span><br><span class="line">  pkg-config \</span><br><span class="line">  texinfo \</span><br><span class="line">  wget \</span><br><span class="line">  yasm \</span><br><span class="line">  zlib1g-dev</span><br></pre></td></tr></table></figure><p>开始编译</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">./configure \</span><br><span class="line">  --prefix=&quot;$HOME/ffmpeg_build&quot; \</span><br><span class="line">  --extra-cflags=&quot;-I$HOME/ffmpeg_build/include&quot; \</span><br><span class="line">  --extra-ldflags=&quot;-L$HOME/ffmpeg_build/lib&quot; \</span><br><span class="line">  --extra-libs=&quot;-lpthread -lm&quot; \</span><br><span class="line">  --ld=&quot;g++&quot; \</span><br><span class="line">  --bindir=&quot;$HOME/bin&quot; \</span><br><span class="line">  --enable-gpl \</span><br><span class="line">  --enable-gnutls \</span><br><span class="line">  --enable-libass \</span><br><span class="line">  --enable-libfdk-aac \</span><br><span class="line">  --enable-libfreetype \</span><br><span class="line">  --enable-libmp3lame \</span><br><span class="line">  --enable-libdav1d \</span><br><span class="line">  --enable-libvorbis \</span><br><span class="line">  --enable-libvpx \</span><br><span class="line">  --enable-libx264 \</span><br><span class="line">  --enable-nonfree</span><br><span class="line">  </span><br><span class="line"> PATH=&quot;$HOME/bin:$PATH&quot; make -j4</span><br><span class="line"> make install</span><br><span class="line"> source ~/.profile</span><br></pre></td></tr></table></figure><p>此时可以直接在终端中输入ffmpeg、ffplay进行使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -version</span><br><span class="line">ffplay -version</span><br></pre></td></tr></table></figure><p>但是发现在终端上输入以上命令仍然是老版本，需要指定ffmpeg、ffplay执行文件才行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~/bin/ffmpeg -version</span><br><span class="line">~/bin/ffmpeg -version</span><br></pre></td></tr></table></figure><h1 id="卸载ffmpeg"><a href="#卸载ffmpeg" class="headerlink" title="卸载ffmpeg"></a>卸载ffmpeg</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf ~/ffmpeg_build ~/bin/&#123;ffmpeg,ffprobe,ffplay,x264,x265&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;使用ffmpeg把非原始格式的内容输入videoloopback设备时发生如下错误&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>使用v4l2loopback实现一个摄像头同时实现IP摄像头和OpenCV视频处理</title>
    <link href="https://big7ng.github.io/2024/03/18/v4l2/"/>
    <id>https://big7ng.github.io/2024/03/18/v4l2/</id>
    <published>2024-03-18T08:41:48.322Z</published>
    <updated>2024-03-23T16:34:41.914Z</updated>
    
    <content type="html"><![CDATA[<p>一个程序在读取摄像头时，如果另一个程序读取这个摄像头，会提示“设备繁忙”的错误，本文使用v4l2loopback将一个真实摄像头虚拟成两个，实现两个程序读取同一个摄像头拍摄的视频。</p><h1 id="v4l-utils"><a href="#v4l-utils" class="headerlink" title="v4l-utils"></a>v4l-utils</h1><p>v4l-utils使用来管理媒体设备的一系列工具，首先安装v4l-utils工具</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install v4l-utils</span><br></pre></td></tr></table></figure><p>将媒体设备与开发板连接（USB摄像头），若连接成功，在<code>/dev/</code>目录下会出现video设备</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> /dev/video*</span><br></pre></td></tr></table></figure><p>使用v4l-utils中的v4l-ctl命令工具查看设备信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">v4l2-ctl --list-devices <span class="comment">#查看连接的v4l2设备</span></span><br><span class="line">v4l2-ctl --list-formats  <span class="comment">#查看设备支持的拍摄格式</span></span><br><span class="line">v4l2-ctl -d  /dev/video0 --all <span class="comment">#查看设备的详细信息</span></span><br></pre></td></tr></table></figure><p>需要注意的是，如果摄像头不支持h264格式录制（例如本博客使用的摄像头支持MJPG与YUYV），那传输视频流的时候只能使用rtsp或rtmp。http+flv、hls等格式无法使用，因为他们只支持h264格式的视频流。</p><h1 id="v4l2rtspserver"><a href="#v4l2rtspserver" class="headerlink" title="v4l2rtspserver"></a>v4l2rtspserver</h1><h4 id="RTSP协议"><a href="#RTSP协议" class="headerlink" title="RTSP协议"></a>RTSP协议</h4><p>Real-Time Messaging Protocol（RTMP）和The Real-Time Streaming Protocol (RTSP)是目前使用较广泛的流媒体协议之一。</p><p>RTSP传输一般需要2-3个通道，命令和数据通道分离，HTTP和RTMP一般在TCP一个通道上传输命令和数据。RTSP 本身不传输数据流，而是配合 RTP&#x2F;RTCP 一起使用，RTSP 负责控制传输。</p><p>由于 Flash 的普及度降低，chrome与firefox均停止了对Flash的支持，RTMP 的使用也在逐渐减少，被如 HLS（HTTP Live Streaming）和 DASH（Dynamic Adaptive Streaming over HTTP）等其他流媒体传输协议替代。</p><h4 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h4><p><a href="https://github.com/mpromonet/v4l2rtspserver">v4l2rtspserver</a>是一个v4l2设备的rtsp服务器，首先下载v4l2rtpserver源码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone --recursive https://github.com/mpromonet/v4l2rtspserver.git </span><br></pre></td></tr></table></figure><p>v4l2rtspsever的依赖库如下：</p><ul><li>liblivemedia-dev：会在编译的时候自动下载</li><li>libv4l2cpp：已作为子模块包含在源码中</li><li>liblog4cpp5-dev ：可选项，增强日志功能</li><li>libasound2-dev ：可选项，增加音频传输功能</li></ul><p>开始编译</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd v4l2rtspserver</span><br><span class="line">cmake . &amp;&amp; make</span><br></pre></td></tr></table></figure><p>编译完成后，开始运行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./videortspserver -v -W 640 -H 480 /dev/video0</span><br></pre></td></tr></table></figure><p>运行该命令后会输出直播url，可以输入至VLC播放器或者IP摄像头app进行远程查看。</p><p>.&#x2F;ffmpeg -f v4l2 -input_format mjpeg -i &#x2F;dev&#x2F;video0 -c:v mjpeg -f v4l2 &#x2F;dev&#x2F;video2</p><h1 id="v4l2loopback"><a href="#v4l2loopback" class="headerlink" title="v4l2loopback"></a>v4l2loopback</h1><p>v4l2loopback可以创建多个虚拟的媒体设备，我们可以把虚拟设备当作摄像头来使用，下载v4l2源码并进行编译</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/umlaeute/v4l2loopback.git</span><br><span class="line">cd v4l2loopback</span><br><span class="line">make</span><br></pre></td></tr></table></figure><p>以下命令可以不执行，不影响使用，执行的话可以使用<code>modprobe</code>命令更方便地实现内核模块安装，但是本文在这一步出现了问题，因此放弃了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo make install </span><br></pre></td></tr></table></figure><p>在v4l2loopback目录中执行以下命令，安装v4l2loopback内核模块，一下命令将</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo insmod v4l2loopback.ko devices=2 exclusive_caps=1,1 video_nr=2,3 card_label=<span class="string">&quot;IP Camera&quot;</span>,<span class="string">&quot;OpenCV Camera&quot;</span></span><br></pre></td></tr></table></figure><p>也可以使用v4l2loopback-ctl来动态管理虚拟设备，但是还没有测试过</p><h1 id="Mplayer"><a href="#Mplayer" class="headerlink" title="Mplayer"></a>Mplayer</h1><p>可以使用mplayer来测试虚拟设备，使用包管理器自带的mplayer会报错</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mplayer: symbol lookup error: mplayer: undefined symbol: av_alloc_vdpaucontext, version LIBAVCODEC_58</span><br></pre></td></tr></table></figure><p>重新编译mplayer可以解决这个问题</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sudo apt remove mplayer</span><br><span class="line">wget https://mplayerhq.hu/MPlayer/releases/MPlayer-1.5.tar.gz</span><br><span class="line">tar -xzvf MPlayer-1.5.tar.gz</span><br><span class="line"><span class="built_in">cd</span> MPlayer-1.5/</span><br><span class="line">./configure </span><br><span class="line">make -j6</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><p>开始播放</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mplayer tv:// -tv driver=v4l2:device=/dev/video0</span><br></pre></td></tr></table></figure><h1 id="ffmpeg"><a href="#ffmpeg" class="headerlink" title="ffmpeg"></a>ffmpeg</h1><p>使用ffmpeg把视频流&#x2F;真实摄像头输入虚拟设备中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -f v4l2 -i /dev/video0 -f v4l2 /dev/video2</span><br><span class="line">ffplay /dev/video2</span><br></pre></td></tr></table></figure><p>使用ffmpeg将摄像头的内容复制到<code>/dev/video2</code>与<code>/dev/video3</code>两个虚拟设备中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./ffmpeg -f v4l2 -input_format mjpeg -i /dev/video0 -c:v copy -f v4l2 /dev/video2 -c:v copy -f v4l2 /dev/video3</span><br></pre></td></tr></table></figure><p>此时就可以使用v4l2rtspserver读取<code>/dev/video2</code>中的内容，使用opencv读取<code>/dev/video3</code>中的内容了</p><h1 id="v4l2tools"><a href="#v4l2tools" class="headerlink" title="v4l2tools"></a>v4l2tools</h1><p>v4l2tools是一个可以压缩、复制v4l2设备的工具，本文中使用ffmpeg代替了这个工具</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install libtool autoconf</span><br><span class="line">git clone --recursive https://github.com/mpromonet/v4l2tools</span><br><span class="line">make </span><br><span class="line">make install</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;一个程序在读取摄像头时，如果另一个程序读取这个摄像头，会提示“设备繁忙”的错误，本文使用v4l2loopback将一个真实摄像头虚拟成两个，实现两个程序读取同一个摄像头拍摄的视频。&lt;/p&gt;
&lt;h1 id=&quot;v4l-utils&quot;&gt;&lt;a href=&quot;#v4l-utils&quot; cl</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>编译并使用Qemu运行一个基于busybox的最小操作系统</title>
    <link href="https://big7ng.github.io/2024/02/19/busybox_kernel/"/>
    <id>https://big7ng.github.io/2024/02/19/busybox_kernel/</id>
    <published>2024-02-19T07:23:59.743Z</published>
    <updated>2024-02-19T20:00:19.042Z</updated>
    
    <content type="html"><![CDATA[<p>编译环境为ubuntu 18.04</p><h1 id="编译kernel"><a href="#编译kernel" class="headerlink" title="编译kernel"></a>编译kernel</h1><p>安装编译工具</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install bc binutils bison dwarves flex gcc git gnupg2 gzip libelf-dev libncurses5-dev libssl-dev make openssl pahole perl-base rsync tar xz-utils</span><br></pre></td></tr></table></figure><p>下载并编译内核代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">wget https://cdn.kernel.org/pub/linux/kernel/v4.x/linux-4.9.229.tar.xz</span><br><span class="line">tar xvf linux-4.9.229.tar.xz</span><br><span class="line"><span class="built_in">cd</span> linux-4.9.229/</span><br><span class="line"><span class="built_in">export</span> ARCH=x86</span><br><span class="line">make x86_64_defconfig</span><br><span class="line">make menuconfig</span><br><span class="line">make</span><br></pre></td></tr></table></figure><p>令编译的内核支持ramdisk驱动</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">General setup  ---&gt;</span><br><span class="line"></span><br><span class="line">       [*] Initial RAM filesystem and RAM disk (initramfs/initrd) support</span><br><span class="line"></span><br><span class="line">Device Drivers  ---&gt;</span><br><span class="line"></span><br><span class="line">       [*] Block devices  ---&gt;</span><br><span class="line"></span><br><span class="line">               &lt;*&gt;   RAM block device support</span><br><span class="line"></span><br><span class="line">               (65536) Default RAM disk size (kbytes)</span><br></pre></td></tr></table></figure><h1 id="Busybox"><a href="#Busybox" class="headerlink" title="Busybox"></a>Busybox</h1><p>编译Busybox</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tar xvf busybox-1.30.0.tar.bz2</span><br><span class="line"><span class="built_in">cd</span> busybox-1.30.0/</span><br><span class="line">make menuconfig</span><br><span class="line">make</span><br></pre></td></tr></table></figure><p>把busybox配置为静态编译，这样busybox在运行的时候就不需要额外的动态链接库了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Busybox Settings  ---&gt;</span><br><span class="line">      Build Options  ---&gt;</span><br><span class="line">            [*] Build BusyBox as a static binary (no shared libs)</span><br></pre></td></tr></table></figure><p>配置根文件系统</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> _install/</span><br><span class="line"><span class="built_in">mkdir</span> etc dev mnt</span><br><span class="line"><span class="built_in">mkdir</span> -p proc sys tmp mnt</span><br><span class="line"><span class="built_in">mkdir</span> -p etc/init.d</span><br><span class="line">vim etc/fstab</span><br><span class="line">vim etc/init.d/rcS</span><br><span class="line"><span class="built_in">chmod</span> 755 etc/init.d/rcS</span><br><span class="line">vim etc/inittab</span><br><span class="line"><span class="built_in">chmod</span> 755 etc/inittab</span><br><span class="line"><span class="built_in">cd</span> dev/</span><br><span class="line">sudo su</span><br><span class="line"><span class="built_in">mknod</span> console c 5 1<span class="comment">#mknod [选项] [名称] [类型] [主设备号] [次设备号]</span></span><br><span class="line"><span class="built_in">mknod</span> null c 1 3</span><br><span class="line"><span class="built_in">mknod</span> tty1 c 4 1</span><br></pre></td></tr></table></figure><p>其中, fstab文件:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">proc        /proc           proc         defaults        0        0</span><br><span class="line">tmpfs       /tmp            tmpfs    　　defaults        0        0</span><br><span class="line">sysfs       /sys            sysfs        defaults        0        0 </span><br></pre></td></tr></table></figure><p>rcS文件:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;Welcome to tinyLinux&quot;</span></span><br><span class="line">/bin/mount -a<span class="comment">#挂载 /etc/fstab 文件中定义的所有文件系统。-a 参数表示挂载所有在 /etc/fstab 文件中列出的文件系统。</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;Remounting the root filesystem&quot;</span></span><br><span class="line">mount  -o  remount,rw  /<span class="comment">#以读写模式重新挂载根文件系统（通常是 /），使其可写入。-o remount,rw 参数表示重新挂载为读写模式。</span></span><br><span class="line"><span class="built_in">mkdir</span> -p /dev/pts<span class="comment">#挂载伪终端文件系统 (devpts) 到 /dev/pts 目录。-t devpts 参数指定文件系统类型为 devpts。</span></span><br><span class="line">mount -t devpts devpts /dev/pts</span><br><span class="line"><span class="built_in">echo</span> /sbin/mdev &gt; /proc/sys/kernel/hotplug<span class="comment">#把/sbin/mdev写到/proc/sys/kernel/hotplug文件里,当有热插拔事件产生时，内核会调用/proc/sys/kernel/hotplug文件里指定的应用程序来处理热插拔事件</span></span><br><span class="line">mdev -s<span class="comment">#启动 mdev 守护进程，它用于在 Linux 系统中自动创建和管理设备节点。-s 参数表示以守护进程模式运行。</span></span><br></pre></td></tr></table></figure><p>mdev是busybox提供的一个工具，相当于简化版的udev。通过描述sysfs下的dev节点，在系统启动和热插拔或动态加载驱动程序时，自动创建设备节点。文件系统中的&#x2F;dev目录下的设备节点都是由mdev创建的。</p><p><a href="https://git.busybox.net/busybox/tree/examples/inittab">inittab</a>文件:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># Format for each entry: &lt;id&gt;:&lt;runlevels&gt;:&lt;action&gt;:&lt;process&gt;</span><br><span class="line"># &lt;id&gt;: WARNING: This field has a non-traditional meaning for BusyBox init!</span><br><span class="line"># &lt;runlevels&gt;: The runlevels field is completely ignored.</span><br><span class="line"># &lt;action&gt;: Valid actions include: sysinit, wait, once, respawn, askfirst, shutdown, restart and ctrlaltdel.</span><br><span class="line"># &lt;process&gt;: Specifies the process to be executed and it&#x27;s command line.</span><br><span class="line"></span><br><span class="line"># Note below that we prefix the shell commands with a &quot;-&quot; to indicate to the</span><br><span class="line"># shell that it is supposed to be a login shell.  Normally this is handled by</span><br><span class="line"># login, but since we are bypassing login in this case, BusyBox lets you do</span><br><span class="line"># this yourself...</span><br><span class="line"></span><br><span class="line">::sysinit:/etc/init.d/rcS</span><br><span class="line">::respawn:-/bin/sh</span><br><span class="line">::askfirst:-/bin/sh</span><br><span class="line">::ctrlaltdel:/bin/umount -a -r</span><br></pre></td></tr></table></figure><p>烧录镜像文件</p><p>将如下内容拷贝至<code>make_rootfs.sh</code>文件中:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">rm</span> -rf rootfs.ext3</span><br><span class="line"><span class="built_in">rm</span> -rf fs</span><br><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/zero of=./rootfs.ext3 bs=1M count=32</span><br><span class="line">mkfs.ext3 rootfs.ext3</span><br><span class="line"><span class="built_in">mkdir</span> fs</span><br><span class="line">mount -o loop rootfs.ext3 ./fs</span><br><span class="line"><span class="built_in">cp</span> -rf ./_install/* ./fs</span><br><span class="line">umount ./fs</span><br><span class="line">gzip --best -c rootfs.ext3 &gt; rootfs.img.gz</span><br></pre></td></tr></table></figure><p>运行脚本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh make_rootfs.sh</span><br></pre></td></tr></table></figure><h1 id="运行系统"><a href="#运行系统" class="headerlink" title="运行系统"></a>运行系统</h1><p>安装qemu</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install qemu</span><br></pre></td></tr></table></figure><p>启动qemu</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-x86_64   -kernel ./linux-4.9.229/arch/x86_64/boot/bzImage    -initrd ./busybox-1.30.0/rootfs.img.gz     -append <span class="string">&quot;root=/dev/ram init=/linuxrc&quot;</span>    -serial file:output.txt  -curses</span><br></pre></td></tr></table></figure><ul><li><code>-curses</code>: Normally, QEMU uses SDL to display the VGA output. With this option, QEMU can display the VGA output when in text mode using a curses&#x2F;ncurses interface. Nothing is displayed in graphical mode.<code>-curses</code> works over ssh.</li><li><code>-serial</code>:用于配置虚拟机的串行端口。该选项可以用于将虚拟机与主机之间建立串行通信连接，以便在虚拟机中模拟串行设备的输入和输出。使用 <code>-serial file:filename</code> 将串行输出保存到文件中进行分析。以下是一些常用的 <code>-serial</code> 选项参数：<ul><li><code>stdio</code>：将虚拟机的串行输入输出重定向到主机的标准输入输出（通常是终端窗口）。</li><li><code>file:filename</code>：将虚拟机的串行输出重定向到指定的文件中。</li><li><code>tcp:host:port</code>：通过 TCP&#x2F;IP 连接将虚拟机的串行输入输出重定向到指定的主机和端口。</li><li><code>udp:host:port</code>：通过 UDP 连接将虚拟机的串行输入输出重定向到指定的主机和端口。</li></ul></li><li><code>-append</code>:用于指定要传递给内核的命令行参数。当使用 -kernel 选项加载一个内核映像时，通常需要将一些参数传递给内核，以配置虚拟机的启动行为。这些参数可以通过 -append 选项来指定。</li></ul><p>在生成的终端中关闭系统, 即可退出qemu</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">poweroff</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;编译环境为ubuntu 18.04&lt;/p&gt;
&lt;h1 id=&quot;编译kernel&quot;&gt;&lt;a href=&quot;#编译kernel&quot; class=&quot;headerlink&quot; title=&quot;编译kernel&quot;&gt;&lt;/a&gt;编译kernel&lt;/h1&gt;&lt;p&gt;安装编译工具&lt;/p&gt;
&lt;figure cl</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>rk3568开发板使用Docker安装Openwrt实现旁路由</title>
    <link href="https://big7ng.github.io/2024/01/23/docker_bypass/"/>
    <id>https://big7ng.github.io/2024/01/23/docker_bypass/</id>
    <published>2024-01-23T11:39:00.182Z</published>
    <updated>2024-01-23T17:37:19.361Z</updated>
    
    <content type="html"><![CDATA[<p>开发板为Lubancat2n<br>系统为ubuntu20.04<br>主路由器网段为192.168.124.0&#x2F;24,  网关为192.168.124.1</p><img src="\img\network_tp.png" style="zoom:25%;" /><h1 id="安装与配置Docker"><a href="#安装与配置Docker" class="headerlink" title="安装与配置Docker"></a>安装与配置Docker</h1><p>根据<a href="https://docs.docker.com/engine/install/ubuntu/">官网的步骤</a>, 安装Docker。<br>安装portainer容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume create portainer_data</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 8000:8000 -p 9443:9443 --name portainer --restart=always -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer-ce:latest</span><br></pre></td></tr></table></figure><p>安装piaoyizy提供的<a href="https://hub.docker.com/r/piaoyizy/openwrt-aarch64">openwrt镜像</a>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull piaoyizy/openwrt-aarch64:latest</span><br></pre></td></tr></table></figure><p>将选用的网卡打开混杂模式, 需要将下述命令中的<code>eth3</code>修改为实际使用的网卡:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ip link set eth3 promisc on</span><br></pre></td></tr></table></figure><ul><li><p>可以使用<code>ip a</code>或<code>ifconfig</code>查看本机的网卡.</p></li><li><p>混杂模式（promiscuous mode）是计算机网络中的术语。是指一台机器的网卡能够接收所有经过它的数据流，而不论其目的地址是否是它。</p><p><em>一般计算机网卡都工作在非混杂模式下，此时网卡只接受来自网络端口的目的地址指向自己的数据。当网卡工作在混杂模式下时，网卡将来自接口的所有数据都捕获并交给相应的驱动程序。网卡的混杂模式一般在网络管理员分析网络数据作为网络故障诊断手段时用到，同时这个模式也被网络黑客利用来作为网络数据窃听的入口。</em></p></li></ul><p>创建docker network, 这里需要将网段与网关修改以符合主路由的设置, 将<code>parent</code>设置为使用的物理网卡:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network create -d macvlan --subnet=192.168.124.0/24 --gateway=192.168.124.1 -o parent=eth3 macnet</span><br></pre></td></tr></table></figure><ul><li>macvlan为Docker network<a href="https://docs.docker.com/network/drivers/">提供的驱动</a>中的一种。 macvlan是linux中网络虚拟化的一种技术，这种技术能将 <strong>一块物理网卡虚拟成多块虚拟网卡</strong> ，相当于物理网卡施展了多重影分身之术 ，由一个变多个。 深入macvlan可以参考如下文章：<a href="https://mp.weixin.qq.com/s?__biz=MzI1OTY2MzMxOQ==&mid=2247485246&idx=1&sn=c42a3618c357ebf5f6b7b7ce78ae568f&chksm=ea743386dd03ba90ad65940321385f68f9315fec16d82a08efa12c18501d8cadf95cf9e614a2&scene=21#wechat_redirect">Macvlan</a>，<a href="https://www.cnblogs.com/bakari/p/10893589.html">Docker 网络模型之 macvlan 详解</a>，<a href="https://docs.docker.com/network/drivers/macvlan/">Docker Macvlan文档</a>。</li></ul><p>运行容器:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name=OpenWrt --restart always --privileged --network macnet --ip 192.168.124.20 piaoyizy/openwrt-aarch64:latest</span><br></pre></td></tr></table></figure><p>此时在浏览器中输入旁路由地址还不能访问openwrt页面,  因为容器中默认使用的静态分配IP地址与我们使用的不同，需要进入bash设置，在portainer控制台中进入openwrt容器的命令行界面.</p><img src="\img\portainer.png" style="zoom:67%;" /><p>修改配置文件:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/config/network</span><br></pre></td></tr></table></figure><p>替换lan网络配置如下(根据自己的网络情况填写):</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">config interface &#x27;lan&#x27;</span><br><span class="line">        option type &#x27;bridge&#x27;</span><br><span class="line">        option ifname &#x27;eth0&#x27;</span><br><span class="line">        option proto &#x27;static&#x27;</span><br><span class="line">        option ipaddr &#x27;192.168.124.20&#x27;</span><br><span class="line">        option netmask &#x27;255.255.255.0&#x27;</span><br><span class="line">        option gateway &#x27;192.168.124.1&#x27;</span><br><span class="line">        option dns &#x27;192.168.124.1&#x27;</span><br></pre></td></tr></table></figure><p>重启网络:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/network restart</span><br></pre></td></tr></table></figure><p>此时在浏览器中输入目标地址,即可访问openwrt页面,  默认账号 root 密码 password。</p><p>登录openwrt界面后, 在openwrt的网络配置中，点击接口选项，修改名为LAN的接口。</p><p>在<code>物理配置</code>中，取消勾选<code>桥接接口</code>；在<code>最下方的基本配置</code>中，关闭DHCP，勾选忽略此接口；<code>最下方的IPV6设置</code>中，<code>路由通告服务</code>、<code>DHCPv6 服务</code>和<code>NDP 代理</code>全部选择<code>已禁用</code>;<code>入站数据</code>、<code>出站数据</code>和<code>转发</code>全部选择接受；</p><h1 id="配置OpenClash"><a href="#配置OpenClash" class="headerlink" title="配置OpenClash"></a>配置OpenClash</h1><p>piaoyizy提供的openwrt镜像中包含了passwall, openClash等插件，我们可以很方便的进行使用。</p><p>在使用openClash时，出现了如下问题：<br>    开启服务后，Clash占用CPU、内存过大，Openwrt内显示的下载与上传速度非常高。后发现日志系统设置为Info模式，Clash内核会把所有的代理信息发送到网页控制台（9090端口），而这个代理信息的发送到端口9090的过程也会被当作Info再次发送到端口9090，导致无穷无尽地发送，使内核占用资源非常多。将日志信息模式修改为Warning模式即可。</p><h1 id="配置客户端"><a href="#配置客户端" class="headerlink" title="配置客户端"></a>配置客户端</h1><p>在完成上述配置后，在操作系统网络设置中关闭客户端的DHCP自动分配，选择静态分配IP，将客户端的网关、DNS服务器指向在Docker中新搭建的openwrt。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;开发板为Lubancat2n&lt;br&gt;系统为ubuntu20.04&lt;br&gt;主路由器网段为192.168.124.0&amp;#x2F;24,  网关为192.168.124.1&lt;/p&gt;
&lt;img src=&quot;&#92;img&#92;network_tp.png&quot; style=&quot;zoom:25%;&quot; </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Debian系统中实现局域网共享文件夹（samba）</title>
    <link href="https://big7ng.github.io/2023/11/05/samba/"/>
    <id>https://big7ng.github.io/2023/11/05/samba/</id>
    <published>2023-11-05T14:26:01.522Z</published>
    <updated>2023-11-05T14:54:08.468Z</updated>
    
    <content type="html"><![CDATA[<p>本文将在Debian12 bookworm系统中，通过samba服务实现网络共享文件夹，并实现外置硬盘的自动挂载。</p><h1 id="Samba"><a href="#Samba" class="headerlink" title="Samba"></a>Samba</h1><h4 id="安装samba"><a href="#安装samba" class="headerlink" title="安装samba"></a>安装samba</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install samba</span><br></pre></td></tr></table></figure><p>查看samba安装状态</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl status smbd</span><br></pre></td></tr></table></figure><p>smbd处于running状态,则安装成功</p><h4 id="配置samba"><a href="#配置samba" class="headerlink" title="配置samba"></a>配置samba</h4><p>进入samba配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/samba/smb.conf</span><br></pre></td></tr></table></figure><p>在文件末尾添加如下内容,<code>path</code>为需要共享的文件夹</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[sambashare]</span><br><span class="line">    comment = Samba on debian</span><br><span class="line">    path = /mnt/study</span><br><span class="line">    read only = no</span><br><span class="line">    browsable = yes</span><br><span class="line">    guest ok = yes</span><br></pre></td></tr></table></figure><p>配置samba登录用户名与密码,用户名需与系统用户名相同</p><p>如果在配置文件中声明<code>guest ok = yes</code>,则这一步可以跳过</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo smbpasswd -a username</span><br></pre></td></tr></table></figure><p>重启samba服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl restart smbd.service</span><br></pre></td></tr></table></figure><h1 id="自动挂载"><a href="#自动挂载" class="headerlink" title="自动挂载"></a>自动挂载</h1><p>将外置硬盘插入主机中,我们可以使用<code>mount</code>命令来挂载,如果系统重启,我们需要重新mount,接下来将配置自动挂载.</p><p>首先将硬盘插入主机,使用<code>sudo fdisk -l</code>查看块设备.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Disk /dev/sda: 931.51 GiB, 1000204886016 bytes, 1953525168 sectors</span><br><span class="line">Disk model: RTL9210 NVME</span><br><span class="line">Units: sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 33553920 bytes</span><br><span class="line">Disklabel type: gpt</span><br><span class="line">Disk identifier: 64950C9B-606E-4BBA-93D1-C032DA79C574</span><br><span class="line"></span><br><span class="line">Device     Start        End    Sectors   Size Type</span><br><span class="line">/dev/sda1     34      32767      32734    16M Microsoft reserved</span><br><span class="line">/dev/sda2  32768 1953523711 1953490944 931.5G Microsoft basic data</span><br></pre></td></tr></table></figure><p>使用mount命令挂载</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mount /dev/sda2 /mnt/study</span><br></pre></td></tr></table></figure><p>挂载后,使用<code>lsblk -f</code>查看设备信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">user@starfive:~$ lsblk -f</span><br><span class="line">NAME        FSTYPE FSVER LABEL UUID                                 FSAVAIL FSUSE% MOUNTPOINTS</span><br><span class="line">sda</span><br><span class="line">|-sda1</span><br><span class="line">`-sda2      ntfs               2921CF502C42771A                        726G    22% /mnt/study</span><br><span class="line">mtdblock0</span><br><span class="line">mtdblock1</span><br><span class="line">mtdblock2</span><br><span class="line">mmcblk1</span><br><span class="line">|-mmcblk1p1</span><br><span class="line">|-mmcblk1p2</span><br><span class="line">|-mmcblk1p3 vfat   FAT16       DC47-E0F8</span><br><span class="line">`-mmcblk1p4 ext4   1.0   root  93d1b271-9260-4414-99ba-55edab9106e7  109.1G     8% /</span><br><span class="line">nvme0n1     ext4   1.0         9decbacf-f688-4442-a107-140863a2c42f</span><br></pre></td></tr></table></figure><p>记下需要自动挂载的设备的UUID与FSTYPE,修改<code>/etc/fstab</code>文件,添加以下内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UUID=2921CF502C42771A   /mnt/study      ntfs    default 0       0</span><br></pre></td></tr></table></figure><p>保存后,下次重新启动即可实现自动挂载.</p><p>自此,samba服务就算是配置完成了,在windows系统的文件资源管理器中输入地址<code>\\&#123;配置samba服务的主机网络地址&#125;</code>即可访问共享文件夹.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文将在Debian12 bookworm系统中，通过samba服务实现网络共享文件夹，并实现外置硬盘的自动挂载。&lt;/p&gt;
&lt;h1 id=&quot;Samba&quot;&gt;&lt;a href=&quot;#Samba&quot; class=&quot;headerlink&quot; title=&quot;Samba&quot;&gt;&lt;/a&gt;Samba&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>使用Visionfive2开发板搭建clash旁路由</title>
    <link href="https://big7ng.github.io/2023/09/24/visionfive2/"/>
    <id>https://big7ng.github.io/2023/09/24/visionfive2/</id>
    <published>2023-09-24T14:07:22.654Z</published>
    <updated>2023-12-17T16:02:52.422Z</updated>
    
    <content type="html"><![CDATA[<p>作者使用的是riscv架构的Visionfive2开发板，本博客内的步骤也适用于其他开发板。交叉编译环境为ubuntu20.04。</p><h2 id="编译内核"><a href="#编译内核" class="headerlink" title="编译内核"></a>编译内核</h2><p>由于visionfive2开发板官方提供的debian镜像中的kernel未开启netfilter模块，因此我们需要重新编译内核以开启该功能，如果开启了该功能，可跳过这部分。</p><ol><li><p>安装所需工具</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install -y build-essential gcc-riscv64-linux-gnu libncurses-dev git </span><br><span class="line">sudo apt install -y flex bc bison </span><br></pre></td></tr></table></figure></li><li><p>下载源码</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/starfive-tech/linux.git</span><br><span class="line"><span class="comment"># 执行以下命令，切换到代码分支：</span></span><br><span class="line"><span class="built_in">cd</span> linux</span><br><span class="line">git checkout origin/JH7110_VisionFive2_devel</span><br><span class="line">git pull</span><br></pre></td></tr></table></figure></li><li><p>设置编译Linux内核的默认设置</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make starfive_visionfive2_defconfig CROSS_COMPILE=riscv64-linux-gnu- ARCH=riscv</span><br></pre></td></tr></table></figure><p> 修改编译Linux内核的设置，我们先使用默认的设置进行编译，编译完成后再进行修改，因此可以直接退出</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make CROSS_COMPILE=riscv64-linux-gnu- ARCH=riscv -j4 bindeb-pkg LOCALVERSION=-<span class="built_in">test</span></span><br></pre></td></tr></table></figure></li><li><p>编译内核</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make CROSS_COMPILE=riscv64-linux-gnu- ARCH=riscv -jX</span><br></pre></td></tr></table></figure></li><li><p>编译完成后，再次打开Linux内核配置页面，依次进入<code>Networking  support</code> -&gt; <code>Network option</code> -&gt;<code>Network packet filtering framework(Netfilter)</code>-&gt;<code>Core Netfilter Configuration</code>，增加内核对netfilter的redirect、nat、reject功能的支持。再次进行编译。</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make CROSS_COMPILE=riscv64-linux-gnu- ARCH=riscv menuconfig</span><br><span class="line">make CROSS_COMPILE=riscv64-linux-gnu- ARCH=riscv -j4 bindeb-pkg LOCALVERSION=-netfilter</span><br></pre></td></tr></table></figure></li></ol><p>编译完成后<code>..</code>目录会出现三个安装包, 分别为<code>linux-image-*.deb</code>、<code>linux-libc-dev_*.deb</code>与<code>linux-headers-*.deb</code>, 这里我们只需要使用image内核安装包。</p><h2 id="安装内核"><a href="#安装内核" class="headerlink" title="安装内核"></a>安装内核</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dpkg -i linux-image-5.15.0-netfilter_5.15.0-netfilter-1_riscv64.deb <span class="comment">#安装内核</span></span><br><span class="line">dpkg --get-selections | grep linux-image <span class="comment">#查看已安装的内核信息</span></span><br></pre></td></tr></table></figure><p>修改<code>extlinux.conf</code>文件,将默认启动项修改为我们刚刚编译的kernel</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /boot/extlinux/extlinux.conf</span><br></pre></td></tr></table></figure><p>重启系统，查看内核信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">uname</span> -srm</span><br></pre></td></tr></table></figure><h2 id="内核安装失败的问题"><a href="#内核安装失败的问题" class="headerlink" title="内核安装失败的问题"></a>内核安装失败的问题</h2><p>博主在重启失败时出现了内核启动失败的问题，具体问题如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[FAILED] Failed to mount Huge Pages File System.</span><br><span class="line">[FAILED] Failed to mount POSIX Message Queue File System.</span><br><span class="line">[FAILED] Failed to mount Kernel Debug File System.</span><br><span class="line">[FAILED] Failed to mount FUSE Control File System.</span><br><span class="line">[FAILED] Failed to mount Kernel Configuration File System.</span><br></pre></td></tr></table></figure><p>经过了很长时间的筛查，发现是gcc编译器的问题：一开始博主通过目标机编译kernel，而不是交叉编译，而开发板中自带的gcc版本较低，导致编译出来的kernel无法被加载。更换为ubuntu20.04进行交叉编译后，解决了这个问题。</p><h2 id="安装clash"><a href="#安装clash" class="headerlink" title="安装clash"></a>安装clash</h2><p>在开发板上下载clash-core，并解压</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gzip -d clash-linux-riscv64-v1.18.0.gz</span><br><span class="line">install clash-linux-riscv64-v1.18.0 /usr/local/bin/clash</span><br></pre></td></tr></table></figure><p>创建clash的systemd文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/systemd/system/clash.service</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Clash daemon, A rule-based proxy in Go.</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=simple</span><br><span class="line">Restart=always</span><br><span class="line">ExecStart=/usr/local/bin/clash -d /etc/clash</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><p>设置clash为开机启动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> clash --now</span><br><span class="line">systemctl status clash</span><br></pre></td></tr></table></figure><p>配置clash管理页面</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone -b gh-pages --depth 1 https://github.com/haishanh/yacd.git /opt/clash-dashboard</span><br></pre></td></tr></table></figure><h2 id="开启-Linux-内核的转发功能"><a href="#开启-Linux-内核的转发功能" class="headerlink" title="开启 Linux 内核的转发功能"></a>开启 Linux 内核的转发功能</h2><ol><li><p>编辑配置文件 <code>/etc/sysctl.conf</code> 并向其中添加如下内容</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.ip_forward=1</span><br></pre></td></tr></table></figure></li><li><p>保存退出后，执行以下命令使修改生效</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysctl -p</span><br></pre></td></tr></table></figure></li><li><p>查看 <code>/proc/sys/net/ipv4/ip_forward</code> 的内容，如果是 <code>1</code> 表示设置成功生效</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/sys/net/ipv4/ip_forward</span><br></pre></td></tr></table></figure></li></ol><h2 id="配置nftables"><a href="#配置nftables" class="headerlink" title="配置nftables"></a>配置nftables</h2><p>安装nftables</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt -y install nftables</span><br></pre></td></tr></table></figure><p>创建 nftables 配置文件扩展目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir /etc/nftables.conf.d</span><br></pre></td></tr></table></figure><p>创建私有地址的定义文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">define private_list = &#123;</span><br><span class="line">    0.0.0.0/8,</span><br><span class="line">    10.0.0.0/8,</span><br><span class="line">    127.0.0.0/8,</span><br><span class="line">    169.254.0.0/16,</span><br><span class="line">    172.16.0.0/12,</span><br><span class="line">    192.168.0.0/16,</span><br><span class="line">    224.0.0.0/4,</span><br><span class="line">    240.0.0.0/4</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改 nftalbes 配置文件，内容如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/sbin/nft -f</span><br><span class="line"></span><br><span class="line">include &quot;/etc/nftables.conf.d/private.nft&quot;</span><br><span class="line"></span><br><span class="line">table ip nat &#123;</span><br><span class="line">    chain proxy &#123;</span><br><span class="line">        ip daddr $private_list return</span><br><span class="line">            ip protocol tcp redirect to :7892</span><br><span class="line">    &#125;</span><br><span class="line">    chain prerouting &#123;</span><br><span class="line">        type nat hook prerouting priority 0; policy accept;</span><br><span class="line">        jump proxy</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>清空 nftalbes 规则，并使新规则生效, 查看 nftalbes 当前规则</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nft -f /etc/nftables.conf</span><br><span class="line">nft flush ruleset</span><br><span class="line">nft list ruleset</span><br></pre></td></tr></table></figure><p>设置 <code>nftalbes</code> 开机自启动</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable nftables --now</span><br></pre></td></tr></table></figure><h2 id="配置机场订阅"><a href="#配置机场订阅" class="headerlink" title="配置机场订阅"></a>配置机场订阅</h2><p>将机场订阅文件下载至<code>/etc/clash</code>文件夹内, 并添加如下内容。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">external-controller: &#x27;0.0.0.0:9090&#x27;</span><br><span class="line">secret: &#x27;&#x27;</span><br><span class="line">external-ui: /opt/clash-dashboard #web控制台文件地址</span><br></pre></td></tr></table></figure><p>重启clash</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart clash</span><br><span class="line">systemctl status clash</span><br></pre></td></tr></table></figure><p>通过<code>http://server-ip:9090/ui</code>网页访问clash控制台。</p><ul><li><p>测试代理</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> http_proxy=<span class="string">&quot;http://127.0.0.1:7890&quot;</span></span><br><span class="line"><span class="built_in">export</span> https_proxy=<span class="string">&quot;http://127.0.0.1:7890&quot;</span></span><br><span class="line"><span class="built_in">export</span> -p <span class="comment">#查看环境变量</span></span><br><span class="line">curl google.com</span><br></pre></td></tr></table></figure></li><li><p>查看clash日志</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">journalctl -u clash.service</span><br></pre></td></tr></table></figure></li></ul><p>使用了代理后使用apt install出现了如下报错</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">E: Failed to fetch https://snapshot.debian.org/archive/debian-ports/20221225T084846Z/pool/main/t/toilet/toilet-fonts_0.3-1.4_all.deb  Unsupported proxy configured: 127.0.0.1://7890</span><br><span class="line">E: Failed to fetch https://snapshot.debian.org/archive/debian-ports/20221225T084846Z/pool-riscv64/main/t/toilet/toilet_0.3-1.4%2bb1_riscv64.deb  Unsupported proxy configured: 127.0.0.1://7890</span><br><span class="line">E: Failed to fetch https://snapshot.debian.org/archive/debian-ports/20221225T084846Z/pool-riscv64/main/w/w3m/w3m_0.5.3%2bgit20220429-1%2bb2_riscv64.deb  Unsupported proxy configured: 127.0.0.1://7890</span><br></pre></td></tr></table></figure><p>原因为<code>export http_proxy=&quot;http://127.0.0.1:7890&quot;</code>写成了<code>export http_proxy=&quot;127.0.0.1:7890&quot;</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;作者使用的是riscv架构的Visionfive2开发板，本博客内的步骤也适用于其他开发板。交叉编译环境为ubuntu20.04。&lt;/p&gt;
&lt;h2 id=&quot;编译内核&quot;&gt;&lt;a href=&quot;#编译内核&quot; class=&quot;headerlink&quot; title=&quot;编译内核&quot;&gt;&lt;/a&gt;编</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>为使用国产SF19A2890芯片的gl-sft1200路由器编译第三方固件</title>
    <link href="https://big7ng.github.io/2023/09/11/glinet/"/>
    <id>https://big7ng.github.io/2023/09/11/glinet/</id>
    <published>2023-09-11T04:14:10.541Z</published>
    <updated>2023-09-11T12:46:59.166Z</updated>
    
    <content type="html"><![CDATA[<p>因为要在寝室里使用，选来选去最终购买了sft1200这款路由器，看重了它的小巧不占空间以及开放源码。<br><img src="\img\sft1200.jpg" alt="sft1200" style="zoom:50%;" /></p><p>本次编译使用vmware虚拟机，操作系统为ubuntu20.04。</p><h1 id="编译固件"><a href="#编译固件" class="headerlink" title="编译固件"></a>编译固件</h1><p>首先下载第三方固件源码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/Big7ng/openwrt-sf-sft1200.git</span><br></pre></td></tr></table></figure><p>进入openwrt目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> openwrt-18.06</span><br></pre></td></tr></table></figure><p>更新feeds</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./scripts/feeds update -a&amp;&amp; ./scripts/feeds install -a</span><br></pre></td></tr></table></figure><p>根据所使用的路由器型号选择配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> .config.sf1200 .config  <span class="comment">#如果使用sf路由器则 cp .config.sf1200 .config</span></span><br></pre></td></tr></table></figure><p>配置所需要的luci-app以及luci-theme</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make menuconfig</span><br></pre></td></tr></table></figure><p>依次点击LuCI-&gt;Applications\Themes,然后选择需要编译安装的应用,我这里选择安装了Openclash以及argon主题。</p><img src="\img\vmware_sBGwsBqf1i.png" alt="vmware_sBGwsBqf1i" style="zoom:50%;" /><img src="\img\vmware_xfmucOtP3D.png" alt="vmware_xfmucOtP3D" style="zoom: 67%;" /><p>下载编译所需工具，<code>n</code>为使用处理器数量</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make -jn download</span><br><span class="line">make V=s -jn</span><br></pre></td></tr></table></figure><p>使用官方SDK时，下载时会出现xxd工具<a href="https://github.com/openwrt/openwrt/issues/10555">无法下载的问题</a>，具体的原因为源码配置的连接类型为http，而该网站之后拒绝了http请求，导致无法下载，我们只需要将原url中的http改为https即可。</p><p>编译完成后，打开<code>./bin/targets/siflower</code>文件夹，将<code>immortalwrt-siflower-sf19a28-fullmask-glinet_gl-sft1200-squashfs-factory.img</code>文件保存起来为后续烧录使用。</p><h1 id="烧录固件"><a href="#烧录固件" class="headerlink" title="烧录固件"></a>烧录固件</h1><p>如果现在路由器上使用的是官方固件，那么可以打开管理页面进行Web升级，如果路由器上使用的是第三方固件，那么只能使用uboot刷入，如下所示：</p><p>断开电源，将路由器lan口与电脑连接，按住路由器重置键不放，打开电源，路由器灯闪五下后变成白灯，此时将本机ip改为192.168.1.0网段，然后浏览器输入192.168.1.1进入uboot界面，选择之前编译好的固件。</p><img src="\img\dllhost_UQCpNjowUK.png" alt="dllhost_UQCpNjowUK" style="zoom:50%;" /><img src="\img\chrome_HxQKGEsgQF.png" alt="chrome_HxQKGEsgQF" style="zoom:50%;" /><p>烧入固件成功后，连接名为Openwrt的WIFI，连接成功后进入192.168.1.1管理界面，初始账号为root，密码为passwd。</p><img src="/img/image-20230911201258283.png" alt="image-20230911201258283" style="zoom: 33%;" /><h1 id="使用感悟"><a href="#使用感悟" class="headerlink" title="使用感悟"></a>使用感悟</h1><p>矽昌Siflower的SF19A2890使用了MIPS架构，但对该架构进行了修改，导致无法使用已经编译过的MIPS二进制程序，而需要特定工具链进行编译。Openclash提供的MIPS架构clash内核无法在路由器上使用，需要自行编译，待后续有时间再进行了解，目前就先用一下Passwall吧。</p><p>不过Clash的界面做的真心可以，不管是CFW、clash网页界面还是Openclash，都比其它工具好看，导致我更喜欢用clash。</p><p>参考：</p><ul><li><a href="https://www.right.com.cn/forum/thread-7348817-1-7.html">恩山论坛zheshifandian</a></li><li><a href="https://forum.gl-inet.cn/forum.php?mod=viewthread&tid=3215&extra=page=1">glinet论坛mulder125</a></li></ul><p>​</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;因为要在寝室里使用，选来选去最终购买了sft1200这款路由器，看重了它的小巧不占空间以及开放源码。&lt;br&gt;&lt;img src=&quot;&#92;img&#92;sft1200.jpg&quot; alt=&quot;sft1200&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;本次编译使用vmware虚</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>编译安卓源码并修改开机动画</title>
    <link href="https://big7ng.github.io/2023/07/02/android/"/>
    <id>https://big7ng.github.io/2023/07/02/android/</id>
    <published>2023-07-02T14:13:28.032Z</published>
    <updated>2023-07-02T14:36:41.567Z</updated>
    
    <content type="html"><![CDATA[<p>本文将编译安卓源码，使用自带emulator工具对编译后的系统进行模拟运行，并修改开机动画。</p><h1 id="下载源码并编译安卓"><a href="#下载源码并编译安卓" class="headerlink" title="下载源码并编译安卓"></a>下载源码并编译安卓</h1><h3 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install git-core gnupg flex bison build-essential zip curl zlib1g-dev gcc-multilib g++-multilib libc6-dev-i386 libncurses5 lib32ncurses5-dev x11proto-core-dev libx11-dev lib32z1-dev libgl1-mesa-dev libxml2-utils xsltproc unzip fontconfig</span><br></pre></td></tr></table></figure><p>安装repo工具</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> ~/bin</span><br><span class="line"><span class="built_in">export</span> PATH=~/bin:<span class="variable">$PATH</span></span><br><span class="line">curl -sSL  <span class="string">&#x27;https://gerrit-googlesource.proxy.ustclug.org/git-repo/+/master/repo?format=TEXT&#x27;</span> |<span class="built_in">base64</span> -d &gt; ~/bin/repo</span><br><span class="line"><span class="built_in">chmod</span> a+x ~/bin/repo</span><br></pre></td></tr></table></figure><h3 id="下载源码"><a href="#下载源码" class="headerlink" title="下载源码"></a>下载源码</h3><p>使用<code>repo init</code>的方法不稳定，因此从<a href="https://mirrors.ustc.edu.cn/help/aosp.html">中科大镜像源</a>上直接下载aosp镜像tar包，下载完成后进行提取。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xf aosp_latest.tar</span><br></pre></td></tr></table></figure><p>进入提取后的aosp目录，运行如下命令，进行同步。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repo sync</span><br></pre></td></tr></table></figure><h3 id="开始编译"><a href="#开始编译" class="headerlink" title="开始编译"></a>开始编译</h3><p>初始化环境，每次开启Shell时都需要运行该命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> build/envsetup.sh</span><br></pre></td></tr></table></figure><p>通过<code>lunch</code>命令对构建目标进行配置，我这里选择的是<code>sdk_pc_x86_64-userdebug</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lunch sdk_pc_x86_64-userdebug <span class="comment">#也可以只输入lunch命令，再根据提示进行选择</span></span><br></pre></td></tr></table></figure><p>开始构建，可以通过<code>-jN</code>选项设置线程数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m</span><br></pre></td></tr></table></figure><img src="/img/build.png" width="600"><p>本文使用16线程数、16GB内存以及30GB交换空间进行编译，耗时约两个半小时，编译完成后提示：<br><img src="/img/build_finish.png" width="600"></p><h3 id="运行emulator"><a href="#运行emulator" class="headerlink" title="运行emulator"></a>运行emulator</h3><p>编译完成后，使用<code>emulator</code>命令启动模拟器，在启用模拟器前，需要通过<code>lunch</code>进行设置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">emulator</span><br></pre></td></tr></table></figure><img src="/img/boot.png" width="600"><h1 id="修改开机动画"><a href="#修改开机动画" class="headerlink" title="修改开机动画"></a>修改开机动画</h1><p>打开<code>packages/services/Car/car_product/bootanimations/bootanimation-832.zip</code>目录，将<code>bootanimation-832.zip</code>修改为自定义的开机动画即可。</p><p>修改完成后，将下述代码加入编译时使用到的任意makefile即可，我这里选用的是<code>build/make/core/envsetup.mk</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PRODUCT_COPY_FILES += \</span><br><span class="line">  packages/services/Car/car_product/bootanimations/bootanimation-832.zip:system/media/bootanimation.zip</span><br></pre></td></tr></table></figure><p>重新编译，再运行emulator，即可看到修改后的开机动画。<br><img src="/img/boot2.png" width="600"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文将编译安卓源码，使用自带emulator工具对编译后的系统进行模拟运行，并修改开机动画。&lt;/p&gt;
&lt;h1 id=&quot;下载源码并编译安卓&quot;&gt;&lt;a href=&quot;#下载源码并编译安卓&quot; class=&quot;headerlink&quot; title=&quot;下载源码并编译安卓&quot;&gt;&lt;/a&gt;下载源码并</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>通过GitHub Pages托管Hexo个人博客</title>
    <link href="https://big7ng.github.io/2023/06/06/hexo_blog/"/>
    <id>https://big7ng.github.io/2023/06/06/hexo_blog/</id>
    <published>2023-06-06T11:03:07.979Z</published>
    <updated>2023-06-06T11:29:22.230Z</updated>
    
    <content type="html"><![CDATA[<p>本文将介绍如何通过GitHub Pages托管个人静态页面，博客所使用的框架为<a href="https://hexo.io/zh-cn/index.html">Hexo</a>，Hexo主题为<a href="https://github.com/chongshengsun/hexo-theme-apollo">apollo</a>。</p><h2 id="本地环境搭建"><a href="#本地环境搭建" class="headerlink" title="本地环境搭建"></a>本地环境搭建</h2><h4 id="安装Git、Nodejs"><a href="#安装Git、Nodejs" class="headerlink" title="安装Git、Nodejs"></a>安装Git、Nodejs</h4><h4 id="安装配置Hexo"><a href="#安装配置Hexo" class="headerlink" title="安装配置Hexo"></a>安装配置Hexo</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo</span><br></pre></td></tr></table></figure><p>创建文件夹,初始化Hexo</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure><h4 id="安装apollo主题"><a href="#安装apollo主题" class="headerlink" title="安装apollo主题"></a>安装apollo主题</h4><p>安装依赖项(可能会有警告,但可以不管)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save hexo-renderer-jade hexo-generator-feed hexo-generator-sitemap hexo-browsersync hexo-generator-archive</span><br></pre></td></tr></table></figure><p>下载主题文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/chongshengsun/hexo-theme-apollo.git themes/apollo</span><br></pre></td></tr></table></figure><p>修改<code>_config.yml</code>的<code>theme</code>配置项为<code>apollo</code>:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="comment">## Plugins: https://hexo.io/plugins/</span></span><br><span class="line"><span class="comment">## Themes: https://hexo.io/themes/</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">apollo</span></span><br></pre></td></tr></table></figure><p>apollo主题中的标签栏信息可以在<code>./theme/apollo/_config.yml</code>文件中修改。</p><h2 id="GitHub-Pages配置与部署Hexo"><a href="#GitHub-Pages配置与部署Hexo" class="headerlink" title="GitHub Pages配置与部署Hexo"></a>GitHub Pages配置与部署Hexo</h2><p>一开始打算使用Gitee的页面托管，但是使用该服务需要上传身份证照片，不仅麻烦还不方便写一些特殊技术，遂放弃。如何使用GitHub Pages可以参考<a href="https://docs.github.com/en/pages/quickstart">这篇文章</a>。</p><p>配置好GitHub Pages就可以部署Hexo了.</p><h4 id="部署Hexo"><a href="#部署Hexo" class="headerlink" title="部署Hexo"></a>部署Hexo</h4><p>安装 hexo-deployer-git</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>修改<code>_config.yml</code>配置文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">https://github.com/Big7ng/Big7ng.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure><p>在命令行输入如下命令完成部署</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo generate</span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文将介绍如何通过GitHub Pages托管个人静态页面，博客所使用的框架为&lt;a href=&quot;https://hexo.io/zh-cn/index.html&quot;&gt;Hexo&lt;/a&gt;，Hexo主题为&lt;a href=&quot;https://github.com/chongshengs</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://big7ng.github.io/2023/06/05/hello-world/"/>
    <id>https://big7ng.github.io/2023/06/05/hello-world/</id>
    <published>2023-06-05T14:30:49.978Z</published>
    <updated>2023-06-05T14:30:49.978Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
